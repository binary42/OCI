/* -*- C++ -*- */
/* Generated by ../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file DdsDcpsInfrastructure.idl*/
#ifndef OPENDDS_IDL_GENERATED_DDSDCPSINFRASTRUCTURETYPESUPPORTIMPL_H_WT3ACW
#define OPENDDS_IDL_GENERATED_DDSDCPSINFRASTRUCTURETYPESUPPORTIMPL_H_WT3ACW
#include "dds/DCPS/Definitions.h"
#include "DdsDcpsInfrastructureC.h"
#include "DdsDcpsInfrastructureTypeSupportC.h"
#include "dds/DCPS/DataReaderImpl.h"
#include "dds/DCPS/DataWriterImpl.h"
#include "dds/DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/SubscriptionInstance.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "tao/LongSeqC.h"
#include "tao/StringSeqC.h"
#include "dds/DCPS/dcps_export.h"


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BuiltinTopicKeyValue_forany& arr, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BuiltinTopicKeyValue_forany& arr);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BuiltinTopicKeyValue_forany& arr);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKeyValue_forany*);

}  }

#endif

/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin STRUCT: BuiltinTopicKey_t */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BuiltinTopicKey_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BuiltinTopicKey_t& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::BuiltinTopicKey_t>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKey_t*);

}  }

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin TYPEDEF: InstanceHandleSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::InstanceHandleSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::InstanceHandleSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::InstanceHandleSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::InstanceHandleSeq*);

}  }

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin TYPEDEF: StringSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::StringSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::StringSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::StringSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::StringSeq*);

}  }

#endif

/* End TYPEDEF: StringSeq */


/* Begin STRUCT: Duration_t */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::Duration_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::Duration_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::Duration_t& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::Duration_t>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::Duration_t*);

}  }

#endif

/* End STRUCT: Duration_t */


/* Begin STRUCT: Time_t */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::Time_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::Time_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::Time_t& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::Time_t>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::Time_t*);

}  }

#endif

/* End STRUCT: Time_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::InconsistentTopicStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::InconsistentTopicStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::InconsistentTopicStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::InconsistentTopicStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::InconsistentTopicStatus*);

}  }

#endif

/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SampleLostStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleLostStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleLostStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SampleLostStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SampleLostStatus*);

}  }

#endif

/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleRejectedStatusKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleRejectedStatusKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_SampleRejectedStatusKind_names[];
}  }

#endif

/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SampleRejectedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleRejectedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleRejectedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SampleRejectedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SampleRejectedStatus*);

}  }

#endif

/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LivelinessLostStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessLostStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessLostStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LivelinessLostStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::LivelinessLostStatus*);

}  }

#endif

/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LivelinessChangedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessChangedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessChangedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LivelinessChangedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::LivelinessChangedStatus*);

}  }

#endif

/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OfferedDeadlineMissedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OfferedDeadlineMissedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OfferedDeadlineMissedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OfferedDeadlineMissedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::OfferedDeadlineMissedStatus*);

}  }

#endif

/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::RequestedDeadlineMissedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::RequestedDeadlineMissedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::RequestedDeadlineMissedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::RequestedDeadlineMissedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::RequestedDeadlineMissedStatus*);

}  }

#endif

/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: QosPolicyCount */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::QosPolicyCount& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::QosPolicyCount& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::QosPolicyCount>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::QosPolicyCount*);

}  }

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::QosPolicyCountSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::QosPolicyCountSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::QosPolicyCountSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::QosPolicyCountSeq*);

}  }

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin STRUCT: OfferedIncompatibleQosStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OfferedIncompatibleQosStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OfferedIncompatibleQosStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OfferedIncompatibleQosStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OfferedIncompatibleQosStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::OfferedIncompatibleQosStatus*);

}  }

#endif

/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::RequestedIncompatibleQosStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::RequestedIncompatibleQosStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::RequestedIncompatibleQosStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::RequestedIncompatibleQosStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::RequestedIncompatibleQosStatus*);

}  }

#endif

/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PublicationMatchedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PublicationMatchedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PublicationMatchedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PublicationMatchedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::PublicationMatchedStatus*);

}  }

#endif

/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SubscriptionMatchedStatus& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SubscriptionMatchedStatus& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SubscriptionMatchedStatus& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SubscriptionMatchedStatus>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SubscriptionMatchedStatus*);

}  }

#endif

/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin TYPEDEF: ConditionSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ConditionSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ConditionSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ConditionSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::ConditionSeq*);

}  }

#endif

/* End TYPEDEF: ConditionSeq */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin TYPEDEF: OctetSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OctetSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OctetSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OctetSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::OctetSeq*);

}  }

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: UserDataQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::UserDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::UserDataQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::UserDataQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::UserDataQosPolicy*);

}  }

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicDataQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicDataQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::TopicDataQosPolicy*);

}  }

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::GroupDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::GroupDataQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::GroupDataQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::GroupDataQosPolicy*);

}  }

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TransportPriorityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TransportPriorityQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TransportPriorityQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::TransportPriorityQosPolicy*);

}  }

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LifespanQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LifespanQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LifespanQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::LifespanQosPolicy*);

}  }

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: DurabilityQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_DurabilityQosPolicyKind_names[];
}  }

#endif

/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DurabilityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DurabilityQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DurabilityQosPolicy*);

}  }

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PresentationQosPolicyAccessScopeKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PresentationQosPolicyAccessScopeKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[];
}  }

#endif

/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PresentationQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PresentationQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PresentationQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::PresentationQosPolicy*);

}  }

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DeadlineQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DeadlineQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DeadlineQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DeadlineQosPolicy*);

}  }

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LatencyBudgetQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LatencyBudgetQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LatencyBudgetQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::LatencyBudgetQosPolicy*);

}  }

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_OwnershipQosPolicyKind_names[];
}  }

#endif

/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OwnershipQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OwnershipQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::OwnershipQosPolicy*);

}  }

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OwnershipStrengthQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipStrengthQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OwnershipStrengthQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::OwnershipStrengthQosPolicy*);

}  }

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_LivelinessQosPolicyKind_names[];
}  }

#endif

/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LivelinessQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LivelinessQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::LivelinessQosPolicy*);

}  }

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TimeBasedFilterQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TimeBasedFilterQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TimeBasedFilterQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::TimeBasedFilterQosPolicy*);

}  }

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PartitionQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PartitionQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PartitionQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::PartitionQosPolicy*);

}  }

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_ReliabilityQosPolicyKind_names[];
}  }

#endif

/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ReliabilityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ReliabilityQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::ReliabilityQosPolicy*);

}  }

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_DestinationOrderQosPolicyKind_names[];
}  }

#endif

/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DestinationOrderQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DestinationOrderQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DestinationOrderQosPolicy*);

}  }

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::HistoryQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::HistoryQosPolicyKind& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDS_HistoryQosPolicyKind_names[];
}  }

#endif

/* End ENUM: HistoryQosPolicyKind */


/* Begin STRUCT: HistoryQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::HistoryQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::HistoryQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::HistoryQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::HistoryQosPolicy*);

}  }

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ResourceLimitsQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ResourceLimitsQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ResourceLimitsQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::ResourceLimitsQosPolicy*);

}  }

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: EntityFactoryQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::EntityFactoryQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::EntityFactoryQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::EntityFactoryQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::EntityFactoryQosPolicy*);

}  }

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::WriterDataLifecycleQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::WriterDataLifecycleQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::WriterDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::WriterDataLifecycleQosPolicy*);

}  }

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ReaderDataLifecycleQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReaderDataLifecycleQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::ReaderDataLifecycleQosPolicy*);

}  }

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DurabilityServiceQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityServiceQosPolicy& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DurabilityServiceQosPolicy>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DurabilityServiceQosPolicy*);

}  }

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DomainParticipantFactoryQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DomainParticipantFactoryQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DomainParticipantFactoryQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DomainParticipantFactoryQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DomainParticipantFactoryQos*);

}  }

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DomainParticipantQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DomainParticipantQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DomainParticipantQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DomainParticipantQos*);

}  }

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: TopicQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::TopicQos*);

}  }

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: DataWriterQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DataWriterQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DataWriterQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DataWriterQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DataWriterQos*);

}  }

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: PublisherQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PublisherQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PublisherQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PublisherQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::PublisherQos*);

}  }

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: DataReaderQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DataReaderQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DataReaderQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DataReaderQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::DataReaderQos*);

}  }

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SubscriberQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SubscriberQos& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SubscriberQos>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SubscriberQos*);

}  }

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: ParticipantBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ParticipantBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(const DDS::ParticipantBuiltinTopicData&);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::ParticipantBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(KeyOnly<const DDS::ParticipantBuiltinTopicData>);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::ParticipantBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::ParticipantBuiltinTopicData> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_has_key(const DDS::ParticipantBuiltinTopicData&);

}  }

namespace DDS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export ParticipantBuiltinTopicData_KeyLessThan {
  bool operator()(const DDS::ParticipantBuiltinTopicData& v1, const DDS::ParticipantBuiltinTopicData& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
}
namespace DDS {

class ParticipantBuiltinTopicDataDataWriterImpl;
class ParticipantBuiltinTopicDataDataReaderImpl;

/** Servant for TypeSupport interface of ParticipantBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export ParticipantBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef ParticipantBuiltinTopicData                message_type;
  typedef ParticipantBuiltinTopicData_var            message_var;
  typedef ParticipantBuiltinTopicDataTypeSupport     typesupport_type;
  typedef ParticipantBuiltinTopicDataTypeSupport_var typesupport_var;
  typedef ParticipantBuiltinTopicDataDataWriter      datawriter_type;
  typedef ParticipantBuiltinTopicDataDataReader      datareader_type;
  typedef ParticipantBuiltinTopicDataDataWriter_var  datawriter_var;
  typedef ParticipantBuiltinTopicDataDataReader_var  datareader_var;
  typedef ParticipantBuiltinTopicDataDataWriterImpl  datawriterimpl_type;
  typedef ParticipantBuiltinTopicDataDataReaderImpl  datareaderimpl_type;

  ParticipantBuiltinTopicDataTypeSupportImpl();
  virtual ~ParticipantBuiltinTopicDataTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef ParticipantBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;
  typedef ParticipantBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef ParticipantBuiltinTopicDataDataWriter data_writer_type;
  typedef ParticipantBuiltinTopicDataDataReader data_reader_type;
  typedef ::DDS::ParticipantBuiltinTopicData data_sample_type;
  typedef ::DDS::ParticipantBuiltinTopicDataSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return ParticipantBuiltinTopicDataTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the ParticipantBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Dcps_Export ParticipantBuiltinTopicDataDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantBuiltinTopicDataDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef ParticipantBuiltinTopicData                message_type;
  typedef ParticipantBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef ParticipantBuiltinTopicDataDataReaderImpl  datareader_type;

  typedef std::map<DDS::ParticipantBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ParticipantBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  ParticipantBuiltinTopicDataDataWriterImpl (void);

  /// Destructor
  virtual ~ParticipantBuiltinTopicDataDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::DDS::ParticipantBuiltinTopicData & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::DDS::ParticipantBuiltinTopicData & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::DDS::ParticipantBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::DDS::ParticipantBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::DDS::ParticipantBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::DDS::ParticipantBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::DDS::ParticipantBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::DDS::ParticipantBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::ParticipantBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::ParticipantBuiltinTopicData & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::DDS::ParticipantBuiltinTopicData& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::DDS::ParticipantBuiltinTopicData& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of ParticipantBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export ParticipantBuiltinTopicDataDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantBuiltinTopicDataDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef ParticipantBuiltinTopicData                message_type;
  typedef ParticipantBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef ParticipantBuiltinTopicDataDataWriterImpl  datawriter_type;

  typedef std::map<DDS::ParticipantBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ParticipantBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<DDS::ParticipantBuiltinTopicData, ACE_Null_Mutex>  DataAllocator;
  typedef ParticipantBuiltinTopicDataDataReader Interface;

  /// Constructor
  ParticipantBuiltinTopicDataDataReaderImpl (void);

  /// Destructor
  virtual ~ParticipantBuiltinTopicDataDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::DDS::ParticipantBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::DDS::ParticipantBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::DDS::ParticipantBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::DDS::ParticipantBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::DDS::ParticipantBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::DDS::ParticipantBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::ParticipantBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::ParticipantBuiltinTopicData & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::DDS::ParticipantBuiltinTopicDataSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const DDS::ParticipantBuiltinTopicData& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::DDS::ParticipantBuiltinTopicData *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ParticipantBuiltinTopicData>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::ParticipantBuiltinTopicData*);

}  }

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(const DDS::TopicBuiltinTopicData&);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::TopicBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(KeyOnly<const DDS::TopicBuiltinTopicData>);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::TopicBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::TopicBuiltinTopicData> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_has_key(const DDS::TopicBuiltinTopicData&);

}  }

namespace DDS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export TopicBuiltinTopicData_KeyLessThan {
  bool operator()(const DDS::TopicBuiltinTopicData& v1, const DDS::TopicBuiltinTopicData& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
}
namespace DDS {

class TopicBuiltinTopicDataDataWriterImpl;
class TopicBuiltinTopicDataDataReaderImpl;

/** Servant for TypeSupport interface of TopicBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export TopicBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef TopicBuiltinTopicData                message_type;
  typedef TopicBuiltinTopicData_var            message_var;
  typedef TopicBuiltinTopicDataTypeSupport     typesupport_type;
  typedef TopicBuiltinTopicDataTypeSupport_var typesupport_var;
  typedef TopicBuiltinTopicDataDataWriter      datawriter_type;
  typedef TopicBuiltinTopicDataDataReader      datareader_type;
  typedef TopicBuiltinTopicDataDataWriter_var  datawriter_var;
  typedef TopicBuiltinTopicDataDataReader_var  datareader_var;
  typedef TopicBuiltinTopicDataDataWriterImpl  datawriterimpl_type;
  typedef TopicBuiltinTopicDataDataReaderImpl  datareaderimpl_type;

  TopicBuiltinTopicDataTypeSupportImpl();
  virtual ~TopicBuiltinTopicDataTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef TopicBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;
  typedef TopicBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef TopicBuiltinTopicDataDataWriter data_writer_type;
  typedef TopicBuiltinTopicDataDataReader data_reader_type;
  typedef ::DDS::TopicBuiltinTopicData data_sample_type;
  typedef ::DDS::TopicBuiltinTopicDataSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return TopicBuiltinTopicDataTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the TopicBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Dcps_Export TopicBuiltinTopicDataDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicBuiltinTopicDataDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef TopicBuiltinTopicData                message_type;
  typedef TopicBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef TopicBuiltinTopicDataDataReaderImpl  datareader_type;

  typedef std::map<DDS::TopicBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  TopicBuiltinTopicDataDataWriterImpl (void);

  /// Destructor
  virtual ~TopicBuiltinTopicDataDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::DDS::TopicBuiltinTopicData & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::DDS::TopicBuiltinTopicData & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::DDS::TopicBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::DDS::TopicBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::DDS::TopicBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::DDS::TopicBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::DDS::TopicBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::DDS::TopicBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::TopicBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::TopicBuiltinTopicData & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::DDS::TopicBuiltinTopicData& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::DDS::TopicBuiltinTopicData& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of TopicBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export TopicBuiltinTopicDataDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicBuiltinTopicDataDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef TopicBuiltinTopicData                message_type;
  typedef TopicBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef TopicBuiltinTopicDataDataWriterImpl  datawriter_type;

  typedef std::map<DDS::TopicBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<DDS::TopicBuiltinTopicData, ACE_Null_Mutex>  DataAllocator;
  typedef TopicBuiltinTopicDataDataReader Interface;

  /// Constructor
  TopicBuiltinTopicDataDataReaderImpl (void);

  /// Destructor
  virtual ~TopicBuiltinTopicDataDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::DDS::TopicBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::DDS::TopicBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::DDS::TopicBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::DDS::TopicBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::DDS::TopicBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::DDS::TopicBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::TopicBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::TopicBuiltinTopicData & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::DDS::TopicBuiltinTopicDataSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const DDS::TopicBuiltinTopicData& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::DDS::TopicBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::DDS::TopicBuiltinTopicData *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::DDS::TopicBuiltinTopicDataSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicBuiltinTopicData>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::TopicBuiltinTopicData*);

}  }

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PublicationBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(const DDS::PublicationBuiltinTopicData&);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::PublicationBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(KeyOnly<const DDS::PublicationBuiltinTopicData>);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::PublicationBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::PublicationBuiltinTopicData> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_has_key(const DDS::PublicationBuiltinTopicData&);

}  }

namespace DDS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export PublicationBuiltinTopicData_KeyLessThan {
  bool operator()(const DDS::PublicationBuiltinTopicData& v1, const DDS::PublicationBuiltinTopicData& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
}
namespace DDS {

class PublicationBuiltinTopicDataDataWriterImpl;
class PublicationBuiltinTopicDataDataReaderImpl;

/** Servant for TypeSupport interface of PublicationBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export PublicationBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef PublicationBuiltinTopicData                message_type;
  typedef PublicationBuiltinTopicData_var            message_var;
  typedef PublicationBuiltinTopicDataTypeSupport     typesupport_type;
  typedef PublicationBuiltinTopicDataTypeSupport_var typesupport_var;
  typedef PublicationBuiltinTopicDataDataWriter      datawriter_type;
  typedef PublicationBuiltinTopicDataDataReader      datareader_type;
  typedef PublicationBuiltinTopicDataDataWriter_var  datawriter_var;
  typedef PublicationBuiltinTopicDataDataReader_var  datareader_var;
  typedef PublicationBuiltinTopicDataDataWriterImpl  datawriterimpl_type;
  typedef PublicationBuiltinTopicDataDataReaderImpl  datareaderimpl_type;

  PublicationBuiltinTopicDataTypeSupportImpl();
  virtual ~PublicationBuiltinTopicDataTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef PublicationBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;
  typedef PublicationBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef PublicationBuiltinTopicDataDataWriter data_writer_type;
  typedef PublicationBuiltinTopicDataDataReader data_reader_type;
  typedef ::DDS::PublicationBuiltinTopicData data_sample_type;
  typedef ::DDS::PublicationBuiltinTopicDataSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return PublicationBuiltinTopicDataTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the PublicationBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Dcps_Export PublicationBuiltinTopicDataDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationBuiltinTopicDataDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef PublicationBuiltinTopicData                message_type;
  typedef PublicationBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef PublicationBuiltinTopicDataDataReaderImpl  datareader_type;

  typedef std::map<DDS::PublicationBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublicationBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  PublicationBuiltinTopicDataDataWriterImpl (void);

  /// Destructor
  virtual ~PublicationBuiltinTopicDataDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::DDS::PublicationBuiltinTopicData & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::DDS::PublicationBuiltinTopicData & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::DDS::PublicationBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::DDS::PublicationBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::DDS::PublicationBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::DDS::PublicationBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::DDS::PublicationBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::DDS::PublicationBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::PublicationBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::PublicationBuiltinTopicData & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::DDS::PublicationBuiltinTopicData& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::DDS::PublicationBuiltinTopicData& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of PublicationBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export PublicationBuiltinTopicDataDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationBuiltinTopicDataDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef PublicationBuiltinTopicData                message_type;
  typedef PublicationBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef PublicationBuiltinTopicDataDataWriterImpl  datawriter_type;

  typedef std::map<DDS::PublicationBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublicationBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<DDS::PublicationBuiltinTopicData, ACE_Null_Mutex>  DataAllocator;
  typedef PublicationBuiltinTopicDataDataReader Interface;

  /// Constructor
  PublicationBuiltinTopicDataDataReaderImpl (void);

  /// Destructor
  virtual ~PublicationBuiltinTopicDataDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::DDS::PublicationBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::DDS::PublicationBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::DDS::PublicationBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::DDS::PublicationBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::DDS::PublicationBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::DDS::PublicationBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::PublicationBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::PublicationBuiltinTopicData & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::DDS::PublicationBuiltinTopicDataSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const DDS::PublicationBuiltinTopicData& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::DDS::PublicationBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::DDS::PublicationBuiltinTopicData *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::DDS::PublicationBuiltinTopicDataSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PublicationBuiltinTopicData>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::PublicationBuiltinTopicData*);

}  }

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SubscriptionBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(const DDS::SubscriptionBuiltinTopicData&);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::SubscriptionBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
bool gen_is_bounded_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData>);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::SubscriptionBuiltinTopicData> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_has_key(const DDS::SubscriptionBuiltinTopicData&);

}  }

namespace DDS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export SubscriptionBuiltinTopicData_KeyLessThan {
  bool operator()(const DDS::SubscriptionBuiltinTopicData& v1, const DDS::SubscriptionBuiltinTopicData& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
}
namespace DDS {

class SubscriptionBuiltinTopicDataDataWriterImpl;
class SubscriptionBuiltinTopicDataDataReaderImpl;

/** Servant for TypeSupport interface of SubscriptionBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export SubscriptionBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef SubscriptionBuiltinTopicData                message_type;
  typedef SubscriptionBuiltinTopicData_var            message_var;
  typedef SubscriptionBuiltinTopicDataTypeSupport     typesupport_type;
  typedef SubscriptionBuiltinTopicDataTypeSupport_var typesupport_var;
  typedef SubscriptionBuiltinTopicDataDataWriter      datawriter_type;
  typedef SubscriptionBuiltinTopicDataDataReader      datareader_type;
  typedef SubscriptionBuiltinTopicDataDataWriter_var  datawriter_var;
  typedef SubscriptionBuiltinTopicDataDataReader_var  datareader_var;
  typedef SubscriptionBuiltinTopicDataDataWriterImpl  datawriterimpl_type;
  typedef SubscriptionBuiltinTopicDataDataReaderImpl  datareaderimpl_type;

  SubscriptionBuiltinTopicDataTypeSupportImpl();
  virtual ~SubscriptionBuiltinTopicDataTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef SubscriptionBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;
  typedef SubscriptionBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef SubscriptionBuiltinTopicDataDataWriter data_writer_type;
  typedef SubscriptionBuiltinTopicDataDataReader data_reader_type;
  typedef ::DDS::SubscriptionBuiltinTopicData data_sample_type;
  typedef ::DDS::SubscriptionBuiltinTopicDataSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return SubscriptionBuiltinTopicDataTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the SubscriptionBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Dcps_Export SubscriptionBuiltinTopicDataDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionBuiltinTopicDataDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef SubscriptionBuiltinTopicData                message_type;
  typedef SubscriptionBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef SubscriptionBuiltinTopicDataDataReaderImpl  datareader_type;

  typedef std::map<DDS::SubscriptionBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriptionBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  SubscriptionBuiltinTopicDataDataWriterImpl (void);

  /// Destructor
  virtual ~SubscriptionBuiltinTopicDataDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::DDS::SubscriptionBuiltinTopicData & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::DDS::SubscriptionBuiltinTopicData & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::DDS::SubscriptionBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::DDS::SubscriptionBuiltinTopicData & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::SubscriptionBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::DDS::SubscriptionBuiltinTopicData& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::DDS::SubscriptionBuiltinTopicData& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of SubscriptionBuiltinTopicData data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Dcps_Export SubscriptionBuiltinTopicDataDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionBuiltinTopicDataDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef SubscriptionBuiltinTopicData                message_type;
  typedef SubscriptionBuiltinTopicDataTypeSupportImpl typesupportimpl_type;
  typedef SubscriptionBuiltinTopicDataDataWriterImpl  datawriter_type;

  typedef std::map<DDS::SubscriptionBuiltinTopicData, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriptionBuiltinTopicData_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<DDS::SubscriptionBuiltinTopicData, ACE_Null_Mutex>  DataAllocator;
  typedef SubscriptionBuiltinTopicDataDataReader Interface;

  /// Constructor
  SubscriptionBuiltinTopicDataDataReaderImpl (void);

  /// Destructor
  virtual ~SubscriptionBuiltinTopicDataDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::DDS::SubscriptionBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::DDS::SubscriptionBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::DDS::SubscriptionBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::DDS::SubscriptionBuiltinTopicData & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::DDS::SubscriptionBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::DDS::SubscriptionBuiltinTopicDataSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::DDS::SubscriptionBuiltinTopicData & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::DDS::SubscriptionBuiltinTopicData & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::DDS::SubscriptionBuiltinTopicDataSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const DDS::SubscriptionBuiltinTopicData& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::DDS::SubscriptionBuiltinTopicData *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SubscriptionBuiltinTopicData>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SubscriptionBuiltinTopicData*);

}  }

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */


/* Begin STRUCT: SampleInfo */

namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SampleInfo& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleInfo& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SampleInfo>();
OpenDDS_Dcps_Export
void gen_skip_over(Serializer& ser, DDS::SampleInfo*);

}  }

#endif

/* End STRUCT: SampleInfo */


/* Begin NATIVE: SampleInfoSeq */


/* End NATIVE: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
#endif /* OPENDDS_IDL_GENERATED_DDSDCPSINFRASTRUCTURETYPESUPPORTIMPL_H_WT3ACW */
