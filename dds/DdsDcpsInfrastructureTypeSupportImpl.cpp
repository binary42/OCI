/* Generated by ../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file DdsDcpsInfrastructure.idl*/
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsInfrastructureTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/CorbaSeq/OctetSeqTypeSupportImpl.h"
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::BuiltinTopicKeyValue_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 3 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const DDS::BuiltinTopicKeyValue_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 3);
}

bool operator>>(Serializer& strm, DDS::BuiltinTopicKeyValue_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 3);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKeyValue_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(3, 4);
}

}  }

#endif

/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin STRUCT: BuiltinTopicKey_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::BuiltinTopicKey_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::BuiltinTopicKey_t> : MetaStruct {
  typedef DDS::BuiltinTopicKey_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::BuiltinTopicKey_t& typed = *static_cast<const DDS::BuiltinTopicKey_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::BuiltinTopicKeyValue_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::BuiltinTopicKey_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      DDS::BuiltinTopicKeyValue* lhsArr = &static_cast<T*>(lhs)->value;
      const DDS::BuiltinTopicKeyValue* rhsArr = static_cast<const DDS::BuiltinTopicKeyValue*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::BuiltinTopicKey_t>()
{
  static MetaStructImpl<DDS::BuiltinTopicKey_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKey_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::BuiltinTopicKey_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin TYPEDEF: InstanceHandleSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::InstanceHandleSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::InstanceHandleSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin TYPEDEF: StringSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::StringSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    find_size_ulong(size, padding);
    if (seq[i]) {
      size += ACE_OS::strlen(seq[i]) + 1;
    }
  }
}

bool operator<<(Serializer& strm, const DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq.get_buffer()[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::StringSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }

#endif

/* End TYPEDEF: StringSeq */


/* Begin STRUCT: Duration_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::Duration_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sec);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.nanosec);
}

bool operator<<(Serializer& strm, const DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm, DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sec)
    && (strm >> stru.nanosec);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::Duration_t> : MetaStruct {
  typedef DDS::Duration_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::Duration_t& typed = *static_cast<const DDS::Duration_t*>(stru);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::Duration_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::Duration_t>()
{
  static MetaStructImpl<DDS::Duration_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::Duration_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Duration_t */


/* Begin STRUCT: Time_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::Time_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sec);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.nanosec);
}

bool operator<<(Serializer& strm, const DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm, DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sec)
    && (strm >> stru.nanosec);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::Time_t> : MetaStruct {
  typedef DDS::Time_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::Time_t& typed = *static_cast<const DDS::Time_t*>(stru);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::Time_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::Time_t>()
{
  static MetaStructImpl<DDS::Time_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::Time_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Time_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::InconsistentTopicStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
}

bool operator<<(Serializer& strm, const DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm, DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::InconsistentTopicStatus> : MetaStruct {
  typedef DDS::InconsistentTopicStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::InconsistentTopicStatus& typed = *static_cast<const DDS::InconsistentTopicStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::InconsistentTopicStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::InconsistentTopicStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::InconsistentTopicStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::InconsistentTopicStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::InconsistentTopicStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::InconsistentTopicStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::InconsistentTopicStatus>()
{
  static MetaStructImpl<DDS::InconsistentTopicStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::InconsistentTopicStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::InconsistentTopicStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SampleLostStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
}

bool operator<<(Serializer& strm, const DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm, DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SampleLostStatus> : MetaStruct {
  typedef DDS::SampleLostStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SampleLostStatus& typed = *static_cast<const DDS::SampleLostStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleLostStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SampleLostStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleLostStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleLostStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleLostStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleLostStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SampleLostStatus>()
{
  static MetaStructImpl<DDS::SampleLostStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SampleLostStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SampleLostStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::SampleRejectedStatusKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::SampleRejectedStatusKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::SampleRejectedStatusKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_SampleRejectedStatusKind_names[] = {
  "NOT_REJECTED",
  "REJECTED_BY_INSTANCES_LIMIT",
  "REJECTED_BY_SAMPLES_LIMIT",
  "REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT"
};
}  }

#endif

/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SampleRejectedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  find_size_ulong(size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_reason)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm, DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.last_reason)
    && (strm >> stru.last_instance_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SampleRejectedStatus> : MetaStruct {
  typedef DDS::SampleRejectedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SampleRejectedStatus& typed = *static_cast<const DDS::SampleRejectedStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return gen_DDS_SampleRejectedStatusKind_names[typed.last_reason];
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleRejectedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_reason") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_reason' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SampleRejectedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return make_field_cmp(&T::last_reason, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleRejectedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_reason", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return &static_cast<const T*>(stru)->last_reason;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleRejectedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      static_cast<T*>(lhs)->last_reason = *static_cast<const DDS::SampleRejectedStatusKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleRejectedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return static_cast<const T*>(lhs)->last_reason == static_cast<const T*>(rhs)->last_reason;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleRejectedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SampleRejectedStatus>()
{
  static MetaStructImpl<DDS::SampleRejectedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SampleRejectedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SampleRejectedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LivelinessLostStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
}

bool operator<<(Serializer& strm, const DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm, DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LivelinessLostStatus> : MetaStruct {
  typedef DDS::LivelinessLostStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LivelinessLostStatus& typed = *static_cast<const DDS::LivelinessLostStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessLostStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::LivelinessLostStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessLostStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessLostStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessLostStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessLostStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LivelinessLostStatus>()
{
  static MetaStructImpl<DDS::LivelinessLostStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LivelinessLostStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LivelinessLostStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LivelinessChangedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.alive_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.not_alive_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.alive_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.not_alive_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_publication_handle);
}

bool operator<<(Serializer& strm, const DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.alive_count)
    && (strm << stru.not_alive_count)
    && (strm << stru.alive_count_change)
    && (strm << stru.not_alive_count_change)
    && (strm << stru.last_publication_handle);
}

bool operator>>(Serializer& strm, DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.alive_count)
    && (strm >> stru.not_alive_count)
    && (strm >> stru.alive_count_change)
    && (strm >> stru.not_alive_count_change)
    && (strm >> stru.last_publication_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LivelinessChangedStatus> : MetaStruct {
  typedef DDS::LivelinessChangedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LivelinessChangedStatus& typed = *static_cast<const DDS::LivelinessChangedStatus*>(stru);
    if (std::strcmp(field, "alive_count") == 0) {
      return typed.alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return typed.not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return typed.alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return typed.not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return typed.last_publication_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessChangedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "alive_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'alive_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'not_alive_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'alive_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'not_alive_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_publication_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::LivelinessChangedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "alive_count") == 0) {
      return make_field_cmp(&T::alive_count, next);
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return make_field_cmp(&T::not_alive_count, next);
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return make_field_cmp(&T::alive_count_change, next);
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return make_field_cmp(&T::not_alive_count_change, next);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return make_field_cmp(&T::last_publication_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessChangedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"alive_count", "not_alive_count", "alive_count_change", "not_alive_count_change", "last_publication_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "alive_count") == 0) {
      return &static_cast<const T*>(stru)->alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return &static_cast<const T*>(stru)->not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return &static_cast<const T*>(stru)->alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return &static_cast<const T*>(stru)->not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return &static_cast<const T*>(stru)->last_publication_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessChangedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "alive_count") == 0) {
      static_cast<T*>(lhs)->alive_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      static_cast<T*>(lhs)->not_alive_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      static_cast<T*>(lhs)->alive_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      static_cast<T*>(lhs)->not_alive_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      static_cast<T*>(lhs)->last_publication_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessChangedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "alive_count") == 0) {
      return static_cast<const T*>(lhs)->alive_count == static_cast<const T*>(rhs)->alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return static_cast<const T*>(lhs)->not_alive_count == static_cast<const T*>(rhs)->not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return static_cast<const T*>(lhs)->alive_count_change == static_cast<const T*>(rhs)->alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return static_cast<const T*>(lhs)->not_alive_count_change == static_cast<const T*>(rhs)->not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return static_cast<const T*>(lhs)->last_publication_handle == static_cast<const T*>(rhs)->last_publication_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessChangedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LivelinessChangedStatus>()
{
  static MetaStructImpl<DDS::LivelinessChangedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LivelinessChangedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LivelinessChangedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OfferedDeadlineMissedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm, DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.last_instance_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OfferedDeadlineMissedStatus> : MetaStruct {
  typedef DDS::OfferedDeadlineMissedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OfferedDeadlineMissedStatus& typed = *static_cast<const DDS::OfferedDeadlineMissedStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedDeadlineMissedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::OfferedDeadlineMissedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedDeadlineMissedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedDeadlineMissedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedDeadlineMissedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedDeadlineMissedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OfferedDeadlineMissedStatus>()
{
  static MetaStructImpl<DDS::OfferedDeadlineMissedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OfferedDeadlineMissedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OfferedDeadlineMissedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::RequestedDeadlineMissedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm, DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.last_instance_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::RequestedDeadlineMissedStatus> : MetaStruct {
  typedef DDS::RequestedDeadlineMissedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::RequestedDeadlineMissedStatus& typed = *static_cast<const DDS::RequestedDeadlineMissedStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedDeadlineMissedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::RequestedDeadlineMissedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedDeadlineMissedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedDeadlineMissedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedDeadlineMissedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedDeadlineMissedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::RequestedDeadlineMissedStatus>()
{
  static MetaStructImpl<DDS::RequestedDeadlineMissedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::RequestedDeadlineMissedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::RequestedDeadlineMissedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: QosPolicyCount */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::QosPolicyCount& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.policy_id);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.count);
}

bool operator<<(Serializer& strm, const DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.policy_id)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.policy_id)
    && (strm >> stru.count);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::QosPolicyCount> : MetaStruct {
  typedef DDS::QosPolicyCount T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::QosPolicyCount& typed = *static_cast<const DDS::QosPolicyCount*>(stru);
    if (std::strcmp(field, "policy_id") == 0) {
      return typed.policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return typed.count;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'policy_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::QosPolicyCount");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "policy_id") == 0) {
      return make_field_cmp(&T::policy_id, next);
    }
    if (std::strcmp(field, "count") == 0) {
      return make_field_cmp(&T::count, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"policy_id", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "policy_id") == 0) {
      return &static_cast<const T*>(stru)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "policy_id") == 0) {
      static_cast<T*>(lhs)->policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "policy_id") == 0) {
      return static_cast<const T*>(lhs)->policy_id == static_cast<const T*>(rhs)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return static_cast<const T*>(lhs)->count == static_cast<const T*>(rhs)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::QosPolicyCount>()
{
  static MetaStructImpl<DDS::QosPolicyCount> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::QosPolicyCount*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::QosPolicyCount>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::QosPolicyCountSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::QosPolicyCountSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<DDS::QosPolicyCount*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin STRUCT: OfferedIncompatibleQosStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OfferedIncompatibleQosStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_policy_id);
  gen_find_size(stru.policies, size, padding);
}

bool operator<<(Serializer& strm, const DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm, DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.last_policy_id)
    && (strm >> stru.policies);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OfferedIncompatibleQosStatus> : MetaStruct {
  typedef DDS::OfferedIncompatibleQosStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OfferedIncompatibleQosStatus& typed = *static_cast<const DDS::OfferedIncompatibleQosStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedIncompatibleQosStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<DDS::QosPolicyCountSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::OfferedIncompatibleQosStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedIncompatibleQosStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedIncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedIncompatibleQosStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OfferedIncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OfferedIncompatibleQosStatus>()
{
  static MetaStructImpl<DDS::OfferedIncompatibleQosStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OfferedIncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OfferedIncompatibleQosStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::RequestedIncompatibleQosStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_policy_id);
  gen_find_size(stru.policies, size, padding);
}

bool operator<<(Serializer& strm, const DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm, DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.last_policy_id)
    && (strm >> stru.policies);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::RequestedIncompatibleQosStatus> : MetaStruct {
  typedef DDS::RequestedIncompatibleQosStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::RequestedIncompatibleQosStatus& typed = *static_cast<const DDS::RequestedIncompatibleQosStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedIncompatibleQosStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<DDS::QosPolicyCountSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::RequestedIncompatibleQosStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedIncompatibleQosStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedIncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedIncompatibleQosStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::RequestedIncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::RequestedIncompatibleQosStatus>()
{
  static MetaStructImpl<DDS::RequestedIncompatibleQosStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::RequestedIncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::RequestedIncompatibleQosStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PublicationMatchedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.current_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.current_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_subscription_handle);
}

bool operator<<(Serializer& strm, const DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.current_count)
    && (strm << stru.current_count_change)
    && (strm << stru.last_subscription_handle);
}

bool operator>>(Serializer& strm, DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.current_count)
    && (strm >> stru.current_count_change)
    && (strm >> stru.last_subscription_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PublicationMatchedStatus> : MetaStruct {
  typedef DDS::PublicationMatchedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PublicationMatchedStatus& typed = *static_cast<const DDS::PublicationMatchedStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return typed.current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return typed.current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return typed.last_subscription_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationMatchedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "current_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'current_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'current_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_subscription_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::PublicationMatchedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "current_count") == 0) {
      return make_field_cmp(&T::current_count, next);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return make_field_cmp(&T::current_count_change, next);
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return make_field_cmp(&T::last_subscription_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationMatchedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "current_count", "current_count_change", "last_subscription_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return &static_cast<const T*>(stru)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return &static_cast<const T*>(stru)->current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return &static_cast<const T*>(stru)->last_subscription_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationMatchedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count") == 0) {
      static_cast<T*>(lhs)->current_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      static_cast<T*>(lhs)->current_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      static_cast<T*>(lhs)->last_subscription_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationMatchedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return static_cast<const T*>(lhs)->current_count == static_cast<const T*>(rhs)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return static_cast<const T*>(lhs)->current_count_change == static_cast<const T*>(rhs)->current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return static_cast<const T*>(lhs)->last_subscription_handle == static_cast<const T*>(rhs)->last_subscription_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationMatchedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PublicationMatchedStatus>()
{
  static MetaStructImpl<DDS::PublicationMatchedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PublicationMatchedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PublicationMatchedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SubscriptionMatchedStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.current_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.current_count_change);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_publication_handle);
}

bool operator<<(Serializer& strm, const DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.current_count)
    && (strm << stru.current_count_change)
    && (strm << stru.last_publication_handle);
}

bool operator>>(Serializer& strm, DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.total_count_change)
    && (strm >> stru.current_count)
    && (strm >> stru.current_count_change)
    && (strm >> stru.last_publication_handle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SubscriptionMatchedStatus> : MetaStruct {
  typedef DDS::SubscriptionMatchedStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SubscriptionMatchedStatus& typed = *static_cast<const DDS::SubscriptionMatchedStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return typed.current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return typed.current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return typed.last_publication_handle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionMatchedStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "current_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'current_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'current_count_change' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_publication_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SubscriptionMatchedStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "current_count") == 0) {
      return make_field_cmp(&T::current_count, next);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return make_field_cmp(&T::current_count_change, next);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return make_field_cmp(&T::last_publication_handle, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionMatchedStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "current_count", "current_count_change", "last_publication_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return &static_cast<const T*>(stru)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return &static_cast<const T*>(stru)->current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return &static_cast<const T*>(stru)->last_publication_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionMatchedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count") == 0) {
      static_cast<T*>(lhs)->current_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      static_cast<T*>(lhs)->current_count_change = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      static_cast<T*>(lhs)->last_publication_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionMatchedStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return static_cast<const T*>(lhs)->current_count == static_cast<const T*>(rhs)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return static_cast<const T*>(lhs)->current_count_change == static_cast<const T*>(rhs)->current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return static_cast<const T*>(lhs)->last_publication_handle == static_cast<const T*>(rhs)->last_publication_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionMatchedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SubscriptionMatchedStatus>()
{
  static MetaStructImpl<DDS::SubscriptionMatchedStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SubscriptionMatchedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SubscriptionMatchedStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin TYPEDEF: ConditionSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ConditionSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  // sequence of objrefs is not marshaled
}

bool operator<<(Serializer& strm, const DDS::ConditionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return false; // sequence of objrefs is not marshaled
}

bool operator>>(Serializer& strm, DDS::ConditionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  return false; // sequence of objrefs is not marshaled
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::ConditionSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }

#endif

/* End TYPEDEF: ConditionSeq */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin TYPEDEF: OctetSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OctetSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_octet_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_octet_array(seq.get_buffer(), length);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::OctetSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: UserDataQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::UserDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::UserDataQosPolicy> : MetaStruct {
  typedef DDS::UserDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::UserDataQosPolicy& typed = *static_cast<const DDS::UserDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::UserDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::UserDataQosPolicy>()
{
  static MetaStructImpl<DDS::UserDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::UserDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::UserDataQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicDataQosPolicy> : MetaStruct {
  typedef DDS::TopicDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicDataQosPolicy& typed = *static_cast<const DDS::TopicDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::TopicDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicDataQosPolicy>()
{
  static MetaStructImpl<DDS::TopicDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicDataQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::GroupDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::GroupDataQosPolicy> : MetaStruct {
  typedef DDS::GroupDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::GroupDataQosPolicy& typed = *static_cast<const DDS::GroupDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::GroupDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::GroupDataQosPolicy>()
{
  static MetaStructImpl<DDS::GroupDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::GroupDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::GroupDataQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TransportPriorityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TransportPriorityQosPolicy> : MetaStruct {
  typedef DDS::TransportPriorityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TransportPriorityQosPolicy& typed = *static_cast<const DDS::TransportPriorityQosPolicy*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::TransportPriorityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TransportPriorityQosPolicy>()
{
  static MetaStructImpl<DDS::TransportPriorityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TransportPriorityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TransportPriorityQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LifespanQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm, DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.duration);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LifespanQosPolicy> : MetaStruct {
  typedef DDS::LifespanQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LifespanQosPolicy& typed = *static_cast<const DDS::LifespanQosPolicy*>(stru);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::LifespanQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LifespanQosPolicy>()
{
  static MetaStructImpl<DDS::LifespanQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LifespanQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LifespanQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: DurabilityQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::DurabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DurabilityQosPolicyKind_names[] = {
  "VOLATILE_DURABILITY_QOS",
  "TRANSIENT_LOCAL_DURABILITY_QOS",
  "TRANSIENT_DURABILITY_QOS",
  "PERSISTENT_DURABILITY_QOS"
};
}  }

#endif

/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DurabilityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DurabilityQosPolicy> : MetaStruct {
  typedef DDS::DurabilityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DurabilityQosPolicy& typed = *static_cast<const DDS::DurabilityQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DurabilityQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DurabilityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DurabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DurabilityQosPolicy>()
{
  static MetaStructImpl<DDS::DurabilityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DurabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DurabilityQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::PresentationQosPolicyAccessScopeKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[] = {
  "INSTANCE_PRESENTATION_QOS",
  "TOPIC_PRESENTATION_QOS",
  "GROUP_PRESENTATION_QOS"
};
}  }

#endif

/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PresentationQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.coherent_access));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator<<(Serializer& strm, const DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.access_scope)
    && (strm << ACE_OutputCDR::from_boolean(stru.coherent_access))
    && (strm << ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator>>(Serializer& strm, DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.access_scope)
    && (strm >> ACE_InputCDR::to_boolean(stru.coherent_access))
    && (strm >> ACE_InputCDR::to_boolean(stru.ordered_access));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PresentationQosPolicy> : MetaStruct {
  typedef DDS::PresentationQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PresentationQosPolicy& typed = *static_cast<const DDS::PresentationQosPolicy*>(stru);
    if (std::strcmp(field, "access_scope") == 0) {
      return gen_DDS_PresentationQosPolicyAccessScopeKind_names[typed.access_scope];
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return typed.coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return typed.ordered_access;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "access_scope") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'access_scope' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'coherent_access' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ordered_access' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::PresentationQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "access_scope") == 0) {
      return make_field_cmp(&T::access_scope, next);
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return make_field_cmp(&T::coherent_access, next);
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return make_field_cmp(&T::ordered_access, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"access_scope", "coherent_access", "ordered_access", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "access_scope") == 0) {
      return &static_cast<const T*>(stru)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return &static_cast<const T*>(stru)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return &static_cast<const T*>(stru)->ordered_access;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "access_scope") == 0) {
      static_cast<T*>(lhs)->access_scope = *static_cast<const DDS::PresentationQosPolicyAccessScopeKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      static_cast<T*>(lhs)->coherent_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      static_cast<T*>(lhs)->ordered_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "access_scope") == 0) {
      return static_cast<const T*>(lhs)->access_scope == static_cast<const T*>(rhs)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return static_cast<const T*>(lhs)->coherent_access == static_cast<const T*>(rhs)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return static_cast<const T*>(lhs)->ordered_access == static_cast<const T*>(rhs)->ordered_access;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PresentationQosPolicy>()
{
  static MetaStructImpl<DDS::PresentationQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PresentationQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PresentationQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DeadlineQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.period, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.period);
}

bool operator>>(Serializer& strm, DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.period);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DeadlineQosPolicy> : MetaStruct {
  typedef DDS::DeadlineQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DeadlineQosPolicy& typed = *static_cast<const DDS::DeadlineQosPolicy*>(stru);
    if (std::strncmp(field, "period.", 7) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.period, field + 7);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "period.", 7) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DeadlineQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "period.", 7) == 0) {
      return make_struct_cmp(&T::period, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 7, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"period", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "period") == 0) {
      return &static_cast<const T*>(stru)->period;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "period") == 0) {
      static_cast<T*>(lhs)->period = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DeadlineQosPolicy>()
{
  static MetaStructImpl<DDS::DeadlineQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DeadlineQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DeadlineQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LatencyBudgetQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm, DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.duration);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LatencyBudgetQosPolicy> : MetaStruct {
  typedef DDS::LatencyBudgetQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LatencyBudgetQosPolicy& typed = *static_cast<const DDS::LatencyBudgetQosPolicy*>(stru);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::LatencyBudgetQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LatencyBudgetQosPolicy>()
{
  static MetaStructImpl<DDS::LatencyBudgetQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LatencyBudgetQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LatencyBudgetQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::OwnershipQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_OwnershipQosPolicyKind_names[] = {
  "SHARED_OWNERSHIP_QOS",
  "EXCLUSIVE_OWNERSHIP_QOS"
};
}  }

#endif

/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OwnershipQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OwnershipQosPolicy> : MetaStruct {
  typedef DDS::OwnershipQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OwnershipQosPolicy& typed = *static_cast<const DDS::OwnershipQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_OwnershipQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::OwnershipQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::OwnershipQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OwnershipQosPolicy>()
{
  static MetaStructImpl<DDS::OwnershipQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OwnershipQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OwnershipQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OwnershipStrengthQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OwnershipStrengthQosPolicy> : MetaStruct {
  typedef DDS::OwnershipStrengthQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OwnershipStrengthQosPolicy& typed = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::OwnershipStrengthQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OwnershipStrengthQosPolicy>()
{
  static MetaStructImpl<DDS::OwnershipStrengthQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OwnershipStrengthQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OwnershipStrengthQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::LivelinessQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_LivelinessQosPolicyKind_names[] = {
  "AUTOMATIC_LIVELINESS_QOS",
  "MANUAL_BY_PARTICIPANT_LIVELINESS_QOS",
  "MANUAL_BY_TOPIC_LIVELINESS_QOS"
};
}  }

#endif

/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LivelinessQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  gen_find_size(stru.lease_duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.lease_duration);
}

bool operator>>(Serializer& strm, DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.lease_duration);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LivelinessQosPolicy> : MetaStruct {
  typedef DDS::LivelinessQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LivelinessQosPolicy& typed = *static_cast<const DDS::LivelinessQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_LivelinessQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.lease_duration, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::LivelinessQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return make_struct_cmp(&T::lease_duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 15, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "lease_duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      return &static_cast<const T*>(stru)->lease_duration;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::LivelinessQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      static_cast<T*>(lhs)->lease_duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LivelinessQosPolicy>()
{
  static MetaStructImpl<DDS::LivelinessQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LivelinessQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LivelinessQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TimeBasedFilterQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.minimum_separation, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.minimum_separation);
}

bool operator>>(Serializer& strm, DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.minimum_separation);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TimeBasedFilterQosPolicy> : MetaStruct {
  typedef DDS::TimeBasedFilterQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TimeBasedFilterQosPolicy& typed = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(stru);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.minimum_separation, field + 19);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::TimeBasedFilterQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return make_struct_cmp(&T::minimum_separation, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 19, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"minimum_separation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "minimum_separation") == 0) {
      return &static_cast<const T*>(stru)->minimum_separation;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "minimum_separation") == 0) {
      static_cast<T*>(lhs)->minimum_separation = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TimeBasedFilterQosPolicy>()
{
  static MetaStructImpl<DDS::TimeBasedFilterQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TimeBasedFilterQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TimeBasedFilterQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PartitionQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.name, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name);
}

bool operator>>(Serializer& strm, DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PartitionQosPolicy> : MetaStruct {
  typedef DDS::PartitionQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PartitionQosPolicy& typed = *static_cast<const DDS::PartitionQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::StringSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::PartitionQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PartitionQosPolicy>()
{
  static MetaStructImpl<DDS::PartitionQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PartitionQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PartitionQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::ReliabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_ReliabilityQosPolicyKind_names[] = {
  "BEST_EFFORT_RELIABILITY_QOS",
  "RELIABLE_RELIABILITY_QOS"
};
}  }

#endif

/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ReliabilityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  gen_find_size(stru.max_blocking_time, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.max_blocking_time);
}

bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.max_blocking_time);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ReliabilityQosPolicy> : MetaStruct {
  typedef DDS::ReliabilityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ReliabilityQosPolicy& typed = *static_cast<const DDS::ReliabilityQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_ReliabilityQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.max_blocking_time, field + 18);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::ReliabilityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return make_struct_cmp(&T::max_blocking_time, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 18, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "max_blocking_time", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      return &static_cast<const T*>(stru)->max_blocking_time;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::ReliabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      static_cast<T*>(lhs)->max_blocking_time = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ReliabilityQosPolicy>()
{
  static MetaStructImpl<DDS::ReliabilityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ReliabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ReliabilityQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::DestinationOrderQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DestinationOrderQosPolicyKind_names[] = {
  "BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS",
  "BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS"
};
}  }

#endif

/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DestinationOrderQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DestinationOrderQosPolicy> : MetaStruct {
  typedef DDS::DestinationOrderQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DestinationOrderQosPolicy& typed = *static_cast<const DDS::DestinationOrderQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DestinationOrderQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DestinationOrderQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DestinationOrderQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DestinationOrderQosPolicy>()
{
  static MetaStructImpl<DDS::DestinationOrderQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DestinationOrderQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DestinationOrderQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::HistoryQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_HistoryQosPolicyKind_names[] = {
  "KEEP_LAST_HISTORY_QOS",
  "KEEP_ALL_HISTORY_QOS"
};
}  }

#endif

/* End ENUM: HistoryQosPolicyKind */


/* Begin STRUCT: HistoryQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::HistoryQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.depth);
}

bool operator<<(Serializer& strm, const DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.depth);
}

bool operator>>(Serializer& strm, DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.depth);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::HistoryQosPolicy> : MetaStruct {
  typedef DDS::HistoryQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::HistoryQosPolicy& typed = *static_cast<const DDS::HistoryQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.kind];
    }
    if (std::strcmp(field, "depth") == 0) {
      return typed.depth;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "depth") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'depth' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::HistoryQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "depth") == 0) {
      return make_field_cmp(&T::depth, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "depth", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return &static_cast<const T*>(stru)->depth;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "depth") == 0) {
      static_cast<T*>(lhs)->depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return static_cast<const T*>(lhs)->depth == static_cast<const T*>(rhs)->depth;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::HistoryQosPolicy>()
{
  static MetaStructImpl<DDS::HistoryQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::HistoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::HistoryQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ResourceLimitsQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_instances);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm, DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.max_samples)
    && (strm >> stru.max_instances)
    && (strm >> stru.max_samples_per_instance);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ResourceLimitsQosPolicy> : MetaStruct {
  typedef DDS::ResourceLimitsQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ResourceLimitsQosPolicy& typed = *static_cast<const DDS::ResourceLimitsQosPolicy*>(stru);
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "max_samples") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::ResourceLimitsQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ResourceLimitsQosPolicy>()
{
  static MetaStructImpl<DDS::ResourceLimitsQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ResourceLimitsQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ResourceLimitsQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: EntityFactoryQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::EntityFactoryQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator<<(Serializer& strm, const DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator>>(Serializer& strm, DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_boolean(stru.autoenable_created_entities));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::EntityFactoryQosPolicy> : MetaStruct {
  typedef DDS::EntityFactoryQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::EntityFactoryQosPolicy& typed = *static_cast<const DDS::EntityFactoryQosPolicy*>(stru);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return typed.autoenable_created_entities;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autoenable_created_entities' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::EntityFactoryQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return make_field_cmp(&T::autoenable_created_entities, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autoenable_created_entities", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return &static_cast<const T*>(stru)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      static_cast<T*>(lhs)->autoenable_created_entities = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return static_cast<const T*>(lhs)->autoenable_created_entities == static_cast<const T*>(rhs)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::EntityFactoryQosPolicy>()
{
  static MetaStructImpl<DDS::EntityFactoryQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::EntityFactoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::EntityFactoryQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::WriterDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator<<(Serializer& strm, const DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator>>(Serializer& strm, DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_boolean(stru.autodispose_unregistered_instances));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> : MetaStruct {
  typedef DDS::WriterDataLifecycleQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::WriterDataLifecycleQosPolicy& typed = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(stru);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return typed.autodispose_unregistered_instances;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::WriterDataLifecycleQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return make_field_cmp(&T::autodispose_unregistered_instances, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autodispose_unregistered_instances", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return &static_cast<const T*>(stru)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      static_cast<T*>(lhs)->autodispose_unregistered_instances = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return static_cast<const T*>(lhs)->autodispose_unregistered_instances == static_cast<const T*>(rhs)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::WriterDataLifecycleQosPolicy>()
{
  static MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::WriterDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ReaderDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.autopurge_nowriter_samples_delay, size, padding);
  gen_find_size(stru.autopurge_disposed_samples_delay, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.autopurge_nowriter_samples_delay)
    && (strm << stru.autopurge_disposed_samples_delay);
}

bool operator>>(Serializer& strm, DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.autopurge_nowriter_samples_delay)
    && (strm >> stru.autopurge_disposed_samples_delay);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> : MetaStruct {
  typedef DDS::ReaderDataLifecycleQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ReaderDataLifecycleQosPolicy& typed = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(stru);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_nowriter_samples_delay, field + 33);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_disposed_samples_delay, field + 33);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::ReaderDataLifecycleQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_nowriter_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33, 0), next);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_disposed_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autopurge_nowriter_samples_delay", "autopurge_disposed_samples_delay", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_nowriter_samples_delay;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_disposed_samples_delay;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_nowriter_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_disposed_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>()
{
  static MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ReaderDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DurabilityServiceQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.service_cleanup_delay, size, padding);
  find_size_ulong(size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.history_depth);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_instances);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.service_cleanup_delay)
    && (strm << stru.history_kind)
    && (strm << stru.history_depth)
    && (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm, DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.service_cleanup_delay)
    && (strm >> stru.history_kind)
    && (strm >> stru.history_depth)
    && (strm >> stru.max_samples)
    && (strm >> stru.max_instances)
    && (strm >> stru.max_samples_per_instance);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DurabilityServiceQosPolicy> : MetaStruct {
  typedef DDS::DurabilityServiceQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DurabilityServiceQosPolicy& typed = *static_cast<const DDS::DurabilityServiceQosPolicy*>(stru);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.service_cleanup_delay, field + 22);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.history_kind];
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return typed.history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (std::strcmp(field, "history_kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'history_kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "history_depth") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'history_depth' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DurabilityServiceQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return make_struct_cmp(&T::service_cleanup_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 22, 0), next);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return make_field_cmp(&T::history_kind, next);
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return make_field_cmp(&T::history_depth, next);
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"service_cleanup_delay", "history_kind", "history_depth", "max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      return &static_cast<const T*>(stru)->service_cleanup_delay;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return &static_cast<const T*>(stru)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return &static_cast<const T*>(stru)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      static_cast<T*>(lhs)->service_cleanup_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      static_cast<T*>(lhs)->history_kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      static_cast<T*>(lhs)->history_depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "history_kind") == 0) {
      return static_cast<const T*>(lhs)->history_kind == static_cast<const T*>(rhs)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return static_cast<const T*>(lhs)->history_depth == static_cast<const T*>(rhs)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DurabilityServiceQosPolicy>()
{
  static MetaStructImpl<DDS::DurabilityServiceQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DurabilityServiceQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DurabilityServiceQosPolicy>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DomainParticipantFactoryQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DomainParticipantFactoryQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.entity_factory);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DomainParticipantFactoryQos> : MetaStruct {
  typedef DDS::DomainParticipantFactoryQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DomainParticipantFactoryQos& typed = *static_cast<const DDS::DomainParticipantFactoryQos*>(stru);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DomainParticipantFactoryQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DomainParticipantFactoryQos>()
{
  static MetaStructImpl<DDS::DomainParticipantFactoryQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DomainParticipantFactoryQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DomainParticipantFactoryQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DomainParticipantQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.user_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.user_data)
    && (strm >> stru.entity_factory);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DomainParticipantQos> : MetaStruct {
  typedef DDS::DomainParticipantQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DomainParticipantQos& typed = *static_cast<const DDS::DomainParticipantQos*>(stru);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DomainParticipantQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"user_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DomainParticipantQos>()
{
  static MetaStructImpl<DDS::DomainParticipantQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DomainParticipantQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DomainParticipantQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: TopicQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.ownership, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.topic_data)
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.ownership);
}

bool operator>>(Serializer& strm, DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.topic_data)
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.ownership);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicQos> : MetaStruct {
  typedef DDS::TopicQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicQos& typed = *static_cast<const DDS::TopicQos*>(stru);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::TopicQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"topic_data", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "ownership", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicQos>()
{
  static MetaStructImpl<DDS::TopicQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: DataWriterQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DataWriterQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.ownership_strength, size, padding);
  gen_find_size(stru.writer_data_lifecycle, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.writer_data_lifecycle);
}

bool operator>>(Serializer& strm, DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.ownership_strength)
    && (strm >> stru.writer_data_lifecycle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DataWriterQos> : MetaStruct {
  typedef DDS::DataWriterQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DataWriterQos& typed = *static_cast<const DDS::DataWriterQos*>(stru);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(&typed.writer_data_lifecycle, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::WriterDataLifecycleQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DataWriterQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::writer_data_lifecycle, getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().create_qc_comparator(field + 22, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "user_data", "ownership", "ownership_strength", "writer_data_lifecycle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->writer_data_lifecycle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->writer_data_lifecycle = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DataWriterQos>()
{
  static MetaStructImpl<DDS::DataWriterQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DataWriterQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DataWriterQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: PublisherQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PublisherQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.group_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.group_data)
    && (strm >> stru.entity_factory);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PublisherQos> : MetaStruct {
  typedef DDS::PublisherQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PublisherQos& typed = *static_cast<const DDS::PublisherQos*>(stru);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::PublisherQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13, 0), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PublisherQos>()
{
  static MetaStructImpl<DDS::PublisherQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PublisherQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PublisherQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: DataReaderQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DataReaderQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.time_based_filter, size, padding);
  gen_find_size(stru.reader_data_lifecycle, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.time_based_filter)
    && (strm << stru.reader_data_lifecycle);
}

bool operator>>(Serializer& strm, DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.durability)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.time_based_filter)
    && (strm >> stru.reader_data_lifecycle);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DataReaderQos> : MetaStruct {
  typedef DDS::DataReaderQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DataReaderQos& typed = *static_cast<const DDS::DataReaderQos*>(stru);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(&typed.reader_data_lifecycle, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReaderDataLifecycleQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::DataReaderQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::reader_data_lifecycle, getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().create_qc_comparator(field + 22, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "user_data", "ownership", "time_based_filter", "reader_data_lifecycle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->reader_data_lifecycle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->reader_data_lifecycle = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DataReaderQos>()
{
  static MetaStructImpl<DDS::DataReaderQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DataReaderQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DataReaderQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SubscriberQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.group_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.group_data)
    && (strm >> stru.entity_factory);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SubscriberQos> : MetaStruct {
  typedef DDS::SubscriberQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SubscriberQos& typed = *static_cast<const DDS::SubscriberQos*>(stru);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SubscriberQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13, 0), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SubscriberQos>()
{
  static MetaStructImpl<DDS::SubscriberQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SubscriberQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SubscriberQos>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: ParticipantBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ParticipantBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.user_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.user_data);
}

bool operator>>(Serializer& strm, DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.user_data);
}

bool gen_is_bounded_size(const DDS::ParticipantBuiltinTopicData&)
{
  return false;
}

size_t gen_max_marshaled_size(const DDS::ParticipantBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const DDS::ParticipantBuiltinTopicData>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::ParticipantBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::ParticipantBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const DDS::ParticipantBuiltinTopicData&)
{
  return true;
}

}  }

namespace DDS {
ParticipantBuiltinTopicDataTypeSupportImpl::ParticipantBuiltinTopicDataTypeSupportImpl ()
{
}

ParticipantBuiltinTopicDataTypeSupportImpl::~ParticipantBuiltinTopicDataTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
ParticipantBuiltinTopicDataTypeSupportImpl::create_datawriter ()
{
  ParticipantBuiltinTopicDataDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 ParticipantBuiltinTopicDataDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
ParticipantBuiltinTopicDataTypeSupportImpl::create_datareader ()
{
  ParticipantBuiltinTopicDataDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 ParticipantBuiltinTopicDataDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
ParticipantBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantBuiltinTopicData,
    ParticipantBuiltinTopicDataDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
ParticipantBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ParticipantBuiltinTopicData>();
}

#endif

bool
ParticipantBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(ParticipantBuiltinTopicData());
}


ParticipantBuiltinTopicDataDataWriterImpl::ParticipantBuiltinTopicDataDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

ParticipantBuiltinTopicDataDataWriterImpl::~ParticipantBuiltinTopicDataDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataWriterImpl::register_instance (
    const ::DDS::ParticipantBuiltinTopicData & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataWriterImpl::register_instance_w_timestamp (
    const ::DDS::ParticipantBuiltinTopicData & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::unregister_instance (
    const ::DDS::ParticipantBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::unregister_instance_w_timestamp (
    const ::DDS::ParticipantBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // ParticipantBuiltinTopicDataDataWriter.
  // That the instance handle is removed from there and hence
  // ParticipantBuiltinTopicDataDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::write (
    const ::DDS::ParticipantBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::write_w_timestamp (
    const ::DDS::ParticipantBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::dispose (
    const ::DDS::ParticipantBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::dispose_w_timestamp (
    const ::DDS::ParticipantBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::get_key_value (
    ::DDS::ParticipantBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataWriterImpl::lookup_instance (
    const ::DDS::ParticipantBuiltinTopicData & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
ParticipantBuiltinTopicDataDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::DDS::ParticipantBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::DDS::ParticipantBuiltinTopicData > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::enable_specific ()
{
  ::DDS::ParticipantBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The ParticipantBuiltinTopicDataDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
ParticipantBuiltinTopicDataDataWriterImpl::dds_marshal(
  const ::DDS::ParticipantBuiltinTopicData& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::DDS::ParticipantBuiltinTopicData > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::DDS::ParticipantBuiltinTopicData& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("ParticipantBuiltinTopicDataDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert DDS::ParticipantBuiltinTopicData failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
ParticipantBuiltinTopicDataDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
ParticipantBuiltinTopicDataDataReaderImpl::ParticipantBuiltinTopicDataDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

ParticipantBuiltinTopicDataDataReaderImpl::~ParticipantBuiltinTopicDataDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::ParticipantBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::ParticipantBuiltinTopicDataSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::ParticipantBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::ParticipantBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_w_condition (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_w_condition (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_next_sample (
    ::DDS::ParticipantBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::ParticipantBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_next_sample (
    ::DDS::ParticipantBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::ParticipantBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_instance (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_instance_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::ParticipantBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::ParticipantBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_instance (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_instance_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::ParticipantBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::ParticipantBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_next_instance (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_next_instance_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_next_instance (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_next_instance_i (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_next_instance_w_condition (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take_next_instance_w_condition (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
ParticipantBuiltinTopicDataDataReaderImpl::release_loan (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data
  )
{
  received_data.length(0);
}


void
ParticipantBuiltinTopicDataDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::DDS::ParticipantBuiltinTopicData* const ptr
        = static_cast< ::DDS::ParticipantBuiltinTopicData* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    ParticipantBuiltinTopicData );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::return_loan (
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::get_key_value (
    ::DDS::ParticipantBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataReaderImpl::lookup_instance (
    const ::DDS::ParticipantBuiltinTopicData & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
ParticipantBuiltinTopicDataDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::DDS::ParticipantBuiltinTopicData* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  DDS::ParticipantBuiltinTopicDataSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  DDS::ParticipantBuiltinTopicDataSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const DDS::ParticipantBuiltinTopicData*>(data));
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::ParticipantBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::ParticipantBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::ParticipantBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::ParticipantBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
ParticipantBuiltinTopicDataDataReaderImpl::store_synthetic_data(const DDS::ParticipantBuiltinTopicData& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    DDS::ParticipantBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::ParticipantBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::ParticipantBuiltinTopicData))),
      DDS::ParticipantBuiltinTopicData(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
ParticipantBuiltinTopicDataDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    DDS::ParticipantBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::ParticipantBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::ParticipantBuiltinTopicData))),
      DDS::ParticipantBuiltinTopicData);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
ParticipantBuiltinTopicDataDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::DDS::ParticipantBuiltinTopicData* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::DDS::ParticipantBuiltinTopicData *>(
                            data_allocator_->malloc(sizeof(::DDS::ParticipantBuiltinTopicData))),
                           ::DDS::ParticipantBuiltinTopicData);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::ParticipantBuiltinTopicData>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
ParticipantBuiltinTopicDataDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::DDS::ParticipantBuiltinTopicData data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::ParticipantBuiltinTopicData>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
ParticipantBuiltinTopicDataDataReaderImpl::store_instance_data(
    ::DDS::ParticipantBuiltinTopicData *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  ParticipantBuiltinTopicData );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ParticipantBuiltinTopicData );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ParticipantBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ParticipantBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("ParticipantBuiltinTopicDataDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::DDS::ParticipantBuiltinTopicData failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ParticipantBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("ParticipantBuiltinTopicDataDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::DDS::ParticipantBuiltinTopicData failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ParticipantBuiltinTopicData );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ParticipantBuiltinTopicData );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         ParticipantBuiltinTopicData );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    ParticipantBuiltinTopicData );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  ParticipantBuiltinTopicData );
  }
}

void
ParticipantBuiltinTopicDataDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
ParticipantBuiltinTopicDataDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::auto_return_loan(void* seq)
{
  ::DDS::ParticipantBuiltinTopicDataSeq& received_data =
    *static_cast< ::DDS::ParticipantBuiltinTopicDataSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
ParticipantBuiltinTopicDataDataReaderImpl::check_inputs (
    const char* method_name,
    ::DDS::ParticipantBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::DDS::ParticipantBuiltinTopicDataSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ParticipantBuiltinTopicDataDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
ParticipantBuiltinTopicDataDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
ParticipantBuiltinTopicDataDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
ParticipantBuiltinTopicDataDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ParticipantBuiltinTopicData> : MetaStruct {
  typedef DDS::ParticipantBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ParticipantBuiltinTopicData& typed = *static_cast<const DDS::ParticipantBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::ParticipantBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4, 0), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "user_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ParticipantBuiltinTopicData>()
{
  static MetaStructImpl<DDS::ParticipantBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ParticipantBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ParticipantBuiltinTopicData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.topic_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.name)
    && (strm << stru.type_name)
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.ownership)
    && (strm << stru.topic_data);
}

bool operator>>(Serializer& strm, DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.ownership)
    && (strm >> stru.topic_data);
}

bool gen_is_bounded_size(const DDS::TopicBuiltinTopicData&)
{
  return false;
}

size_t gen_max_marshaled_size(const DDS::TopicBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const DDS::TopicBuiltinTopicData>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::TopicBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::TopicBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const DDS::TopicBuiltinTopicData&)
{
  return true;
}

}  }

namespace DDS {
TopicBuiltinTopicDataTypeSupportImpl::TopicBuiltinTopicDataTypeSupportImpl ()
{
}

TopicBuiltinTopicDataTypeSupportImpl::~TopicBuiltinTopicDataTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
TopicBuiltinTopicDataTypeSupportImpl::create_datawriter ()
{
  TopicBuiltinTopicDataDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 TopicBuiltinTopicDataDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
TopicBuiltinTopicDataTypeSupportImpl::create_datareader ()
{
  TopicBuiltinTopicDataDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 TopicBuiltinTopicDataDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
TopicBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<TopicBuiltinTopicData,
    TopicBuiltinTopicDataDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
TopicBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicBuiltinTopicData>();
}

#endif

bool
TopicBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(TopicBuiltinTopicData());
}


TopicBuiltinTopicDataDataWriterImpl::TopicBuiltinTopicDataDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

TopicBuiltinTopicDataDataWriterImpl::~TopicBuiltinTopicDataDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataWriterImpl::register_instance (
    const ::DDS::TopicBuiltinTopicData & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataWriterImpl::register_instance_w_timestamp (
    const ::DDS::TopicBuiltinTopicData & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::unregister_instance (
    const ::DDS::TopicBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::unregister_instance_w_timestamp (
    const ::DDS::TopicBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // TopicBuiltinTopicDataDataWriter.
  // That the instance handle is removed from there and hence
  // TopicBuiltinTopicDataDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::write (
    const ::DDS::TopicBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::write_w_timestamp (
    const ::DDS::TopicBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::dispose (
    const ::DDS::TopicBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::dispose_w_timestamp (
    const ::DDS::TopicBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::get_key_value (
    ::DDS::TopicBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataWriterImpl::lookup_instance (
    const ::DDS::TopicBuiltinTopicData & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
TopicBuiltinTopicDataDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::DDS::TopicBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::DDS::TopicBuiltinTopicData > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::enable_specific ()
{
  ::DDS::TopicBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The TopicBuiltinTopicDataDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
TopicBuiltinTopicDataDataWriterImpl::dds_marshal(
  const ::DDS::TopicBuiltinTopicData& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::DDS::TopicBuiltinTopicData > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::DDS::TopicBuiltinTopicData& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("TopicBuiltinTopicDataDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert DDS::TopicBuiltinTopicData failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
TopicBuiltinTopicDataDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
TopicBuiltinTopicDataDataReaderImpl::TopicBuiltinTopicDataDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

TopicBuiltinTopicDataDataReaderImpl::~TopicBuiltinTopicDataDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::TopicBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::TopicBuiltinTopicDataSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::TopicBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::TopicBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_w_condition (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_w_condition (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_next_sample (
    ::DDS::TopicBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::TopicBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_next_sample (
    ::DDS::TopicBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::TopicBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_instance (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_instance_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::TopicBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::TopicBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_instance (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_instance_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::TopicBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::TopicBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_next_instance (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_next_instance_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_next_instance (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_next_instance_i (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_next_instance_w_condition (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take_next_instance_w_condition (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
TopicBuiltinTopicDataDataReaderImpl::release_loan (
    ::DDS::TopicBuiltinTopicDataSeq & received_data
  )
{
  received_data.length(0);
}


void
TopicBuiltinTopicDataDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::DDS::TopicBuiltinTopicData* const ptr
        = static_cast< ::DDS::TopicBuiltinTopicData* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    TopicBuiltinTopicData );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::return_loan (
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::get_key_value (
    ::DDS::TopicBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataReaderImpl::lookup_instance (
    const ::DDS::TopicBuiltinTopicData & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
TopicBuiltinTopicDataDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::DDS::TopicBuiltinTopicData* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  DDS::TopicBuiltinTopicDataSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  DDS::TopicBuiltinTopicDataSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const DDS::TopicBuiltinTopicData*>(data));
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::TopicBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::TopicBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::TopicBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::TopicBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
TopicBuiltinTopicDataDataReaderImpl::store_synthetic_data(const DDS::TopicBuiltinTopicData& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    DDS::TopicBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::TopicBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::TopicBuiltinTopicData))),
      DDS::TopicBuiltinTopicData(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
TopicBuiltinTopicDataDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    DDS::TopicBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::TopicBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::TopicBuiltinTopicData))),
      DDS::TopicBuiltinTopicData);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
TopicBuiltinTopicDataDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::DDS::TopicBuiltinTopicData* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::DDS::TopicBuiltinTopicData *>(
                            data_allocator_->malloc(sizeof(::DDS::TopicBuiltinTopicData))),
                           ::DDS::TopicBuiltinTopicData);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::TopicBuiltinTopicData>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
TopicBuiltinTopicDataDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::DDS::TopicBuiltinTopicData data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::TopicBuiltinTopicData>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
TopicBuiltinTopicDataDataReaderImpl::store_instance_data(
    ::DDS::TopicBuiltinTopicData *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TopicBuiltinTopicData );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicBuiltinTopicData );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("TopicBuiltinTopicDataDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::DDS::TopicBuiltinTopicData failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("TopicBuiltinTopicDataDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::DDS::TopicBuiltinTopicData failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicBuiltinTopicData );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicBuiltinTopicData );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         TopicBuiltinTopicData );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    TopicBuiltinTopicData );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TopicBuiltinTopicData );
  }
}

void
TopicBuiltinTopicDataDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
TopicBuiltinTopicDataDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::auto_return_loan(void* seq)
{
  ::DDS::TopicBuiltinTopicDataSeq& received_data =
    *static_cast< ::DDS::TopicBuiltinTopicDataSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TopicBuiltinTopicDataDataReaderImpl::check_inputs (
    const char* method_name,
    ::DDS::TopicBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::DDS::TopicBuiltinTopicDataSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicBuiltinTopicDataDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
TopicBuiltinTopicDataDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
TopicBuiltinTopicDataDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
TopicBuiltinTopicDataDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicBuiltinTopicData> : MetaStruct {
  typedef DDS::TopicBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicBuiltinTopicData& typed = *static_cast<const DDS::TopicBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::TopicBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4, 0), next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "transport_priority", "lifespan", "destination_order", "history", "resource_limits", "ownership", "topic_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name, static_cast<const T*>(rhs)->name);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name, static_cast<const T*>(rhs)->type_name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicBuiltinTopicData>()
{
  static MetaStructImpl<DDS::TopicBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicBuiltinTopicData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PublicationBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.participant_key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.ownership_strength, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.group_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name)
    && (strm << stru.type_name)
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.destination_order)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data);
}

bool operator>>(Serializer& strm, DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.participant_key)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.lifespan)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.ownership_strength)
    && (strm >> stru.destination_order)
    && (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.topic_data)
    && (strm >> stru.group_data);
}

bool gen_is_bounded_size(const DDS::PublicationBuiltinTopicData&)
{
  return false;
}

size_t gen_max_marshaled_size(const DDS::PublicationBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const DDS::PublicationBuiltinTopicData>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::PublicationBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::PublicationBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const DDS::PublicationBuiltinTopicData&)
{
  return true;
}

}  }

namespace DDS {
PublicationBuiltinTopicDataTypeSupportImpl::PublicationBuiltinTopicDataTypeSupportImpl ()
{
}

PublicationBuiltinTopicDataTypeSupportImpl::~PublicationBuiltinTopicDataTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
PublicationBuiltinTopicDataTypeSupportImpl::create_datawriter ()
{
  PublicationBuiltinTopicDataDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 PublicationBuiltinTopicDataDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
PublicationBuiltinTopicDataTypeSupportImpl::create_datareader ()
{
  PublicationBuiltinTopicDataDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 PublicationBuiltinTopicDataDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
PublicationBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<PublicationBuiltinTopicData,
    PublicationBuiltinTopicDataDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
PublicationBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublicationBuiltinTopicData>();
}

#endif

bool
PublicationBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(PublicationBuiltinTopicData());
}


PublicationBuiltinTopicDataDataWriterImpl::PublicationBuiltinTopicDataDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

PublicationBuiltinTopicDataDataWriterImpl::~PublicationBuiltinTopicDataDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataWriterImpl::register_instance (
    const ::DDS::PublicationBuiltinTopicData & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataWriterImpl::register_instance_w_timestamp (
    const ::DDS::PublicationBuiltinTopicData & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::unregister_instance (
    const ::DDS::PublicationBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::unregister_instance_w_timestamp (
    const ::DDS::PublicationBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // PublicationBuiltinTopicDataDataWriter.
  // That the instance handle is removed from there and hence
  // PublicationBuiltinTopicDataDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::write (
    const ::DDS::PublicationBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::write_w_timestamp (
    const ::DDS::PublicationBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::dispose (
    const ::DDS::PublicationBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::dispose_w_timestamp (
    const ::DDS::PublicationBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::get_key_value (
    ::DDS::PublicationBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataWriterImpl::lookup_instance (
    const ::DDS::PublicationBuiltinTopicData & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
PublicationBuiltinTopicDataDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::DDS::PublicationBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::DDS::PublicationBuiltinTopicData > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::enable_specific ()
{
  ::DDS::PublicationBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The PublicationBuiltinTopicDataDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
PublicationBuiltinTopicDataDataWriterImpl::dds_marshal(
  const ::DDS::PublicationBuiltinTopicData& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::DDS::PublicationBuiltinTopicData > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::DDS::PublicationBuiltinTopicData& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("PublicationBuiltinTopicDataDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert DDS::PublicationBuiltinTopicData failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
PublicationBuiltinTopicDataDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
PublicationBuiltinTopicDataDataReaderImpl::PublicationBuiltinTopicDataDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

PublicationBuiltinTopicDataDataReaderImpl::~PublicationBuiltinTopicDataDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::PublicationBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::PublicationBuiltinTopicDataSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::PublicationBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::PublicationBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_w_condition (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_w_condition (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_next_sample (
    ::DDS::PublicationBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::PublicationBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_next_sample (
    ::DDS::PublicationBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::PublicationBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_instance (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_instance_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::PublicationBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::PublicationBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_instance (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_instance_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::PublicationBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::PublicationBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_next_instance (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_next_instance_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_next_instance (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_next_instance_i (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_next_instance_w_condition (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take_next_instance_w_condition (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
PublicationBuiltinTopicDataDataReaderImpl::release_loan (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data
  )
{
  received_data.length(0);
}


void
PublicationBuiltinTopicDataDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::DDS::PublicationBuiltinTopicData* const ptr
        = static_cast< ::DDS::PublicationBuiltinTopicData* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    PublicationBuiltinTopicData );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::return_loan (
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::get_key_value (
    ::DDS::PublicationBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataReaderImpl::lookup_instance (
    const ::DDS::PublicationBuiltinTopicData & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
PublicationBuiltinTopicDataDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::DDS::PublicationBuiltinTopicData* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  DDS::PublicationBuiltinTopicDataSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  DDS::PublicationBuiltinTopicDataSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const DDS::PublicationBuiltinTopicData*>(data));
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::PublicationBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::PublicationBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::PublicationBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::PublicationBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
PublicationBuiltinTopicDataDataReaderImpl::store_synthetic_data(const DDS::PublicationBuiltinTopicData& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    DDS::PublicationBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::PublicationBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::PublicationBuiltinTopicData))),
      DDS::PublicationBuiltinTopicData(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
PublicationBuiltinTopicDataDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    DDS::PublicationBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::PublicationBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::PublicationBuiltinTopicData))),
      DDS::PublicationBuiltinTopicData);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
PublicationBuiltinTopicDataDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::DDS::PublicationBuiltinTopicData* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::DDS::PublicationBuiltinTopicData *>(
                            data_allocator_->malloc(sizeof(::DDS::PublicationBuiltinTopicData))),
                           ::DDS::PublicationBuiltinTopicData);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::PublicationBuiltinTopicData>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
PublicationBuiltinTopicDataDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::DDS::PublicationBuiltinTopicData data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::PublicationBuiltinTopicData>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
PublicationBuiltinTopicDataDataReaderImpl::store_instance_data(
    ::DDS::PublicationBuiltinTopicData *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  PublicationBuiltinTopicData );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublicationBuiltinTopicData );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublicationBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublicationBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("PublicationBuiltinTopicDataDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::DDS::PublicationBuiltinTopicData failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublicationBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("PublicationBuiltinTopicDataDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::DDS::PublicationBuiltinTopicData failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublicationBuiltinTopicData );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublicationBuiltinTopicData );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         PublicationBuiltinTopicData );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    PublicationBuiltinTopicData );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  PublicationBuiltinTopicData );
  }
}

void
PublicationBuiltinTopicDataDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
PublicationBuiltinTopicDataDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::auto_return_loan(void* seq)
{
  ::DDS::PublicationBuiltinTopicDataSeq& received_data =
    *static_cast< ::DDS::PublicationBuiltinTopicDataSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
PublicationBuiltinTopicDataDataReaderImpl::check_inputs (
    const char* method_name,
    ::DDS::PublicationBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::DDS::PublicationBuiltinTopicDataSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublicationBuiltinTopicDataDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
PublicationBuiltinTopicDataDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
PublicationBuiltinTopicDataDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
PublicationBuiltinTopicDataDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PublicationBuiltinTopicData> : MetaStruct {
  typedef DDS::PublicationBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PublicationBuiltinTopicData& typed = *static_cast<const DDS::PublicationBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::PublicationBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4, 0), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13, 0), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "lifespan", "user_data", "ownership", "ownership_strength", "destination_order", "presentation", "partition", "topic_data", "group_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name, static_cast<const T*>(rhs)->topic_name);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name, static_cast<const T*>(rhs)->type_name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PublicationBuiltinTopicData>()
{
  static MetaStructImpl<DDS::PublicationBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PublicationBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PublicationBuiltinTopicData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SubscriptionBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.participant_key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.time_based_filter, size, padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.group_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name)
    && (strm << stru.type_name)
    && (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.ownership)
    && (strm << stru.destination_order)
    && (strm << stru.user_data)
    && (strm << stru.time_based_filter)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data);
}

bool operator>>(Serializer& strm, DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.participant_key)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.ownership)
    && (strm >> stru.destination_order)
    && (strm >> stru.user_data)
    && (strm >> stru.time_based_filter)
    && (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.topic_data)
    && (strm >> stru.group_data);
}

bool gen_is_bounded_size(const DDS::SubscriptionBuiltinTopicData&)
{
  return false;
}

size_t gen_max_marshaled_size(const DDS::SubscriptionBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::SubscriptionBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const DDS::SubscriptionBuiltinTopicData&)
{
  return true;
}

}  }

namespace DDS {
SubscriptionBuiltinTopicDataTypeSupportImpl::SubscriptionBuiltinTopicDataTypeSupportImpl ()
{
}

SubscriptionBuiltinTopicDataTypeSupportImpl::~SubscriptionBuiltinTopicDataTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
SubscriptionBuiltinTopicDataTypeSupportImpl::create_datawriter ()
{
  SubscriptionBuiltinTopicDataDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 SubscriptionBuiltinTopicDataDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
SubscriptionBuiltinTopicDataTypeSupportImpl::create_datareader ()
{
  SubscriptionBuiltinTopicDataDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 SubscriptionBuiltinTopicDataDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
SubscriptionBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<SubscriptionBuiltinTopicData,
    SubscriptionBuiltinTopicDataDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
SubscriptionBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriptionBuiltinTopicData>();
}

#endif

bool
SubscriptionBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(SubscriptionBuiltinTopicData());
}


SubscriptionBuiltinTopicDataDataWriterImpl::SubscriptionBuiltinTopicDataDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

SubscriptionBuiltinTopicDataDataWriterImpl::~SubscriptionBuiltinTopicDataDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataWriterImpl::register_instance (
    const ::DDS::SubscriptionBuiltinTopicData & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataWriterImpl::register_instance_w_timestamp (
    const ::DDS::SubscriptionBuiltinTopicData & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::unregister_instance (
    const ::DDS::SubscriptionBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::unregister_instance_w_timestamp (
    const ::DDS::SubscriptionBuiltinTopicData & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // SubscriptionBuiltinTopicDataDataWriter.
  // That the instance handle is removed from there and hence
  // SubscriptionBuiltinTopicDataDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::write (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::write_w_timestamp (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::dispose (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::dispose_w_timestamp (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::get_key_value (
    ::DDS::SubscriptionBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataWriterImpl::lookup_instance (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
SubscriptionBuiltinTopicDataDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::DDS::SubscriptionBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::DDS::SubscriptionBuiltinTopicData > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::enable_specific ()
{
  ::DDS::SubscriptionBuiltinTopicData data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The SubscriptionBuiltinTopicDataDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
SubscriptionBuiltinTopicDataDataWriterImpl::dds_marshal(
  const ::DDS::SubscriptionBuiltinTopicData& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::DDS::SubscriptionBuiltinTopicData > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::DDS::SubscriptionBuiltinTopicData& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("SubscriptionBuiltinTopicDataDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert DDS::SubscriptionBuiltinTopicData failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
SubscriptionBuiltinTopicDataDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
SubscriptionBuiltinTopicDataDataReaderImpl::SubscriptionBuiltinTopicDataDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

SubscriptionBuiltinTopicDataDataReaderImpl::~SubscriptionBuiltinTopicDataDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::SubscriptionBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::SubscriptionBuiltinTopicDataSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::SubscriptionBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::DDS::SubscriptionBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_w_condition (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_w_condition (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_next_sample (
    ::DDS::SubscriptionBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::SubscriptionBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_next_sample (
    ::DDS::SubscriptionBuiltinTopicData & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::DDS::SubscriptionBuiltinTopicData *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_instance (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_instance_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::SubscriptionBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::SubscriptionBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_instance (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_instance_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::SubscriptionBuiltinTopicDataSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::DDS::SubscriptionBuiltinTopicDataSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_next_instance (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_next_instance_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_next_instance (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_next_instance_i (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_next_instance_w_condition (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take_next_instance_w_condition (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::release_loan (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data
  )
{
  received_data.length(0);
}


void
SubscriptionBuiltinTopicDataDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::DDS::SubscriptionBuiltinTopicData* const ptr
        = static_cast< ::DDS::SubscriptionBuiltinTopicData* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    SubscriptionBuiltinTopicData );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::return_loan (
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::get_key_value (
    ::DDS::SubscriptionBuiltinTopicData & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataReaderImpl::lookup_instance (
    const ::DDS::SubscriptionBuiltinTopicData & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
SubscriptionBuiltinTopicDataDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::DDS::SubscriptionBuiltinTopicData* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  DDS::SubscriptionBuiltinTopicDataSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  DDS::SubscriptionBuiltinTopicDataSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const DDS::SubscriptionBuiltinTopicData*>(data));
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::SubscriptionBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::SubscriptionBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  DDS::SubscriptionBuiltinTopicDataSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new DDS::SubscriptionBuiltinTopicData(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
SubscriptionBuiltinTopicDataDataReaderImpl::store_synthetic_data(const DDS::SubscriptionBuiltinTopicData& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    DDS::SubscriptionBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::SubscriptionBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::SubscriptionBuiltinTopicData))),
      DDS::SubscriptionBuiltinTopicData(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    DDS::SubscriptionBuiltinTopicData* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< DDS::SubscriptionBuiltinTopicData*>(data_allocator_->malloc(sizeof(DDS::SubscriptionBuiltinTopicData))),
      DDS::SubscriptionBuiltinTopicData);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::DDS::SubscriptionBuiltinTopicData* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::DDS::SubscriptionBuiltinTopicData *>(
                            data_allocator_->malloc(sizeof(::DDS::SubscriptionBuiltinTopicData))),
                           ::DDS::SubscriptionBuiltinTopicData);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::SubscriptionBuiltinTopicData>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
SubscriptionBuiltinTopicDataDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::DDS::SubscriptionBuiltinTopicData data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::DDS::SubscriptionBuiltinTopicData>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
SubscriptionBuiltinTopicDataDataReaderImpl::store_instance_data(
    ::DDS::SubscriptionBuiltinTopicData *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  SubscriptionBuiltinTopicData );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriptionBuiltinTopicData );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriptionBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriptionBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("SubscriptionBuiltinTopicDataDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::DDS::SubscriptionBuiltinTopicData failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriptionBuiltinTopicDataDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("SubscriptionBuiltinTopicDataDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::DDS::SubscriptionBuiltinTopicData failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriptionBuiltinTopicData );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriptionBuiltinTopicData );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         SubscriptionBuiltinTopicData );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    SubscriptionBuiltinTopicData );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  SubscriptionBuiltinTopicData );
  }
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::auto_return_loan(void* seq)
{
  ::DDS::SubscriptionBuiltinTopicDataSeq& received_data =
    *static_cast< ::DDS::SubscriptionBuiltinTopicDataSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
SubscriptionBuiltinTopicDataDataReaderImpl::check_inputs (
    const char* method_name,
    ::DDS::SubscriptionBuiltinTopicDataSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::DDS::SubscriptionBuiltinTopicDataSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriptionBuiltinTopicDataDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
SubscriptionBuiltinTopicDataDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SubscriptionBuiltinTopicData> : MetaStruct {
  typedef DDS::SubscriptionBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SubscriptionBuiltinTopicData& typed = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SubscriptionBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4, 0), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18, 0), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13, 0), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "deadline", "latency_budget", "liveliness", "reliability", "ownership", "destination_order", "user_data", "time_based_filter", "presentation", "partition", "topic_data", "group_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name, static_cast<const T*>(rhs)->topic_name);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name, static_cast<const T*>(rhs)->type_name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SubscriptionBuiltinTopicData>()
{
  static MetaStructImpl<DDS::SubscriptionBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SubscriptionBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SubscriptionBuiltinTopicData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */


/* Begin STRUCT: SampleInfo */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SampleInfo& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sample_state);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.view_state);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.instance_state);
  gen_find_size(stru.source_timestamp, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.instance_handle);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.publication_handle);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.disposed_generation_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.no_writers_generation_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sample_rank);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.generation_rank);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.absolute_generation_rank);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.valid_data));
}

bool operator<<(Serializer& strm, const DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sample_state)
    && (strm << stru.view_state)
    && (strm << stru.instance_state)
    && (strm << stru.source_timestamp)
    && (strm << stru.instance_handle)
    && (strm << stru.publication_handle)
    && (strm << stru.disposed_generation_count)
    && (strm << stru.no_writers_generation_count)
    && (strm << stru.sample_rank)
    && (strm << stru.generation_rank)
    && (strm << stru.absolute_generation_rank)
    && (strm << ACE_OutputCDR::from_boolean(stru.valid_data));
}

bool operator>>(Serializer& strm, DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sample_state)
    && (strm >> stru.view_state)
    && (strm >> stru.instance_state)
    && (strm >> stru.source_timestamp)
    && (strm >> stru.instance_handle)
    && (strm >> stru.publication_handle)
    && (strm >> stru.disposed_generation_count)
    && (strm >> stru.no_writers_generation_count)
    && (strm >> stru.sample_rank)
    && (strm >> stru.generation_rank)
    && (strm >> stru.absolute_generation_rank)
    && (strm >> ACE_InputCDR::to_boolean(stru.valid_data));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SampleInfo> : MetaStruct {
  typedef DDS::SampleInfo T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SampleInfo& typed = *static_cast<const DDS::SampleInfo*>(stru);
    if (std::strcmp(field, "sample_state") == 0) {
      return typed.sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return typed.view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return typed.instance_state;
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return getMetaStruct<DDS::Time_t>().getValue(&typed.source_timestamp, field + 17);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return typed.instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return typed.publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return typed.disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return typed.no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return typed.sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return typed.generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return typed.absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return typed.valid_data;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sample_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sample_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "view_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'view_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "instance_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'instance_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return getMetaStruct<DDS::Time_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<DDS::Time_t*>(0));
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'instance_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'publication_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'disposed_generation_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'no_writers_generation_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sample_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'generation_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'absolute_generation_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "valid_data") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'valid_data' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct DDS::SampleInfo");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sample_state") == 0) {
      return make_field_cmp(&T::sample_state, next);
    }
    if (std::strcmp(field, "view_state") == 0) {
      return make_field_cmp(&T::view_state, next);
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return make_field_cmp(&T::instance_state, next);
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return make_struct_cmp(&T::source_timestamp, getMetaStruct<DDS::Time_t>().create_qc_comparator(field + 17, 0), next);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return make_field_cmp(&T::instance_handle, next);
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return make_field_cmp(&T::publication_handle, next);
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return make_field_cmp(&T::disposed_generation_count, next);
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return make_field_cmp(&T::no_writers_generation_count, next);
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return make_field_cmp(&T::sample_rank, next);
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return make_field_cmp(&T::generation_rank, next);
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return make_field_cmp(&T::absolute_generation_rank, next);
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return make_field_cmp(&T::valid_data, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sample_state", "view_state", "instance_state", "source_timestamp", "instance_handle", "publication_handle", "disposed_generation_count", "no_writers_generation_count", "sample_rank", "generation_rank", "absolute_generation_rank", "valid_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sample_state") == 0) {
      return &static_cast<const T*>(stru)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return &static_cast<const T*>(stru)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return &static_cast<const T*>(stru)->instance_state;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      return &static_cast<const T*>(stru)->source_timestamp;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return &static_cast<const T*>(stru)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return &static_cast<const T*>(stru)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return &static_cast<const T*>(stru)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return &static_cast<const T*>(stru)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return &static_cast<const T*>(stru)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return &static_cast<const T*>(stru)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return &static_cast<const T*>(stru)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return &static_cast<const T*>(stru)->valid_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sample_state") == 0) {
      static_cast<T*>(lhs)->sample_state = *static_cast<const DDS::SampleStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "view_state") == 0) {
      static_cast<T*>(lhs)->view_state = *static_cast<const DDS::ViewStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      static_cast<T*>(lhs)->instance_state = *static_cast<const DDS::InstanceStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      static_cast<T*>(lhs)->source_timestamp = *static_cast<const DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      static_cast<T*>(lhs)->instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      static_cast<T*>(lhs)->publication_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      static_cast<T*>(lhs)->disposed_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      static_cast<T*>(lhs)->no_writers_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      static_cast<T*>(lhs)->sample_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      static_cast<T*>(lhs)->generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      static_cast<T*>(lhs)->absolute_generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      static_cast<T*>(lhs)->valid_data = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sample_state") == 0) {
      return static_cast<const T*>(lhs)->sample_state == static_cast<const T*>(rhs)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return static_cast<const T*>(lhs)->view_state == static_cast<const T*>(rhs)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return static_cast<const T*>(lhs)->instance_state == static_cast<const T*>(rhs)->instance_state;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return static_cast<const T*>(lhs)->instance_handle == static_cast<const T*>(rhs)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return static_cast<const T*>(lhs)->publication_handle == static_cast<const T*>(rhs)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return static_cast<const T*>(lhs)->disposed_generation_count == static_cast<const T*>(rhs)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return static_cast<const T*>(lhs)->no_writers_generation_count == static_cast<const T*>(rhs)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return static_cast<const T*>(lhs)->sample_rank == static_cast<const T*>(rhs)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return static_cast<const T*>(lhs)->generation_rank == static_cast<const T*>(rhs)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return static_cast<const T*>(lhs)->absolute_generation_rank == static_cast<const T*>(rhs)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return static_cast<const T*>(lhs)->valid_data == static_cast<const T*>(rhs)->valid_data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SampleInfo>()
{
  static MetaStructImpl<DDS::SampleInfo> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SampleInfo*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SampleInfo>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SampleInfo */


/* Begin NATIVE: SampleInfoSeq */


/* End NATIVE: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
