/* -*- C++ -*- */
/* Generated by ../../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file Federator.idl*/
#ifndef OPENDDS_IDL_GENERATED_FEDERATORTYPESUPPORTIMPL_H_UGMJR4
#define OPENDDS_IDL_GENERATED_FEDERATORTYPESUPPORTIMPL_H_UGMJR4
#include "dds/DCPS/Definitions.h"
#include "FederatorC.h"
#include "FederatorTypeSupportC.h"
#include "dds/DCPS/DataReaderImpl.h"
#include "dds/DCPS/DataWriterImpl.h"
#include "dds/DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h"
#include "dds/DCPS/InfoRepoDiscovery/InfoC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/SubscriptionInstance.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DdsDcpsGuidC.h"
#include "tao/OctetSeqC.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: Federator */



/* Begin TYPEDEF: RepoKey */


/* End TYPEDEF: RepoKey */


/* Begin TYPEDEF: FederationDomain */


/* End TYPEDEF: FederationDomain */


/* Begin TYPEDEF: FederationId */


/* End TYPEDEF: FederationId */


/* Begin ENUM: UpdateType */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::UpdateType& enumval);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::UpdateType& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_OpenDDS_Federator_UpdateType_names[];
}  }

#endif

/* End ENUM: UpdateType */


/* Begin CONST: NIL_REPOSITORY */


/* End CONST: NIL_REPOSITORY */


/* Begin CONST: DEFAULT_FEDERATIONDOMAIN */


/* End CONST: DEFAULT_FEDERATIONDOMAIN */


/* Begin CONST: ANY_FEDERATIONDOMAIN */


/* End CONST: ANY_FEDERATIONDOMAIN */


/* Begin STRUCT: OwnerUpdate */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
void gen_find_size(const OpenDDS::Federator::OwnerUpdate& stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::OwnerUpdate& stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::OwnerUpdate& stru);

OpenDDS_Federator_Export
bool gen_is_bounded_size(const OpenDDS::Federator::OwnerUpdate&);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(const OpenDDS::Federator::OwnerUpdate& stru, bool align);

OpenDDS_Federator_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::Federator::OwnerUpdate>);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::Federator::OwnerUpdate> stru, bool align);

OpenDDS_Federator_Export
void gen_find_size(KeyOnly<const OpenDDS::Federator::OwnerUpdate> stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::Federator::OwnerUpdate> stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::Federator::OwnerUpdate> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool gen_has_key(const OpenDDS::Federator::OwnerUpdate&);

}  }

namespace OpenDDS {
namespace Federator {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Federator_Export OwnerUpdate_KeyLessThan {
  bool operator()(const OpenDDS::Federator::OwnerUpdate& v1, const OpenDDS::Federator::OwnerUpdate& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.sender < v2.sender) return true;
    if (v2.sender < v1.sender) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace Federator {

class OwnerUpdateDataWriterImpl;
class OwnerUpdateDataReaderImpl;

/** Servant for TypeSupport interface of OwnerUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export OwnerUpdateTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<OwnerUpdateTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OwnerUpdate                message_type;
  typedef OwnerUpdate_var            message_var;
  typedef OwnerUpdateTypeSupport     typesupport_type;
  typedef OwnerUpdateTypeSupport_var typesupport_var;
  typedef OwnerUpdateDataWriter      datawriter_type;
  typedef OwnerUpdateDataReader      datareader_type;
  typedef OwnerUpdateDataWriter_var  datawriter_var;
  typedef OwnerUpdateDataReader_var  datareader_var;
  typedef OwnerUpdateDataWriterImpl  datawriterimpl_type;
  typedef OwnerUpdateDataReaderImpl  datareaderimpl_type;

  OwnerUpdateTypeSupportImpl();
  virtual ~OwnerUpdateTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef OwnerUpdateTypeSupport::_ptr_type _ptr_type;
  typedef OwnerUpdateTypeSupport::_var_type _var_type;
  typedef OwnerUpdateDataWriter data_writer_type;
  typedef OwnerUpdateDataReader data_reader_type;
  typedef ::OpenDDS::Federator::OwnerUpdate data_sample_type;
  typedef ::OpenDDS::Federator::OwnerUpdateSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return OwnerUpdateTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the OwnerUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Federator_Export OwnerUpdateDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<OwnerUpdateDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef OwnerUpdate                message_type;
  typedef OwnerUpdateTypeSupportImpl typesupportimpl_type;
  typedef OwnerUpdateDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::Federator::OwnerUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::OwnerUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  OwnerUpdateDataWriterImpl (void);

  /// Destructor
  virtual ~OwnerUpdateDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::Federator::OwnerUpdate & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::Federator::OwnerUpdate & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::Federator::OwnerUpdate & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::Federator::OwnerUpdate & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::OwnerUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::Federator::OwnerUpdate& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::Federator::OwnerUpdate& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of OwnerUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export OwnerUpdateDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<OwnerUpdateDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef OwnerUpdate                message_type;
  typedef OwnerUpdateTypeSupportImpl typesupportimpl_type;
  typedef OwnerUpdateDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::Federator::OwnerUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::OwnerUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::Federator::OwnerUpdate, ACE_Null_Mutex>  DataAllocator;
  typedef OwnerUpdateDataReader Interface;

  /// Constructor
  OwnerUpdateDataReaderImpl (void);

  /// Destructor
  virtual ~OwnerUpdateDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::Federator::OwnerUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::Federator::OwnerUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::Federator::OwnerUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::Federator::OwnerUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::Federator::OwnerUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::Federator::OwnerUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::OwnerUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::OwnerUpdate & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::Federator::OwnerUpdateSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::Federator::OwnerUpdate& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::Federator::OwnerUpdate *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::Federator::OwnerUpdateSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_Federator_Export
const MetaStruct& getMetaStruct<OpenDDS::Federator::OwnerUpdate>();
OpenDDS_Federator_Export
void gen_skip_over(Serializer& ser, OpenDDS::Federator::OwnerUpdate*);

}  }

#endif

/* End STRUCT: OwnerUpdate */


/* Begin CONST: OWNERUPDATETOPICNAME */


/* End CONST: OWNERUPDATETOPICNAME */


/* Begin CONST: OWNERUPDATETYPENAME */


/* End CONST: OWNERUPDATETYPENAME */


/* Begin STRUCT: TopicUpdate */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
void gen_find_size(const OpenDDS::Federator::TopicUpdate& stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::TopicUpdate& stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::TopicUpdate& stru);

OpenDDS_Federator_Export
bool gen_is_bounded_size(const OpenDDS::Federator::TopicUpdate&);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(const OpenDDS::Federator::TopicUpdate& stru, bool align);

OpenDDS_Federator_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::Federator::TopicUpdate>);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::Federator::TopicUpdate> stru, bool align);

OpenDDS_Federator_Export
void gen_find_size(KeyOnly<const OpenDDS::Federator::TopicUpdate> stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::Federator::TopicUpdate> stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::Federator::TopicUpdate> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool gen_has_key(const OpenDDS::Federator::TopicUpdate&);

}  }

namespace OpenDDS {
namespace Federator {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Federator_Export TopicUpdate_KeyLessThan {
  bool operator()(const OpenDDS::Federator::TopicUpdate& v1, const OpenDDS::Federator::TopicUpdate& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.sender < v2.sender) return true;
    if (v2.sender < v1.sender) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace Federator {

class TopicUpdateDataWriterImpl;
class TopicUpdateDataReaderImpl;

/** Servant for TypeSupport interface of TopicUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export TopicUpdateTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicUpdateTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef TopicUpdate                message_type;
  typedef TopicUpdate_var            message_var;
  typedef TopicUpdateTypeSupport     typesupport_type;
  typedef TopicUpdateTypeSupport_var typesupport_var;
  typedef TopicUpdateDataWriter      datawriter_type;
  typedef TopicUpdateDataReader      datareader_type;
  typedef TopicUpdateDataWriter_var  datawriter_var;
  typedef TopicUpdateDataReader_var  datareader_var;
  typedef TopicUpdateDataWriterImpl  datawriterimpl_type;
  typedef TopicUpdateDataReaderImpl  datareaderimpl_type;

  TopicUpdateTypeSupportImpl();
  virtual ~TopicUpdateTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef TopicUpdateTypeSupport::_ptr_type _ptr_type;
  typedef TopicUpdateTypeSupport::_var_type _var_type;
  typedef TopicUpdateDataWriter data_writer_type;
  typedef TopicUpdateDataReader data_reader_type;
  typedef ::OpenDDS::Federator::TopicUpdate data_sample_type;
  typedef ::OpenDDS::Federator::TopicUpdateSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return TopicUpdateTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the TopicUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Federator_Export TopicUpdateDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicUpdateDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef TopicUpdate                message_type;
  typedef TopicUpdateTypeSupportImpl typesupportimpl_type;
  typedef TopicUpdateDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::Federator::TopicUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  TopicUpdateDataWriterImpl (void);

  /// Destructor
  virtual ~TopicUpdateDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::Federator::TopicUpdate & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::Federator::TopicUpdate & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::Federator::TopicUpdate & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::Federator::TopicUpdate & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::Federator::TopicUpdate & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::Federator::TopicUpdate & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::Federator::TopicUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::Federator::TopicUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::TopicUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::TopicUpdate & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::Federator::TopicUpdate& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::Federator::TopicUpdate& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of TopicUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export TopicUpdateDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicUpdateDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef TopicUpdate                message_type;
  typedef TopicUpdateTypeSupportImpl typesupportimpl_type;
  typedef TopicUpdateDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::Federator::TopicUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::Federator::TopicUpdate, ACE_Null_Mutex>  DataAllocator;
  typedef TopicUpdateDataReader Interface;

  /// Constructor
  TopicUpdateDataReaderImpl (void);

  /// Destructor
  virtual ~TopicUpdateDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::Federator::TopicUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::Federator::TopicUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::Federator::TopicUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::Federator::TopicUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::Federator::TopicUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::Federator::TopicUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::TopicUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::TopicUpdate & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::Federator::TopicUpdateSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::Federator::TopicUpdate& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::Federator::TopicUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::Federator::TopicUpdate *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::Federator::TopicUpdateSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Federator_Export
const MetaStruct& getMetaStruct<OpenDDS::Federator::TopicUpdate>();
OpenDDS_Federator_Export
void gen_skip_over(Serializer& ser, OpenDDS::Federator::TopicUpdate*);

}  }

#endif

/* End STRUCT: TopicUpdate */


/* Begin CONST: TOPICUPDATETOPICNAME */


/* End CONST: TOPICUPDATETOPICNAME */


/* Begin CONST: TOPICUPDATETYPENAME */


/* End CONST: TOPICUPDATETYPENAME */


/* Begin STRUCT: ParticipantUpdate */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
void gen_find_size(const OpenDDS::Federator::ParticipantUpdate& stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::ParticipantUpdate& stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::ParticipantUpdate& stru);

OpenDDS_Federator_Export
bool gen_is_bounded_size(const OpenDDS::Federator::ParticipantUpdate&);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(const OpenDDS::Federator::ParticipantUpdate& stru, bool align);

OpenDDS_Federator_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::Federator::ParticipantUpdate>);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::Federator::ParticipantUpdate> stru, bool align);

OpenDDS_Federator_Export
void gen_find_size(KeyOnly<const OpenDDS::Federator::ParticipantUpdate> stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::Federator::ParticipantUpdate> stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::Federator::ParticipantUpdate> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool gen_has_key(const OpenDDS::Federator::ParticipantUpdate&);

}  }

namespace OpenDDS {
namespace Federator {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Federator_Export ParticipantUpdate_KeyLessThan {
  bool operator()(const OpenDDS::Federator::ParticipantUpdate& v1, const OpenDDS::Federator::ParticipantUpdate& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.sender < v2.sender) return true;
    if (v2.sender < v1.sender) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace Federator {

class ParticipantUpdateDataWriterImpl;
class ParticipantUpdateDataReaderImpl;

/** Servant for TypeSupport interface of ParticipantUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export ParticipantUpdateTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantUpdateTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef ParticipantUpdate                message_type;
  typedef ParticipantUpdate_var            message_var;
  typedef ParticipantUpdateTypeSupport     typesupport_type;
  typedef ParticipantUpdateTypeSupport_var typesupport_var;
  typedef ParticipantUpdateDataWriter      datawriter_type;
  typedef ParticipantUpdateDataReader      datareader_type;
  typedef ParticipantUpdateDataWriter_var  datawriter_var;
  typedef ParticipantUpdateDataReader_var  datareader_var;
  typedef ParticipantUpdateDataWriterImpl  datawriterimpl_type;
  typedef ParticipantUpdateDataReaderImpl  datareaderimpl_type;

  ParticipantUpdateTypeSupportImpl();
  virtual ~ParticipantUpdateTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef ParticipantUpdateTypeSupport::_ptr_type _ptr_type;
  typedef ParticipantUpdateTypeSupport::_var_type _var_type;
  typedef ParticipantUpdateDataWriter data_writer_type;
  typedef ParticipantUpdateDataReader data_reader_type;
  typedef ::OpenDDS::Federator::ParticipantUpdate data_sample_type;
  typedef ::OpenDDS::Federator::ParticipantUpdateSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return ParticipantUpdateTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the ParticipantUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Federator_Export ParticipantUpdateDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantUpdateDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef ParticipantUpdate                message_type;
  typedef ParticipantUpdateTypeSupportImpl typesupportimpl_type;
  typedef ParticipantUpdateDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::Federator::ParticipantUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ParticipantUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  ParticipantUpdateDataWriterImpl (void);

  /// Destructor
  virtual ~ParticipantUpdateDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::Federator::ParticipantUpdate & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::Federator::ParticipantUpdate & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::Federator::ParticipantUpdate & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::Federator::ParticipantUpdate & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::ParticipantUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::Federator::ParticipantUpdate& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::Federator::ParticipantUpdate& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of ParticipantUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export ParticipantUpdateDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantUpdateDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef ParticipantUpdate                message_type;
  typedef ParticipantUpdateTypeSupportImpl typesupportimpl_type;
  typedef ParticipantUpdateDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::Federator::ParticipantUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ParticipantUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::Federator::ParticipantUpdate, ACE_Null_Mutex>  DataAllocator;
  typedef ParticipantUpdateDataReader Interface;

  /// Constructor
  ParticipantUpdateDataReaderImpl (void);

  /// Destructor
  virtual ~ParticipantUpdateDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::Federator::ParticipantUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::Federator::ParticipantUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::Federator::ParticipantUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::Federator::ParticipantUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::Federator::ParticipantUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::Federator::ParticipantUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::ParticipantUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::ParticipantUpdate & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::Federator::ParticipantUpdateSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::Federator::ParticipantUpdate& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::Federator::ParticipantUpdate *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::Federator::ParticipantUpdateSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Federator_Export
const MetaStruct& getMetaStruct<OpenDDS::Federator::ParticipantUpdate>();
OpenDDS_Federator_Export
void gen_skip_over(Serializer& ser, OpenDDS::Federator::ParticipantUpdate*);

}  }

#endif

/* End STRUCT: ParticipantUpdate */


/* Begin CONST: PARTICIPANTUPDATETOPICNAME */


/* End CONST: PARTICIPANTUPDATETOPICNAME */


/* Begin CONST: PARTICIPANTUPDATETYPENAME */


/* End CONST: PARTICIPANTUPDATETYPENAME */


/* Begin STRUCT: PublicationUpdate */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
void gen_find_size(const OpenDDS::Federator::PublicationUpdate& stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::PublicationUpdate& stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::PublicationUpdate& stru);

OpenDDS_Federator_Export
bool gen_is_bounded_size(const OpenDDS::Federator::PublicationUpdate&);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(const OpenDDS::Federator::PublicationUpdate& stru, bool align);

OpenDDS_Federator_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::Federator::PublicationUpdate>);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::Federator::PublicationUpdate> stru, bool align);

OpenDDS_Federator_Export
void gen_find_size(KeyOnly<const OpenDDS::Federator::PublicationUpdate> stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::Federator::PublicationUpdate> stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::Federator::PublicationUpdate> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool gen_has_key(const OpenDDS::Federator::PublicationUpdate&);

}  }

namespace OpenDDS {
namespace Federator {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Federator_Export PublicationUpdate_KeyLessThan {
  bool operator()(const OpenDDS::Federator::PublicationUpdate& v1, const OpenDDS::Federator::PublicationUpdate& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.sender < v2.sender) return true;
    if (v2.sender < v1.sender) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace Federator {

class PublicationUpdateDataWriterImpl;
class PublicationUpdateDataReaderImpl;

/** Servant for TypeSupport interface of PublicationUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export PublicationUpdateTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationUpdateTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef PublicationUpdate                message_type;
  typedef PublicationUpdate_var            message_var;
  typedef PublicationUpdateTypeSupport     typesupport_type;
  typedef PublicationUpdateTypeSupport_var typesupport_var;
  typedef PublicationUpdateDataWriter      datawriter_type;
  typedef PublicationUpdateDataReader      datareader_type;
  typedef PublicationUpdateDataWriter_var  datawriter_var;
  typedef PublicationUpdateDataReader_var  datareader_var;
  typedef PublicationUpdateDataWriterImpl  datawriterimpl_type;
  typedef PublicationUpdateDataReaderImpl  datareaderimpl_type;

  PublicationUpdateTypeSupportImpl();
  virtual ~PublicationUpdateTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef PublicationUpdateTypeSupport::_ptr_type _ptr_type;
  typedef PublicationUpdateTypeSupport::_var_type _var_type;
  typedef PublicationUpdateDataWriter data_writer_type;
  typedef PublicationUpdateDataReader data_reader_type;
  typedef ::OpenDDS::Federator::PublicationUpdate data_sample_type;
  typedef ::OpenDDS::Federator::PublicationUpdateSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return PublicationUpdateTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the PublicationUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Federator_Export PublicationUpdateDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationUpdateDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef PublicationUpdate                message_type;
  typedef PublicationUpdateTypeSupportImpl typesupportimpl_type;
  typedef PublicationUpdateDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::Federator::PublicationUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublicationUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  PublicationUpdateDataWriterImpl (void);

  /// Destructor
  virtual ~PublicationUpdateDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::Federator::PublicationUpdate & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::Federator::PublicationUpdate & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::Federator::PublicationUpdate & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::Federator::PublicationUpdate & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::PublicationUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::Federator::PublicationUpdate& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::Federator::PublicationUpdate& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of PublicationUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export PublicationUpdateDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationUpdateDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef PublicationUpdate                message_type;
  typedef PublicationUpdateTypeSupportImpl typesupportimpl_type;
  typedef PublicationUpdateDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::Federator::PublicationUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublicationUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::Federator::PublicationUpdate, ACE_Null_Mutex>  DataAllocator;
  typedef PublicationUpdateDataReader Interface;

  /// Constructor
  PublicationUpdateDataReaderImpl (void);

  /// Destructor
  virtual ~PublicationUpdateDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::Federator::PublicationUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::Federator::PublicationUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::Federator::PublicationUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::Federator::PublicationUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::Federator::PublicationUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::Federator::PublicationUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::PublicationUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::PublicationUpdate & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::Federator::PublicationUpdateSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::Federator::PublicationUpdate& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::Federator::PublicationUpdate *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::Federator::PublicationUpdateSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Federator_Export
const MetaStruct& getMetaStruct<OpenDDS::Federator::PublicationUpdate>();
OpenDDS_Federator_Export
void gen_skip_over(Serializer& ser, OpenDDS::Federator::PublicationUpdate*);

}  }

#endif

/* End STRUCT: PublicationUpdate */


/* Begin CONST: PUBLICATIONUPDATETOPICNAME */


/* End CONST: PUBLICATIONUPDATETOPICNAME */


/* Begin CONST: PUBLICATIONUPDATETYPENAME */


/* End CONST: PUBLICATIONUPDATETYPENAME */


/* Begin STRUCT: SubscriptionUpdate */

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
void gen_find_size(const OpenDDS::Federator::SubscriptionUpdate& stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, const OpenDDS::Federator::SubscriptionUpdate& stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, OpenDDS::Federator::SubscriptionUpdate& stru);

OpenDDS_Federator_Export
bool gen_is_bounded_size(const OpenDDS::Federator::SubscriptionUpdate&);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(const OpenDDS::Federator::SubscriptionUpdate& stru, bool align);

OpenDDS_Federator_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::Federator::SubscriptionUpdate>);

OpenDDS_Federator_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::Federator::SubscriptionUpdate> stru, bool align);

OpenDDS_Federator_Export
void gen_find_size(KeyOnly<const OpenDDS::Federator::SubscriptionUpdate> stru, size_t& size, size_t& padding);

OpenDDS_Federator_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::Federator::SubscriptionUpdate> stru);

OpenDDS_Federator_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::Federator::SubscriptionUpdate> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_Federator_Export
bool gen_has_key(const OpenDDS::Federator::SubscriptionUpdate&);

}  }

namespace OpenDDS {
namespace Federator {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Federator_Export SubscriptionUpdate_KeyLessThan {
  bool operator()(const OpenDDS::Federator::SubscriptionUpdate& v1, const OpenDDS::Federator::SubscriptionUpdate& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.sender < v2.sender) return true;
    if (v2.sender < v1.sender) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace Federator {

class SubscriptionUpdateDataWriterImpl;
class SubscriptionUpdateDataReaderImpl;

/** Servant for TypeSupport interface of SubscriptionUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export SubscriptionUpdateTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionUpdateTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef SubscriptionUpdate                message_type;
  typedef SubscriptionUpdate_var            message_var;
  typedef SubscriptionUpdateTypeSupport     typesupport_type;
  typedef SubscriptionUpdateTypeSupport_var typesupport_var;
  typedef SubscriptionUpdateDataWriter      datawriter_type;
  typedef SubscriptionUpdateDataReader      datareader_type;
  typedef SubscriptionUpdateDataWriter_var  datawriter_var;
  typedef SubscriptionUpdateDataReader_var  datareader_var;
  typedef SubscriptionUpdateDataWriterImpl  datawriterimpl_type;
  typedef SubscriptionUpdateDataReaderImpl  datareaderimpl_type;

  SubscriptionUpdateTypeSupportImpl();
  virtual ~SubscriptionUpdateTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef SubscriptionUpdateTypeSupport::_ptr_type _ptr_type;
  typedef SubscriptionUpdateTypeSupport::_var_type _var_type;
  typedef SubscriptionUpdateDataWriter data_writer_type;
  typedef SubscriptionUpdateDataReader data_reader_type;
  typedef ::OpenDDS::Federator::SubscriptionUpdate data_sample_type;
  typedef ::OpenDDS::Federator::SubscriptionUpdateSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return SubscriptionUpdateTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the SubscriptionUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_Federator_Export SubscriptionUpdateDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionUpdateDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef SubscriptionUpdate                message_type;
  typedef SubscriptionUpdateTypeSupportImpl typesupportimpl_type;
  typedef SubscriptionUpdateDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::Federator::SubscriptionUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriptionUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  SubscriptionUpdateDataWriterImpl (void);

  /// Destructor
  virtual ~SubscriptionUpdateDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::SubscriptionUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::Federator::SubscriptionUpdate& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::Federator::SubscriptionUpdate& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of SubscriptionUpdate data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_Federator_Export SubscriptionUpdateDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionUpdateDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef SubscriptionUpdate                message_type;
  typedef SubscriptionUpdateTypeSupportImpl typesupportimpl_type;
  typedef SubscriptionUpdateDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::Federator::SubscriptionUpdate, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriptionUpdate_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::Federator::SubscriptionUpdate, ACE_Null_Mutex>  DataAllocator;
  typedef SubscriptionUpdateDataReader Interface;

  /// Constructor
  SubscriptionUpdateDataReaderImpl (void);

  /// Destructor
  virtual ~SubscriptionUpdateDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::Federator::SubscriptionUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::Federator::SubscriptionUpdate & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::Federator::SubscriptionUpdate & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::Federator::SubscriptionUpdate & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::Federator::SubscriptionUpdateSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::Federator::SubscriptionUpdate& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::Federator::SubscriptionUpdate *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::Federator::SubscriptionUpdateSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Federator_Export
const MetaStruct& getMetaStruct<OpenDDS::Federator::SubscriptionUpdate>();
OpenDDS_Federator_Export
void gen_skip_over(Serializer& ser, OpenDDS::Federator::SubscriptionUpdate*);

}  }

#endif

/* End STRUCT: SubscriptionUpdate */


/* Begin CONST: SUBSCRIPTIONUPDATETOPICNAME */


/* End CONST: SUBSCRIPTIONUPDATETOPICNAME */


/* Begin CONST: SUBSCRIPTIONUPDATETYPENAME */


/* End CONST: SUBSCRIPTIONUPDATETYPENAME */


/* Begin EXCEPTION: Incomplete */


/* End EXCEPTION: Incomplete */


/* Begin INTERFACE: Manager */


/* End INTERFACE: Manager */


/* Begin CONST: REPOSITORY_IORTABLE_KEY */


/* End CONST: REPOSITORY_IORTABLE_KEY */


/* Begin CONST: FEDERATOR_IORTABLE_KEY */


/* End CONST: FEDERATOR_IORTABLE_KEY */

/* End MODULE: Federator */

/* End MODULE: OpenDDS */
#endif /* OPENDDS_IDL_GENERATED_FEDERATORTYPESUPPORTIMPL_H_UGMJR4 */
