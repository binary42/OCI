/* Generated by ../../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file monitor.idl*/
#include "monitorTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/CorbaSeq/ULongSeqTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"
#include "dds/DdsDcpsInfrastructureTypeSupportImpl.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::Statistics& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.n);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.maximum);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.minimum);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.mean);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.variance);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.n)
    && (strm << stru.maximum)
    && (strm << stru.minimum)
    && (strm << stru.mean)
    && (strm << stru.variance);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.n)
    && (strm >> stru.maximum)
    && (strm >> stru.minimum)
    && (strm >> stru.mean)
    && (strm >> stru.variance);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::Statistics> : MetaStruct {
  typedef OpenDDS::DCPS::Statistics T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::Statistics& typed = *static_cast<const OpenDDS::DCPS::Statistics*>(stru);
    if (std::strcmp(field, "n") == 0) {
      return typed.n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return typed.maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return typed.minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return typed.mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return typed.variance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "n") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'n' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "maximum") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'maximum' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "minimum") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'minimum' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "mean") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'mean' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "variance") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'variance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::Statistics");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "n") == 0) {
      return make_field_cmp(&T::n, next);
    }
    if (std::strcmp(field, "maximum") == 0) {
      return make_field_cmp(&T::maximum, next);
    }
    if (std::strcmp(field, "minimum") == 0) {
      return make_field_cmp(&T::minimum, next);
    }
    if (std::strcmp(field, "mean") == 0) {
      return make_field_cmp(&T::mean, next);
    }
    if (std::strcmp(field, "variance") == 0) {
      return make_field_cmp(&T::variance, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"n", "maximum", "minimum", "mean", "variance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "n") == 0) {
      return &static_cast<const T*>(stru)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return &static_cast<const T*>(stru)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return &static_cast<const T*>(stru)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return &static_cast<const T*>(stru)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return &static_cast<const T*>(stru)->variance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "n") == 0) {
      static_cast<T*>(lhs)->n = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "maximum") == 0) {
      static_cast<T*>(lhs)->maximum = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minimum") == 0) {
      static_cast<T*>(lhs)->minimum = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "mean") == 0) {
      static_cast<T*>(lhs)->mean = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "variance") == 0) {
      static_cast<T*>(lhs)->variance = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "n") == 0) {
      return static_cast<const T*>(lhs)->n == static_cast<const T*>(rhs)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return static_cast<const T*>(lhs)->maximum == static_cast<const T*>(rhs)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return static_cast<const T*>(lhs)->minimum == static_cast<const T*>(rhs)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return static_cast<const T*>(lhs)->mean == static_cast<const T*>(rhs)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return static_cast<const T*>(lhs)->variance == static_cast<const T*>(rhs)->variance;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::Statistics>()
{
  static MetaStructImpl<OpenDDS::DCPS::Statistics> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::Statistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::Statistics>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::ValueEnumType>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ValueEnumType_names[] = {
  "INTEGER_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "STATISTICS_TYPE",
  "STRING_LIST_TYPE"
};
}  }

#endif

/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ValueUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.integer_value());
      break;
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      if ((size + padding) % 8) {
        padding += 8 - ((size + padding) % 8);
      }
      size += gen_max_marshaled_size(uni.double_value());
      break;
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.string_value()) + 1;
      break;
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      gen_find_size(uni.stat_value(), size, padding);
      break;
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      gen_find_size(uni.string_seq_value(), size, padding);
      break;
    }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      return (strm << uni.integer_value());
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      return (strm << uni.double_value());
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      return (strm << uni.string_value());
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      return (strm << uni.stat_value());
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      return (strm << uni.string_seq_value());
    }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  OpenDDS::DCPS::ValueEnumType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      CORBA::Long tmp;
      if (strm >> tmp) {
        uni.integer_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      CORBA::Double tmp;
      if (strm >> tmp) {
        uni.double_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      CORBA::String_var tmp;
      if (strm >> tmp.out()) {
        uni.string_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      OpenDDS::DCPS::Statistics tmp;
      if (strm >> tmp) {
        uni.stat_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      DDS::StringSeq tmp;
      if (strm >> tmp) {
        uni.string_seq_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ValueUnion*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::DCPS::ValueEnumType disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    ser.skip(1, 4);
    break;
  case OpenDDS::DCPS::DOUBLE_TYPE:
    ser.skip(1, 8);
    break;
  case OpenDDS::DCPS::STRING_TYPE:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
    }
    break;
  case OpenDDS::DCPS::STATISTICS_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::Statistics*>(0));
    break;
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    gen_skip_over(ser, static_cast<DDS::StringSeq*>(0));
    break;
  default:
    break;
  }
}

}  }

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::NameValuePair& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name) + 1;
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name)
    && (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out())
    && (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::NameValuePair> : MetaStruct {
  typedef OpenDDS::DCPS::NameValuePair T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::NameValuePair& typed = *static_cast<const OpenDDS::DCPS::NameValuePair*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::ValueUnion*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::NameValuePair");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const OpenDDS::DCPS::ValueUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name, static_cast<const T*>(rhs)->name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::NameValuePair>()
{
  static MetaStructImpl<OpenDDS::DCPS::NameValuePair> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NameValuePair*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::NameValuePair>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::NVPSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NVPSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NameValuePair*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  gen_find_size(stru.domain_participants, size, padding);
  gen_find_size(stru.transports, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host)
    && (strm << stru.pid)
    && (strm << stru.domain_participants)
    && (strm << stru.transports)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.domain_participants)
    && (strm >> stru.transports)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::ServiceParticipantReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport>)
{
  return false;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.host) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.pid);
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.host)
    && (strm << stru.t.pid);
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::ServiceParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.host.out())
    && (strm >> stru.t.pid);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::ServiceParticipantReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
ServiceParticipantReportTypeSupportImpl::ServiceParticipantReportTypeSupportImpl ()
{
}

ServiceParticipantReportTypeSupportImpl::~ServiceParticipantReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
ServiceParticipantReportTypeSupportImpl::create_datawriter ()
{
  ServiceParticipantReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 ServiceParticipantReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
ServiceParticipantReportTypeSupportImpl::create_datareader ()
{
  ServiceParticipantReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 ServiceParticipantReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
ServiceParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<ServiceParticipantReport,
    ServiceParticipantReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
ServiceParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ServiceParticipantReport>();
}

#endif

bool
ServiceParticipantReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(ServiceParticipantReport());
}


ServiceParticipantReportDataWriterImpl::ServiceParticipantReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

ServiceParticipantReportDataWriterImpl::~ServiceParticipantReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
ServiceParticipantReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
ServiceParticipantReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("ServiceParticipantReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ServiceParticipantReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ServiceParticipantReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // ServiceParticipantReportDataWriter.
  // That the instance handle is removed from there and hence
  // ServiceParticipantReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("ServiceParticipantReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("ServiceParticipantReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::ServiceParticipantReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
ServiceParticipantReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
ServiceParticipantReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::ServiceParticipantReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::ServiceParticipantReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ServiceParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ServiceParticipantReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ServiceParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ServiceParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The ServiceParticipantReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
ServiceParticipantReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::ServiceParticipantReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::ServiceParticipantReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("ServiceParticipantReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::ServiceParticipantReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
ServiceParticipantReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
ServiceParticipantReportDataReaderImpl::ServiceParticipantReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ServiceParticipantReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

ServiceParticipantReportDataReaderImpl::~ServiceParticipantReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::ServiceParticipantReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::ServiceParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::ServiceParticipantReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::ServiceParticipantReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::ServiceParticipantReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::ServiceParticipantReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::ServiceParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::ServiceParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
ServiceParticipantReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data
  )
{
  received_data.length(0);
}


void
ServiceParticipantReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::ServiceParticipantReport* const ptr
        = static_cast< ::OpenDDS::DCPS::ServiceParticipantReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    ServiceParticipantReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::ServiceParticipantReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
ServiceParticipantReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
ServiceParticipantReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::ServiceParticipantReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::ServiceParticipantReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::ServiceParticipantReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
ServiceParticipantReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::ServiceParticipantReport*>(data));
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::ServiceParticipantReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::ServiceParticipantReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::ServiceParticipantReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::ServiceParticipantReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
ServiceParticipantReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::ServiceParticipantReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::ServiceParticipantReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::ServiceParticipantReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::ServiceParticipantReport))),
      OpenDDS::DCPS::ServiceParticipantReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
ServiceParticipantReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::ServiceParticipantReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::ServiceParticipantReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::ServiceParticipantReport))),
      OpenDDS::DCPS::ServiceParticipantReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
ServiceParticipantReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::ServiceParticipantReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::ServiceParticipantReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::ServiceParticipantReport))),
                           ::OpenDDS::DCPS::ServiceParticipantReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
ServiceParticipantReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::ServiceParticipantReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
ServiceParticipantReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::ServiceParticipantReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  ServiceParticipantReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ServiceParticipantReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ServiceParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ServiceParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("ServiceParticipantReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::ServiceParticipantReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("ServiceParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("ServiceParticipantReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::ServiceParticipantReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ServiceParticipantReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      ServiceParticipantReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         ServiceParticipantReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    ServiceParticipantReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  ServiceParticipantReport );
  }
}

void
ServiceParticipantReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
ServiceParticipantReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::ServiceParticipantReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
ServiceParticipantReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::ServiceParticipantReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ServiceParticipantReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) ServiceParticipantReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) ServiceParticipantReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
ServiceParticipantReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
ServiceParticipantReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
ServiceParticipantReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport> : MetaStruct {
  typedef OpenDDS::DCPS::ServiceParticipantReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ServiceParticipantReport& typed = *static_cast<const OpenDDS::DCPS::ServiceParticipantReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<CORBA::ULongSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::ServiceParticipantReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "domain_participants", "transports", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      return &static_cast<const T*>(stru)->domain_participants;
    }
    if (std::strcmp(field, "transports") == 0) {
      return &static_cast<const T*>(stru)->transports;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      static_cast<T*>(lhs)->domain_participants = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transports") == 0) {
      static_cast<T*>(lhs)->transports = *static_cast<const CORBA::ULongSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host, static_cast<const T*>(rhs)->host);
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ServiceParticipantReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ServiceParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DomainParticipantReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.domain_id);
  gen_find_size(stru.topics, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host)
    && (strm << stru.pid)
    && (strm << stru.dp_id)
    && (strm << stru.domain_id)
    && (strm << stru.topics)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.dp_id)
    && (strm >> stru.domain_id)
    && (strm >> stru.topics)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::DomainParticipantReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DomainParticipantReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DomainParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::DomainParticipantReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
DomainParticipantReportTypeSupportImpl::DomainParticipantReportTypeSupportImpl ()
{
}

DomainParticipantReportTypeSupportImpl::~DomainParticipantReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
DomainParticipantReportTypeSupportImpl::create_datawriter ()
{
  DomainParticipantReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 DomainParticipantReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
DomainParticipantReportTypeSupportImpl::create_datareader ()
{
  DomainParticipantReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 DomainParticipantReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
DomainParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<DomainParticipantReport,
    DomainParticipantReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
DomainParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DomainParticipantReport>();
}

#endif

bool
DomainParticipantReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(DomainParticipantReport());
}


DomainParticipantReportDataWriterImpl::DomainParticipantReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

DomainParticipantReportDataWriterImpl::~DomainParticipantReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
DomainParticipantReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
DomainParticipantReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("DomainParticipantReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DomainParticipantReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DomainParticipantReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // DomainParticipantReportDataWriter.
  // That the instance handle is removed from there and hence
  // DomainParticipantReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DomainParticipantReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("DomainParticipantReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::DomainParticipantReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DomainParticipantReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
DomainParticipantReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::DomainParticipantReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::DomainParticipantReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DomainParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DomainParticipantReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DomainParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DomainParticipantReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The DomainParticipantReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
DomainParticipantReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::DomainParticipantReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
DomainParticipantReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::DomainParticipantReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("DomainParticipantReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::DomainParticipantReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
DomainParticipantReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
DomainParticipantReportDataReaderImpl::DomainParticipantReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DomainParticipantReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

DomainParticipantReportDataReaderImpl::~DomainParticipantReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DomainParticipantReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DomainParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::DomainParticipantReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DomainParticipantReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::DomainParticipantReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DomainParticipantReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DomainParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DomainParticipantReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
DomainParticipantReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data
  )
{
  received_data.length(0);
}


void
DomainParticipantReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::DomainParticipantReport* const ptr
        = static_cast< ::OpenDDS::DCPS::DomainParticipantReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    DomainParticipantReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::DomainParticipantReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DomainParticipantReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::DomainParticipantReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
DomainParticipantReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::DomainParticipantReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::DomainParticipantReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::DomainParticipantReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
DomainParticipantReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::DomainParticipantReport*>(data));
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DomainParticipantReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DomainParticipantReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DomainParticipantReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DomainParticipantReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
DomainParticipantReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::DomainParticipantReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::DomainParticipantReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DomainParticipantReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DomainParticipantReport))),
      OpenDDS::DCPS::DomainParticipantReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
DomainParticipantReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::DomainParticipantReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DomainParticipantReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DomainParticipantReport))),
      OpenDDS::DCPS::DomainParticipantReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
DomainParticipantReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::DomainParticipantReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::DomainParticipantReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::DomainParticipantReport))),
                           ::OpenDDS::DCPS::DomainParticipantReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
DomainParticipantReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::DomainParticipantReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
DomainParticipantReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::DomainParticipantReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DomainParticipantReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DomainParticipantReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DomainParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DomainParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("DomainParticipantReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::DomainParticipantReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DomainParticipantReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("DomainParticipantReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::DomainParticipantReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DomainParticipantReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DomainParticipantReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         DomainParticipantReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    DomainParticipantReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DomainParticipantReport );
  }
}

void
DomainParticipantReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
DomainParticipantReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::DomainParticipantReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DomainParticipantReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::DomainParticipantReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DomainParticipantReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DomainParticipantReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DomainParticipantReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
DomainParticipantReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
DomainParticipantReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
DomainParticipantReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport> : MetaStruct {
  typedef OpenDDS::DCPS::DomainParticipantReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DomainParticipantReport& typed = *static_cast<const OpenDDS::DCPS::DomainParticipantReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return typed.domain_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "domain_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'domain_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DomainParticipantReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return make_field_cmp(&T::domain_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "dp_id", "domain_id", "topics", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return &static_cast<const T*>(stru)->domain_id;
    }
    if (std::strcmp(field, "topics") == 0) {
      return &static_cast<const T*>(stru)->topics;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      static_cast<T*>(lhs)->domain_id = *static_cast<const DDS::DomainId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topics") == 0) {
      static_cast<T*>(lhs)->topics = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host, static_cast<const T*>(rhs)->host);
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return static_cast<const T*>(lhs)->domain_id == static_cast<const T*>(rhs)->domain_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DomainParticipantReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DomainParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TopicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name) + 1;
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.topic_id)
    && (strm << stru.topic_name)
    && (strm << stru.type_name)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::TopicReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::TopicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::TopicReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TopicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TopicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::TopicReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
TopicReportTypeSupportImpl::TopicReportTypeSupportImpl ()
{
}

TopicReportTypeSupportImpl::~TopicReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
TopicReportTypeSupportImpl::create_datawriter ()
{
  TopicReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 TopicReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
TopicReportTypeSupportImpl::create_datareader ()
{
  TopicReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 TopicReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
TopicReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<TopicReport,
    TopicReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
TopicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicReport>();
}

#endif

bool
TopicReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(TopicReport());
}


TopicReportDataWriterImpl::TopicReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

TopicReportDataWriterImpl::~TopicReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
TopicReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::TopicReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
TopicReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::TopicReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("TopicReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
TopicReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::TopicReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::TopicReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // TopicReportDataWriter.
  // That the instance handle is removed from there and hence
  // TopicReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::TopicReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::TopicReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TopicReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::TopicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::TopicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("TopicReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::TopicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TopicReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::TopicReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
TopicReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::TopicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::TopicReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
TopicReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::TopicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The TopicReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
TopicReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::TopicReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::TopicReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
TopicReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::TopicReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("TopicReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::TopicReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
TopicReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
TopicReportDataReaderImpl::TopicReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

TopicReportDataReaderImpl::~TopicReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TopicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TopicReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TopicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TopicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::TopicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::TopicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::TopicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::TopicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TopicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TopicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TopicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TopicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
TopicReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::TopicReportSeq & received_data
  )
{
  received_data.length(0);
}


void
TopicReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::TopicReport* const ptr
        = static_cast< ::OpenDDS::DCPS::TopicReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    TopicReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
TopicReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::TopicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TopicReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::TopicReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
TopicReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::TopicReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::TopicReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::TopicReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
TopicReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::TopicReport*>(data));
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::TopicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::TopicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::TopicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::TopicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
TopicReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::TopicReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::TopicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::TopicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::TopicReport))),
      OpenDDS::DCPS::TopicReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
TopicReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::TopicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::TopicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::TopicReport))),
      OpenDDS::DCPS::TopicReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
TopicReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::TopicReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::TopicReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::TopicReport))),
                           ::OpenDDS::DCPS::TopicReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::TopicReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
TopicReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::TopicReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::TopicReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
TopicReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::TopicReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TopicReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("TopicReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::TopicReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TopicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("TopicReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::TopicReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TopicReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         TopicReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    TopicReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TopicReport );
  }
}

void
TopicReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
TopicReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::TopicReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::TopicReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TopicReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::TopicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::TopicReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TopicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TopicReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
TopicReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
TopicReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
TopicReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TopicReport> : MetaStruct {
  typedef OpenDDS::DCPS::TopicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TopicReport& typed = *static_cast<const OpenDDS::DCPS::TopicReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::TopicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "topic_id", "topic_name", "type_name", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name, static_cast<const T*>(rhs)->topic_name);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name, static_cast<const T*>(rhs)->type_name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TopicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::TopicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TopicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TopicReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::PublisherReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.handle);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  gen_find_size(stru.writers, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.writers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.handle)
    && (strm >> stru.dp_id)
    && (strm >> stru.transport_id)
    && (strm >> stru.writers)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::PublisherReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::PublisherReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::PublisherReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.handle);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::PublisherReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.handle)
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::PublisherReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.handle)
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::PublisherReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
PublisherReportTypeSupportImpl::PublisherReportTypeSupportImpl ()
{
}

PublisherReportTypeSupportImpl::~PublisherReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
PublisherReportTypeSupportImpl::create_datawriter ()
{
  PublisherReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 PublisherReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
PublisherReportTypeSupportImpl::create_datareader ()
{
  PublisherReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 PublisherReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
PublisherReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<PublisherReport,
    PublisherReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
PublisherReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublisherReport>();
}

#endif

bool
PublisherReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(PublisherReport());
}


PublisherReportDataWriterImpl::PublisherReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

PublisherReportDataWriterImpl::~PublisherReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
PublisherReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::PublisherReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
PublisherReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::PublisherReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("PublisherReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
PublisherReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::PublisherReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::PublisherReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublisherReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublisherReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // PublisherReportDataWriter.
  // That the instance handle is removed from there and hence
  // PublisherReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::PublisherReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::PublisherReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("PublisherReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::PublisherReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::PublisherReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("PublisherReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::PublisherReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
PublisherReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::PublisherReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
PublisherReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::PublisherReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::PublisherReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
PublisherReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::PublisherReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublisherReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublisherReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublisherReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublisherReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The PublisherReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
PublisherReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::PublisherReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::PublisherReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
PublisherReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::PublisherReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("PublisherReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::PublisherReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
PublisherReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
PublisherReportDataReaderImpl::PublisherReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublisherReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

PublisherReportDataReaderImpl::~PublisherReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::PublisherReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::PublisherReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::PublisherReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::PublisherReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::PublisherReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::PublisherReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::PublisherReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::PublisherReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::PublisherReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::PublisherReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::PublisherReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::PublisherReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
PublisherReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data
  )
{
  received_data.length(0);
}


void
PublisherReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::PublisherReport* const ptr
        = static_cast< ::OpenDDS::DCPS::PublisherReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    PublisherReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
PublisherReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::PublisherReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
PublisherReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::PublisherReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
PublisherReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::PublisherReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::PublisherReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::PublisherReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
PublisherReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::PublisherReport*>(data));
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::PublisherReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::PublisherReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::PublisherReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::PublisherReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
PublisherReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::PublisherReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::PublisherReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::PublisherReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::PublisherReport))),
      OpenDDS::DCPS::PublisherReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
PublisherReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::PublisherReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::PublisherReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::PublisherReport))),
      OpenDDS::DCPS::PublisherReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
PublisherReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::PublisherReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::PublisherReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::PublisherReport))),
                           ::OpenDDS::DCPS::PublisherReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::PublisherReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
PublisherReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::PublisherReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::PublisherReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
PublisherReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::PublisherReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  PublisherReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublisherReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublisherReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublisherReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("PublisherReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::PublisherReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("PublisherReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("PublisherReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::PublisherReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublisherReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      PublisherReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         PublisherReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    PublisherReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  PublisherReport );
  }
}

void
PublisherReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
PublisherReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::PublisherReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::PublisherReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
PublisherReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::PublisherReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::PublisherReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublisherReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) PublisherReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) PublisherReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
PublisherReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
PublisherReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
PublisherReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::PublisherReport> : MetaStruct {
  typedef OpenDDS::DCPS::PublisherReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::PublisherReport& typed = *static_cast<const OpenDDS::DCPS::PublisherReport*>(stru);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::PublisherReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "writers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "writers") == 0) {
      return &static_cast<const T*>(stru)->writers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writers") == 0) {
      static_cast<T*>(lhs)->writers = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::PublisherReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::PublisherReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::PublisherReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::PublisherReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::SubscriberReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.handle);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  gen_find_size(stru.readers, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.readers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.handle)
    && (strm >> stru.dp_id)
    && (strm >> stru.transport_id)
    && (strm >> stru.readers)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::SubscriberReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::SubscriberReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.handle);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.handle)
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::SubscriberReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.handle)
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::SubscriberReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
SubscriberReportTypeSupportImpl::SubscriberReportTypeSupportImpl ()
{
}

SubscriberReportTypeSupportImpl::~SubscriberReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
SubscriberReportTypeSupportImpl::create_datawriter ()
{
  SubscriberReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 SubscriberReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
SubscriberReportTypeSupportImpl::create_datareader ()
{
  SubscriberReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 SubscriberReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
SubscriberReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<SubscriberReport,
    SubscriberReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
SubscriberReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriberReport>();
}

#endif

bool
SubscriberReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(SubscriberReport());
}


SubscriberReportDataWriterImpl::SubscriberReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

SubscriberReportDataWriterImpl::~SubscriberReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
SubscriberReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::SubscriberReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
SubscriberReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::SubscriberReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("SubscriberReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::SubscriberReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::SubscriberReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriberReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriberReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // SubscriberReportDataWriter.
  // That the instance handle is removed from there and hence
  // SubscriberReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("SubscriberReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("SubscriberReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::SubscriberReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
SubscriberReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
SubscriberReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::SubscriberReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::SubscriberReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::SubscriberReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriberReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriberReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriberReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriberReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The SubscriberReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
SubscriberReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::SubscriberReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::SubscriberReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
SubscriberReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::SubscriberReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("SubscriberReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::SubscriberReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
SubscriberReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
SubscriberReportDataReaderImpl::SubscriberReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriberReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

SubscriberReportDataReaderImpl::~SubscriberReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::SubscriberReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::SubscriberReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::SubscriberReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::SubscriberReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::SubscriberReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::SubscriberReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::SubscriberReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::SubscriberReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::SubscriberReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::SubscriberReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::SubscriberReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::SubscriberReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
SubscriberReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data
  )
{
  received_data.length(0);
}


void
SubscriberReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::SubscriberReport* const ptr
        = static_cast< ::OpenDDS::DCPS::SubscriberReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    SubscriberReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::SubscriberReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
SubscriberReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::SubscriberReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
SubscriberReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::SubscriberReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::SubscriberReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::SubscriberReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
SubscriberReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::SubscriberReport*>(data));
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::SubscriberReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::SubscriberReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::SubscriberReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::SubscriberReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
SubscriberReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::SubscriberReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::SubscriberReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::SubscriberReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::SubscriberReport))),
      OpenDDS::DCPS::SubscriberReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
SubscriberReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::SubscriberReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::SubscriberReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::SubscriberReport))),
      OpenDDS::DCPS::SubscriberReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
SubscriberReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::SubscriberReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::SubscriberReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::SubscriberReport))),
                           ::OpenDDS::DCPS::SubscriberReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::SubscriberReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
SubscriberReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::SubscriberReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::SubscriberReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
SubscriberReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::SubscriberReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  SubscriberReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriberReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriberReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriberReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("SubscriberReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::SubscriberReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("SubscriberReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("SubscriberReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::SubscriberReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriberReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      SubscriberReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         SubscriberReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    SubscriberReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  SubscriberReport );
  }
}

void
SubscriberReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
SubscriberReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::SubscriberReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::SubscriberReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
SubscriberReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::SubscriberReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriberReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) SubscriberReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) SubscriberReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
SubscriberReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
SubscriberReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
SubscriberReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::SubscriberReport> : MetaStruct {
  typedef OpenDDS::DCPS::SubscriberReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::SubscriberReport& typed = *static_cast<const OpenDDS::DCPS::SubscriberReport*>(stru);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::SubscriberReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "readers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "readers") == 0) {
      return &static_cast<const T*>(stru)->readers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readers") == 0) {
      static_cast<T*>(lhs)->readers = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::SubscriberReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::SubscriberReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::SubscriberReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::SubscriberReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterAssociation& typed = *static_cast<const OpenDDS::DCPS::DataWriterAssociation*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataWriterAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DWAssociations& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociations*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterAssociation*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pub_handle);
  gen_find_size(stru.dw_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  gen_find_size(stru.instances, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.pub_handle)
    && (strm << stru.dw_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.pub_handle)
    && (strm >> stru.dw_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.instances)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::DataWriterReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::DataWriterReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
DataWriterReportTypeSupportImpl::DataWriterReportTypeSupportImpl ()
{
}

DataWriterReportTypeSupportImpl::~DataWriterReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
DataWriterReportTypeSupportImpl::create_datawriter ()
{
  DataWriterReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 DataWriterReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
DataWriterReportTypeSupportImpl::create_datareader ()
{
  DataWriterReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 DataWriterReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
DataWriterReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterReport,
    DataWriterReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
DataWriterReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterReport>();
}

#endif

bool
DataWriterReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(DataWriterReport());
}


DataWriterReportDataWriterImpl::DataWriterReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

DataWriterReportDataWriterImpl::~DataWriterReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
DataWriterReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::DataWriterReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
DataWriterReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("DataWriterReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::DataWriterReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // DataWriterReportDataWriter.
  // That the instance handle is removed from there and hence
  // DataWriterReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("DataWriterReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::DataWriterReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataWriterReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
DataWriterReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::DataWriterReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataWriterReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::DataWriterReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The DataWriterReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
DataWriterReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::DataWriterReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataWriterReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
DataWriterReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::DataWriterReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("DataWriterReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::DataWriterReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
DataWriterReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
DataWriterReportDataReaderImpl::DataWriterReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

DataWriterReportDataReaderImpl::~DataWriterReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::DataWriterReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataWriterReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::DataWriterReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataWriterReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
DataWriterReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data
  )
{
  received_data.length(0);
}


void
DataWriterReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::DataWriterReport* const ptr
        = static_cast< ::OpenDDS::DCPS::DataWriterReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    DataWriterReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::DataWriterReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataWriterReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataWriterReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
DataWriterReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::DataWriterReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::DataWriterReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::DataWriterReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
DataWriterReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::DataWriterReport*>(data));
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataWriterReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataWriterReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataWriterReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataWriterReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
DataWriterReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::DataWriterReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::DataWriterReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataWriterReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataWriterReport))),
      OpenDDS::DCPS::DataWriterReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
DataWriterReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::DataWriterReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataWriterReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataWriterReport))),
      OpenDDS::DCPS::DataWriterReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
DataWriterReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::DataWriterReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::DataWriterReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::DataWriterReport))),
                           ::OpenDDS::DCPS::DataWriterReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataWriterReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
DataWriterReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::DataWriterReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataWriterReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
DataWriterReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::DataWriterReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataWriterReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("DataWriterReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::DataWriterReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("DataWriterReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::DataWriterReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         DataWriterReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    DataWriterReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataWriterReport );
  }
}

void
DataWriterReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
DataWriterReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::DataWriterReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::DataWriterReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataWriterReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::DataWriterReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
DataWriterReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
DataWriterReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
DataWriterReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterReport& typed = *static_cast<const OpenDDS::DCPS::DataWriterReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return typed.pub_handle;
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pub_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<DDS::InstanceHandleSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DWAssociations*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataWriterReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return make_field_cmp(&T::pub_handle, next);
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "pub_handle", "dw_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return &static_cast<const T*>(stru)->pub_handle;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      static_cast<T*>(lhs)->pub_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DWAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "pub_handle") == 0) {
      return static_cast<const T*>(lhs)->pub_handle == static_cast<const T*>(rhs)->pub_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sequence_number);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id)
    && (strm << stru.sequence_number);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id)
    && (strm >> stru.sequence_number);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterAssociationPeriodic T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterAssociationPeriodic& typed = *static_cast<const OpenDDS::DCPS::DataWriterAssociationPeriodic*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return typed.sequence_number;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sequence_number' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataWriterAssociationPeriodic");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return make_field_cmp(&T::sequence_number, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "sequence_number", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return &static_cast<const T*>(stru)->sequence_number;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      static_cast<T*>(lhs)->sequence_number = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sequence_number") == 0) {
      return static_cast<const T*>(lhs)->sequence_number == static_cast<const T*>(rhs)->sequence_number;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociationPeriodic>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DWAssociationsPeriodic& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterAssociationPeriodic*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.data_dropped_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.data_delivered_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.control_dropped_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.control_delivered_count);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.data_dropped_count)
    && (strm << stru.data_delivered_count)
    && (strm << stru.control_dropped_count)
    && (strm << stru.control_delivered_count)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.data_dropped_count)
    && (strm >> stru.data_delivered_count)
    && (strm >> stru.control_dropped_count)
    && (strm >> stru.control_delivered_count)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::DataWriterPeriodicReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::DataWriterPeriodicReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
DataWriterPeriodicReportTypeSupportImpl::DataWriterPeriodicReportTypeSupportImpl ()
{
}

DataWriterPeriodicReportTypeSupportImpl::~DataWriterPeriodicReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
DataWriterPeriodicReportTypeSupportImpl::create_datawriter ()
{
  DataWriterPeriodicReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 DataWriterPeriodicReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
DataWriterPeriodicReportTypeSupportImpl::create_datareader ()
{
  DataWriterPeriodicReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 DataWriterPeriodicReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
DataWriterPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterPeriodicReport,
    DataWriterPeriodicReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
DataWriterPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterPeriodicReport>();
}

#endif

bool
DataWriterPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(DataWriterPeriodicReport());
}


DataWriterPeriodicReportDataWriterImpl::DataWriterPeriodicReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

DataWriterPeriodicReportDataWriterImpl::~DataWriterPeriodicReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
DataWriterPeriodicReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
DataWriterPeriodicReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // DataWriterPeriodicReportDataWriter.
  // That the instance handle is removed from there and hence
  // DataWriterPeriodicReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::DataWriterPeriodicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataWriterPeriodicReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
DataWriterPeriodicReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::DataWriterPeriodicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::DataWriterPeriodicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The DataWriterPeriodicReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
DataWriterPeriodicReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::DataWriterPeriodicReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::DataWriterPeriodicReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("DataWriterPeriodicReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::DataWriterPeriodicReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
DataWriterPeriodicReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
DataWriterPeriodicReportDataReaderImpl::DataWriterPeriodicReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

DataWriterPeriodicReportDataReaderImpl::~DataWriterPeriodicReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterPeriodicReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::DataWriterPeriodicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::DataWriterPeriodicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataWriterPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
DataWriterPeriodicReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data
  )
{
  received_data.length(0);
}


void
DataWriterPeriodicReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::DataWriterPeriodicReport* const ptr
        = static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    DataWriterPeriodicReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::DataWriterPeriodicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataWriterPeriodicReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
DataWriterPeriodicReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::DataWriterPeriodicReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::DataWriterPeriodicReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
DataWriterPeriodicReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::DataWriterPeriodicReport*>(data));
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataWriterPeriodicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataWriterPeriodicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataWriterPeriodicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataWriterPeriodicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
DataWriterPeriodicReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::DataWriterPeriodicReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::DataWriterPeriodicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataWriterPeriodicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataWriterPeriodicReport))),
      OpenDDS::DCPS::DataWriterPeriodicReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
DataWriterPeriodicReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::DataWriterPeriodicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataWriterPeriodicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataWriterPeriodicReport))),
      OpenDDS::DCPS::DataWriterPeriodicReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
DataWriterPeriodicReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::DataWriterPeriodicReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::DataWriterPeriodicReport))),
                           ::OpenDDS::DCPS::DataWriterPeriodicReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
DataWriterPeriodicReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::DataWriterPeriodicReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
DataWriterPeriodicReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::DataWriterPeriodicReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataWriterPeriodicReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterPeriodicReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("DataWriterPeriodicReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::DataWriterPeriodicReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataWriterPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("DataWriterPeriodicReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::DataWriterPeriodicReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterPeriodicReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataWriterPeriodicReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         DataWriterPeriodicReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    DataWriterPeriodicReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataWriterPeriodicReport );
  }
}

void
DataWriterPeriodicReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
DataWriterPeriodicReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataWriterPeriodicReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataWriterPeriodicReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
DataWriterPeriodicReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
DataWriterPeriodicReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
DataWriterPeriodicReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterPeriodicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterPeriodicReport& typed = *static_cast<const OpenDDS::DCPS::DataWriterPeriodicReport*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return typed.data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return typed.data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return typed.control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return typed.control_delivered_count;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'data_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'data_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'control_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'control_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DWAssociationsPeriodic*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataWriterPeriodicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return make_field_cmp(&T::data_dropped_count, next);
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return make_field_cmp(&T::data_delivered_count, next);
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return make_field_cmp(&T::control_dropped_count, next);
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return make_field_cmp(&T::control_delivered_count, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "data_dropped_count", "data_delivered_count", "control_dropped_count", "control_delivered_count", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->control_delivered_count;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      static_cast<T*>(lhs)->data_dropped_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      static_cast<T*>(lhs)->data_delivered_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      static_cast<T*>(lhs)->control_dropped_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      static_cast<T*>(lhs)->control_delivered_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DWAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->data_dropped_count == static_cast<const T*>(rhs)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->data_delivered_count == static_cast<const T*>(rhs)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->control_dropped_count == static_cast<const T*>(rhs)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->control_delivered_count == static_cast<const T*>(rhs)->control_delivered_count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterPeriodicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.state);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.state);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.state);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderAssociation& typed = *static_cast<const OpenDDS::DCPS::DataReaderAssociation*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "state") == 0) {
      return typed.state;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "state") == 0) {
      ACE_CDR::Short val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataReaderAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "state") == 0) {
      return make_field_cmp(&T::state, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "state", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "state") == 0) {
      return &static_cast<const T*>(stru)->state;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "state") == 0) {
      static_cast<T*>(lhs)->state = *static_cast<const CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "state") == 0) {
      return static_cast<const T*>(lhs)->state == static_cast<const T*>(rhs)->state;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DRAssociations& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociations*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderAssociation*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sub_handle);
  gen_find_size(stru.dr_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  gen_find_size(stru.instances, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.sub_handle)
    && (strm << stru.dr_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.sub_handle)
    && (strm >> stru.dr_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.instances)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::DataReaderReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::DataReaderReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
DataReaderReportTypeSupportImpl::DataReaderReportTypeSupportImpl ()
{
}

DataReaderReportTypeSupportImpl::~DataReaderReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
DataReaderReportTypeSupportImpl::create_datawriter ()
{
  DataReaderReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 DataReaderReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
DataReaderReportTypeSupportImpl::create_datareader ()
{
  DataReaderReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 DataReaderReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
DataReaderReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderReport,
    DataReaderReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
DataReaderReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderReport>();
}

#endif

bool
DataReaderReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(DataReaderReport());
}


DataReaderReportDataWriterImpl::DataReaderReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

DataReaderReportDataWriterImpl::~DataReaderReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
DataReaderReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::DataReaderReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
DataReaderReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("DataReaderReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::DataReaderReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // DataReaderReportDataWriter.
  // That the instance handle is removed from there and hence
  // DataReaderReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("DataReaderReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::DataReaderReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataReaderReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
DataReaderReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::DataReaderReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataReaderReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::DataReaderReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The DataReaderReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
DataReaderReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::DataReaderReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataReaderReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
DataReaderReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::DataReaderReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("DataReaderReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::DataReaderReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
DataReaderReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
DataReaderReportDataReaderImpl::DataReaderReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

DataReaderReportDataReaderImpl::~DataReaderReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::DataReaderReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataReaderReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::DataReaderReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataReaderReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
DataReaderReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data
  )
{
  received_data.length(0);
}


void
DataReaderReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::DataReaderReport* const ptr
        = static_cast< ::OpenDDS::DCPS::DataReaderReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    DataReaderReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::DataReaderReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataReaderReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataReaderReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
DataReaderReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::DataReaderReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::DataReaderReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::DataReaderReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
DataReaderReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::DataReaderReport*>(data));
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataReaderReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataReaderReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataReaderReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataReaderReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
DataReaderReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::DataReaderReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::DataReaderReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataReaderReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataReaderReport))),
      OpenDDS::DCPS::DataReaderReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
DataReaderReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::DataReaderReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataReaderReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataReaderReport))),
      OpenDDS::DCPS::DataReaderReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
DataReaderReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::DataReaderReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::DataReaderReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::DataReaderReport))),
                           ::OpenDDS::DCPS::DataReaderReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataReaderReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
DataReaderReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::DataReaderReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataReaderReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
DataReaderReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::DataReaderReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataReaderReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("DataReaderReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::DataReaderReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("DataReaderReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::DataReaderReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         DataReaderReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    DataReaderReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataReaderReport );
  }
}

void
DataReaderReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
DataReaderReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::DataReaderReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::DataReaderReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataReaderReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::DataReaderReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
DataReaderReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
DataReaderReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
DataReaderReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderReport& typed = *static_cast<const OpenDDS::DCPS::DataReaderReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return typed.sub_handle;
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sub_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<DDS::InstanceHandleSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DRAssociations*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataReaderReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return make_field_cmp(&T::sub_handle, next);
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "sub_handle", "dr_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return &static_cast<const T*>(stru)->sub_handle;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      static_cast<T*>(lhs)->sub_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DRAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sub_handle") == 0) {
      return static_cast<const T*>(lhs)->sub_handle == static_cast<const T*>(rhs)->sub_handle;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.samples_available);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.samples_available);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.samples_available);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderAssociationPeriodic T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderAssociationPeriodic& typed = *static_cast<const OpenDDS::DCPS::DataReaderAssociationPeriodic*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return typed.samples_available;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "samples_available") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'samples_available' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataReaderAssociationPeriodic");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return make_field_cmp(&T::samples_available, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "samples_available", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return &static_cast<const T*>(stru)->samples_available;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      static_cast<T*>(lhs)->samples_available = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "samples_available") == 0) {
      return static_cast<const T*>(lhs)->samples_available == static_cast<const T*>(rhs)->samples_available;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociationPeriodic>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DRAssociationsPeriodic& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderAssociationPeriodic*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::DataReaderPeriodicReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKind));
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::DataReaderPeriodicReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
DataReaderPeriodicReportTypeSupportImpl::DataReaderPeriodicReportTypeSupportImpl ()
{
}

DataReaderPeriodicReportTypeSupportImpl::~DataReaderPeriodicReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
DataReaderPeriodicReportTypeSupportImpl::create_datawriter ()
{
  DataReaderPeriodicReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 DataReaderPeriodicReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
DataReaderPeriodicReportTypeSupportImpl::create_datareader ()
{
  DataReaderPeriodicReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 DataReaderPeriodicReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
DataReaderPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderPeriodicReport,
    DataReaderPeriodicReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
DataReaderPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderPeriodicReport>();
}

#endif

bool
DataReaderPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(DataReaderPeriodicReport());
}


DataReaderPeriodicReportDataWriterImpl::DataReaderPeriodicReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

DataReaderPeriodicReportDataWriterImpl::~DataReaderPeriodicReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
DataReaderPeriodicReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
DataReaderPeriodicReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // DataReaderPeriodicReportDataWriter.
  // That the instance handle is removed from there and hence
  // DataReaderPeriodicReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::DataReaderPeriodicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataReaderPeriodicReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
DataReaderPeriodicReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::DataReaderPeriodicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::DataReaderPeriodicReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The DataReaderPeriodicReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
DataReaderPeriodicReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::DataReaderPeriodicReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::DataReaderPeriodicReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("DataReaderPeriodicReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::DataReaderPeriodicReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
DataReaderPeriodicReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
DataReaderPeriodicReportDataReaderImpl::DataReaderPeriodicReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

DataReaderPeriodicReportDataReaderImpl::~DataReaderPeriodicReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderPeriodicReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::DataReaderPeriodicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::DataReaderPeriodicReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::DataReaderPeriodicReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
DataReaderPeriodicReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data
  )
{
  received_data.length(0);
}


void
DataReaderPeriodicReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::DataReaderPeriodicReport* const ptr
        = static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    DataReaderPeriodicReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::DataReaderPeriodicReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
DataReaderPeriodicReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
DataReaderPeriodicReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::DataReaderPeriodicReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::DataReaderPeriodicReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
DataReaderPeriodicReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::DataReaderPeriodicReport*>(data));
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataReaderPeriodicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataReaderPeriodicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::DataReaderPeriodicReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::DataReaderPeriodicReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
DataReaderPeriodicReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::DataReaderPeriodicReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::DataReaderPeriodicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataReaderPeriodicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataReaderPeriodicReport))),
      OpenDDS::DCPS::DataReaderPeriodicReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
DataReaderPeriodicReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::DataReaderPeriodicReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::DataReaderPeriodicReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::DataReaderPeriodicReport))),
      OpenDDS::DCPS::DataReaderPeriodicReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
DataReaderPeriodicReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::DataReaderPeriodicReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::DataReaderPeriodicReport))),
                           ::OpenDDS::DCPS::DataReaderPeriodicReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
DataReaderPeriodicReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::DataReaderPeriodicReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
DataReaderPeriodicReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::DataReaderPeriodicReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataReaderPeriodicReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderPeriodicReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("DataReaderPeriodicReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::DataReaderPeriodicReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("DataReaderPeriodicReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("DataReaderPeriodicReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::DataReaderPeriodicReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderPeriodicReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      DataReaderPeriodicReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         DataReaderPeriodicReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    DataReaderPeriodicReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  DataReaderPeriodicReport );
  }
}

void
DataReaderPeriodicReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
DataReaderPeriodicReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
DataReaderPeriodicReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) DataReaderPeriodicReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
DataReaderPeriodicReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
DataReaderPeriodicReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
DataReaderPeriodicReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderPeriodicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderPeriodicReport& typed = *static_cast<const OpenDDS::DCPS::DataReaderPeriodicReport*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DRAssociationsPeriodic*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::DataReaderPeriodicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DRAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderPeriodicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.transport_type) + 1;
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host)
    && (strm << stru.pid)
    && (strm << stru.transport_id)
    && (strm << stru.transport_type)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.transport_id)
    && (strm >> stru.transport_type.out())
    && (strm >> stru.values);
}

bool gen_is_bounded_size(const OpenDDS::DCPS::TransportReport&)
{
  return false;
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::TransportReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::TransportReport>)
{
  return false;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.host) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.pid);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.transport_id);
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TransportReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.host)
    && (strm << stru.t.pid)
    && (strm << stru.t.transport_id);
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TransportReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.host.out())
    && (strm >> stru.t.pid)
    && (strm >> stru.t.transport_id);
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const OpenDDS::DCPS::TransportReport&)
{
  return true;
}

}  }

namespace OpenDDS {
namespace DCPS {
TransportReportTypeSupportImpl::TransportReportTypeSupportImpl ()
{
}

TransportReportTypeSupportImpl::~TransportReportTypeSupportImpl ()
{
}

::DDS::DataWriter_ptr
TransportReportTypeSupportImpl::create_datawriter ()
{
  TransportReportDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 TransportReportDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
TransportReportTypeSupportImpl::create_datareader ()
{
  TransportReportDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 TransportReportDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
TransportReportTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<TransportReport,
    TransportReportDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
TransportReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TransportReport>();
}

#endif

bool
TransportReportTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(TransportReport());
}


TransportReportDataWriterImpl::TransportReportDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

TransportReportDataWriterImpl::~TransportReportDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
}

::DDS::InstanceHandle_t
TransportReportDataWriterImpl::register_instance (
    const ::OpenDDS::DCPS::TransportReport & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
TransportReportDataWriterImpl::register_instance_w_timestamp (
    const ::OpenDDS::DCPS::TransportReport & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("TransportReportDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
TransportReportDataWriterImpl::unregister_instance (
    const ::OpenDDS::DCPS::TransportReport & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::unregister_instance_w_timestamp (
    const ::OpenDDS::DCPS::TransportReport & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TransportReportDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TransportReportDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // TransportReportDataWriter.
  // That the instance handle is removed from there and hence
  // TransportReportDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::write (
    const ::OpenDDS::DCPS::TransportReport & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::write_w_timestamp (
    const ::OpenDDS::DCPS::TransportReport & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  if (handle == ::DDS::HANDLE_NIL) {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
        = this->get_or_create_instance_handle(registered_handle,
                                              instance_data,
                                              source_timestamp);
    if (ret != ::DDS::RETCODE_OK) {
      ACE_ERROR_RETURN((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("TransportReportDataWriterImpl::write, ")
                        ACE_TEXT("register failed err=%d.\n"),
                        ret),
                       ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, ::DDS::RETCODE_ERROR);
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::dispose (
    const ::OpenDDS::DCPS::TransportReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::dispose_w_timestamp (
    const ::OpenDDS::DCPS::TransportReport & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("TransportReportDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::get_key_value (
    ::OpenDDS::DCPS::TransportReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TransportReportDataWriterImpl::lookup_instance (
    const ::OpenDDS::DCPS::TransportReport & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
TransportReportDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::OpenDDS::DCPS::TransportReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::TransportReport > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
TransportReportDataWriterImpl::enable_specific ()
{
  ::OpenDDS::DCPS::TransportReport data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TransportReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TransportReportDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TransportReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TransportReportDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  return ::DDS::RETCODE_OK;
}

// Note: The TransportReportDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
TransportReportDataWriterImpl::dds_marshal(
  const ::OpenDDS::DCPS::TransportReport& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::OpenDDS::DCPS::TransportReport > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size,
                                         ACE_Message_Block::MB_DATA,
                                         0, //cont
                                         0, //data
                                         0, //alloc_strategy
                                         get_db_lock()), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              get_db_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
TransportReportDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::OpenDDS::DCPS::TransportReport& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
                   guard,
                   get_lock(),
                   ::DDS::RETCODE_ERROR);

  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("TransportReportDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert OpenDDS::DCPS::TransportReport failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)

    send_all_to_flush_control(guard);

  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
TransportReportDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
TransportReportDataReaderImpl::TransportReportDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TransportReportDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

TransportReportDataReaderImpl::~TransportReportDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TransportReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TransportReportSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TransportReportSeq::PrivateMemberAccess received_data_p(received_data);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TransportReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_w_condition (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_w_condition (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_next_sample (
    ::OpenDDS::DCPS::TransportReport & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::TransportReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_next_sample (
    ::OpenDDS::DCPS::TransportReport & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::OpenDDS::DCPS::TransportReport *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_instance (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_instance_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TransportReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TransportReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_instance (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_instance_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::OpenDDS::DCPS::TransportReportSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::OpenDDS::DCPS::TransportReportSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_next_instance (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_next_instance_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_next_instance (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_next_instance_i (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_next_instance_w_condition (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take_next_instance_w_condition (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
TransportReportDataReaderImpl::release_loan (
    ::OpenDDS::DCPS::TransportReportSeq & received_data
  )
{
  received_data.length(0);
}


void
TransportReportDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::OpenDDS::DCPS::TransportReport* const ptr
        = static_cast< ::OpenDDS::DCPS::TransportReport* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    TransportReport );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
TransportReportDataReaderImpl::return_loan (
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::get_key_value (
    ::OpenDDS::DCPS::TransportReport & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
TransportReportDataReaderImpl::lookup_instance (
    const ::OpenDDS::DCPS::TransportReport & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
TransportReportDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::OpenDDS::DCPS::TransportReport* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states,
  bool adjust_ref_count)
{

  OpenDDS::DCPS::TransportReportSeq data;
  ::DDS::ReturnCode_t rc;
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  {
      rc = read_i(data, gen.info_,
      	::DDS::LENGTH_UNLIMITED,
        sample_states, view_states, instance_states, 0);
      if (true == adjust_ref_count ) {
        data.increment_references();
      }
  }
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;

}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::take(
  OpenDDS::DCPS::AbstractSamples& samples,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);


  OpenDDS::DCPS::TransportReportSeq data;
  ::DDS::SampleInfoSeq infos;
  ::DDS::ReturnCode_t rc = take_i(data, infos, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);

  samples.reserve(data.length());

  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    samples.push_back(infos[i], &data[i]);
  }

  return rc;
}

::DDS::InstanceHandle_t
TransportReportDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const OpenDDS::DCPS::TransportReport*>(data));
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::TransportReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::TransportReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  OpenDDS::DCPS::TransportReportSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new OpenDDS::DCPS::TransportReport(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
TransportReportDataReaderImpl::store_synthetic_data(const OpenDDS::DCPS::TransportReport& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    OpenDDS::DCPS::TransportReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::TransportReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::TransportReport))),
      OpenDDS::DCPS::TransportReport(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
TransportReportDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    OpenDDS::DCPS::TransportReport* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< OpenDDS::DCPS::TransportReport*>(data_allocator_->malloc(sizeof(OpenDDS::DCPS::TransportReport))),
      OpenDDS::DCPS::TransportReport);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
TransportReportDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::OpenDDS::DCPS::TransportReport* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::OpenDDS::DCPS::TransportReport *>(
                            data_allocator_->malloc(sizeof(::OpenDDS::DCPS::TransportReport))),
                           ::OpenDDS::DCPS::TransportReport);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::TransportReport>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
TransportReportDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::OpenDDS::DCPS::TransportReport data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::OpenDDS::DCPS::TransportReport>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
TransportReportDataReaderImpl::store_instance_data(
    ::OpenDDS::DCPS::TransportReport *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  const bool is_dispose_msg =
    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
  const bool is_unregister_msg =
    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TransportReport );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    std::size_t instances_size = 0;
    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      instances_size = instances_.size();
    }
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TransportReport );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TransportReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->instances_lock_,
                                                 handle));

    instance->instance_handle_ = handle;

    { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

      if (ret != 0)
      {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TransportReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("insert handle failed. \n")));
        return;
      }
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("TransportReportDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::OpenDDS::DCPS::TransportReport failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("TransportReportDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("TransportReportDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::OpenDDS::DCPS::TransportReport failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TransportReport );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition_no_sample_lock();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      TransportReport );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      { ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
        for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
             iter != instances_.end();
             ++iter) {
          OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

          total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        }
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition_no_sample_lock();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         TransportReport );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    TransportReport );
      instance_data = 0;
    }

    bool event_notify = false;

    if (is_dispose_msg) {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
    }

    if (is_unregister_msg) {
      if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
        event_notify = true;
      }
    }

    if (!is_dispose_msg && !is_unregister_msg) {
      event_notify = true;
      instance_ptr->instance_state_.data_was_received(header.publication_id_);
    }

    if (!event_notify) {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition_no_sample_lock();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(sub);
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition_no_sample_lock();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  TransportReport );
  }
}

void
TransportReportDataReaderImpl::notify_status_condition_no_sample_lock()
{
  // This member function avoids a deadlock condition which otherwise
  // could occur as follows:
  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
  // eventually DataReaderImpl::sample_lock_ to lock in call to
  // DataReaderImpl::contains_samples().
  // Thread2: Call to DataReaderImpl::data_received()
  // causes DataReaderImpl::sample_lock_ to lock and eventually
  // during notify of status condition a call to WaitSet::signal()
  // causes WaitSet::lock_ to lock.
  // Because the DataReaderImpl::sample_lock_ is not needed during
  // status notification this member function is used in
  // store_instance_data() to release sample_lock_ before making
  // the notification.
  ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
  notify_status_condition();
}

void
TransportReportDataReaderImpl::dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                           OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::auto_return_loan(void* seq)
{
  ::OpenDDS::DCPS::TransportReportSeq& received_data =
    *static_cast< ::OpenDDS::DCPS::TransportReportSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
TransportReportDataReaderImpl::check_inputs (
    const char* method_name,
    ::OpenDDS::DCPS::TransportReportSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::OpenDDS::DCPS::TransportReportSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TransportReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) TransportReportDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) TransportReportDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
TransportReportDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
TransportReportDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
TransportReportDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TransportReport> : MetaStruct {
  typedef OpenDDS::DCPS::TransportReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TransportReport& typed = *static_cast<const OpenDDS::DCPS::TransportReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "transport_type") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::TransportReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "transport_id", "transport_type", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host, static_cast<const T*>(rhs)->host);
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type, static_cast<const T*>(rhs)->transport_type);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::TransportReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TransportReport>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::ReportType>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ReportType_names[] = {
  "SERVICE_PARTICIPANT_REPORT_TYPE",
  "DOMAIN_PARTICIPANT_REPORT_TYPE",
  "TOPIC_REPORT_TYPE",
  "PUBLISHER_REPORT_TYPE",
  "SUBSCRIBER_REPORT_TYPE",
  "DATA_WRITER_REPORT_TYPE",
  "DATA_WRITER_PERIODIC_REPORT_TYPE",
  "DATA_READER_REPORT_TYPE",
  "DATA_READER_PERIODIC_REPORT_TYPE",
  "TRANSPORT_REPORT_TYPE"
};
}  }

#endif

/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::GenericReport& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      gen_find_size(uni.sp_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      gen_find_size(uni.dp_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      gen_find_size(uni.topic_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      gen_find_size(uni.publisher_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      gen_find_size(uni.subscriber_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      gen_find_size(uni.dw_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      gen_find_size(uni.dw_per_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      gen_find_size(uni.dr_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      gen_find_size(uni.dr_per_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      gen_find_size(uni.transport_report(), size, padding);
      break;
    }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      return (strm << uni.sp_report());
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      return (strm << uni.dp_report());
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      return (strm << uni.topic_report());
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      return (strm << uni.publisher_report());
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      return (strm << uni.subscriber_report());
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      return (strm << uni.dw_report());
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      return (strm << uni.dw_per_report());
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      return (strm << uni.dr_report());
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      return (strm << uni.dr_per_report());
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      return (strm << uni.transport_report());
    }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  OpenDDS::DCPS::ReportType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      OpenDDS::DCPS::ServiceParticipantReport tmp;
      if (strm >> tmp) {
        uni.sp_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      OpenDDS::DCPS::DomainParticipantReport tmp;
      if (strm >> tmp) {
        uni.dp_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::TopicReport tmp;
      if (strm >> tmp) {
        uni.topic_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      OpenDDS::DCPS::PublisherReport tmp;
      if (strm >> tmp) {
        uni.publisher_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      OpenDDS::DCPS::SubscriberReport tmp;
      if (strm >> tmp) {
        uni.subscriber_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataWriterReport tmp;
      if (strm >> tmp) {
        uni.dw_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataWriterPeriodicReport tmp;
      if (strm >> tmp) {
        uni.dw_per_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataReaderReport tmp;
      if (strm >> tmp) {
        uni.dr_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataReaderPeriodicReport tmp;
      if (strm >> tmp) {
        uni.dr_per_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      OpenDDS::DCPS::TransportReport tmp;
      if (strm >> tmp) {
        uni.transport_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::GenericReport*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::DCPS::ReportType disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::ServiceParticipantReport*>(0));
    break;
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DomainParticipantReport*>(0));
    break;
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TopicReport*>(0));
    break;
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::PublisherReport*>(0));
    break;
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::SubscriberReport*>(0));
    break;
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterReport*>(0));
    break;
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterPeriodicReport*>(0));
    break;
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderReport*>(0));
    break;
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderPeriodicReport*>(0));
    break;
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportReport*>(0));
    break;
  default:
    break;
  }
}

}  }

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
