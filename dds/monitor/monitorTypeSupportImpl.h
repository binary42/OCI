/* -*- C++ -*- */
/* Generated by ../../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file monitor.idl*/
#ifndef OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_MOS7OL
#define OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_MOS7OL
#include "dds/DCPS/Definitions.h"
#include "monitorC.h"
#include "dds/DCPS/DataReaderImpl.h"
#include "dds/DCPS/DataWriterImpl.h"
#include "dds/DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/SubscriptionInstance.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DdsDcpsGuidC.h"
#include "dds/DdsDcpsInfrastructureC.h"
#include "monitorTypeSupportC.h"
#include "tao/ULongSeqC.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::Statistics& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::Statistics& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::Statistics>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::Statistics*);

}  }

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueEnumType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueEnumType& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_OpenDDS_DCPS_ValueEnumType_names[];
}  }

#endif

/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::ValueUnion& uni, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueUnion& uni);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ValueUnion*);

}  }

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::NameValuePair& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::NameValuePair& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::NameValuePair>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NameValuePair*);

}  }

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::NVPSeq& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::NVPSeq& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::NVPSeq& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NVPSeq*);

}  }

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::ServiceParticipantReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::ServiceParticipantReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::ServiceParticipantReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export ServiceParticipantReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::ServiceParticipantReport& v1, const OpenDDS::DCPS::ServiceParticipantReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class ServiceParticipantReportDataWriterImpl;
class ServiceParticipantReportDataReaderImpl;

/** Servant for TypeSupport interface of ServiceParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export ServiceParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ServiceParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef ServiceParticipantReport                message_type;
  typedef ServiceParticipantReport_var            message_var;
  typedef ServiceParticipantReportTypeSupport     typesupport_type;
  typedef ServiceParticipantReportTypeSupport_var typesupport_var;
  typedef ServiceParticipantReportDataWriter      datawriter_type;
  typedef ServiceParticipantReportDataReader      datareader_type;
  typedef ServiceParticipantReportDataWriter_var  datawriter_var;
  typedef ServiceParticipantReportDataReader_var  datareader_var;
  typedef ServiceParticipantReportDataWriterImpl  datawriterimpl_type;
  typedef ServiceParticipantReportDataReaderImpl  datareaderimpl_type;

  ServiceParticipantReportTypeSupportImpl();
  virtual ~ServiceParticipantReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef ServiceParticipantReportTypeSupport::_ptr_type _ptr_type;
  typedef ServiceParticipantReportTypeSupport::_var_type _var_type;
  typedef ServiceParticipantReportDataWriter data_writer_type;
  typedef ServiceParticipantReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::ServiceParticipantReport data_sample_type;
  typedef ::OpenDDS::DCPS::ServiceParticipantReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return ServiceParticipantReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the ServiceParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export ServiceParticipantReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<ServiceParticipantReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef ServiceParticipantReport                message_type;
  typedef ServiceParticipantReportTypeSupportImpl typesupportimpl_type;
  typedef ServiceParticipantReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::ServiceParticipantReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ServiceParticipantReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  ServiceParticipantReportDataWriterImpl (void);

  /// Destructor
  virtual ~ServiceParticipantReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::ServiceParticipantReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::ServiceParticipantReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::ServiceParticipantReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of ServiceParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export ServiceParticipantReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<ServiceParticipantReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef ServiceParticipantReport                message_type;
  typedef ServiceParticipantReportTypeSupportImpl typesupportimpl_type;
  typedef ServiceParticipantReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::ServiceParticipantReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::ServiceParticipantReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::ServiceParticipantReport, ACE_Null_Mutex>  DataAllocator;
  typedef ServiceParticipantReportDataReader Interface;

  /// Constructor
  ServiceParticipantReportDataReaderImpl (void);

  /// Destructor
  virtual ~ServiceParticipantReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::ServiceParticipantReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::ServiceParticipantReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::ServiceParticipantReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::ServiceParticipantReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::ServiceParticipantReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::ServiceParticipantReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::ServiceParticipantReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ServiceParticipantReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ServiceParticipantReport*);

}  }

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DomainParticipantReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::DomainParticipantReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DomainParticipantReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DomainParticipantReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::DomainParticipantReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DomainParticipantReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DomainParticipantReport& v1, const OpenDDS::DCPS::DomainParticipantReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class DomainParticipantReportDataWriterImpl;
class DomainParticipantReportDataReaderImpl;

/** Servant for TypeSupport interface of DomainParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DomainParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DomainParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef DomainParticipantReport                message_type;
  typedef DomainParticipantReport_var            message_var;
  typedef DomainParticipantReportTypeSupport     typesupport_type;
  typedef DomainParticipantReportTypeSupport_var typesupport_var;
  typedef DomainParticipantReportDataWriter      datawriter_type;
  typedef DomainParticipantReportDataReader      datareader_type;
  typedef DomainParticipantReportDataWriter_var  datawriter_var;
  typedef DomainParticipantReportDataReader_var  datareader_var;
  typedef DomainParticipantReportDataWriterImpl  datawriterimpl_type;
  typedef DomainParticipantReportDataReaderImpl  datareaderimpl_type;

  DomainParticipantReportTypeSupportImpl();
  virtual ~DomainParticipantReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef DomainParticipantReportTypeSupport::_ptr_type _ptr_type;
  typedef DomainParticipantReportTypeSupport::_var_type _var_type;
  typedef DomainParticipantReportDataWriter data_writer_type;
  typedef DomainParticipantReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::DomainParticipantReport data_sample_type;
  typedef ::OpenDDS::DCPS::DomainParticipantReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return DomainParticipantReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the DomainParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export DomainParticipantReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<DomainParticipantReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef DomainParticipantReport                message_type;
  typedef DomainParticipantReportTypeSupportImpl typesupportimpl_type;
  typedef DomainParticipantReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::DomainParticipantReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DomainParticipantReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  DomainParticipantReportDataWriterImpl (void);

  /// Destructor
  virtual ~DomainParticipantReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DomainParticipantReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::DomainParticipantReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::DomainParticipantReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of DomainParticipantReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DomainParticipantReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<DomainParticipantReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef DomainParticipantReport                message_type;
  typedef DomainParticipantReportTypeSupportImpl typesupportimpl_type;
  typedef DomainParticipantReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::DomainParticipantReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DomainParticipantReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::DomainParticipantReport, ACE_Null_Mutex>  DataAllocator;
  typedef DomainParticipantReportDataReader Interface;

  /// Constructor
  DomainParticipantReportDataReaderImpl (void);

  /// Destructor
  virtual ~DomainParticipantReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::DomainParticipantReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::DomainParticipantReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DomainParticipantReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DomainParticipantReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::DomainParticipantReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::DomainParticipantReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::DomainParticipantReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::DomainParticipantReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DomainParticipantReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DomainParticipantReport*);

}  }

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::TopicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::TopicReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::TopicReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::TopicReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TopicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TopicReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::TopicReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export TopicReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::TopicReport& v1, const OpenDDS::DCPS::TopicReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.topic_id.guidPrefix[11] < v2.topic_id.guidPrefix[11]) return true;
    if (v2.topic_id.guidPrefix[11] < v1.topic_id.guidPrefix[11]) return false;
    if (v1.topic_id.guidPrefix[10] < v2.topic_id.guidPrefix[10]) return true;
    if (v2.topic_id.guidPrefix[10] < v1.topic_id.guidPrefix[10]) return false;
    if (v1.topic_id.guidPrefix[ 9] < v2.topic_id.guidPrefix[ 9]) return true;
    if (v2.topic_id.guidPrefix[ 9] < v1.topic_id.guidPrefix[ 9]) return false;
    if (v1.topic_id.guidPrefix[ 8] < v2.topic_id.guidPrefix[ 8]) return true;
    if (v2.topic_id.guidPrefix[ 8] < v1.topic_id.guidPrefix[ 8]) return false;
    if (v1.topic_id.guidPrefix[ 7] < v2.topic_id.guidPrefix[ 7]) return true;
    if (v2.topic_id.guidPrefix[ 7] < v1.topic_id.guidPrefix[ 7]) return false;
    if (v1.topic_id.guidPrefix[ 6] < v2.topic_id.guidPrefix[ 6]) return true;
    if (v2.topic_id.guidPrefix[ 6] < v1.topic_id.guidPrefix[ 6]) return false;
    if (v1.topic_id.guidPrefix[ 5] < v2.topic_id.guidPrefix[ 5]) return true;
    if (v2.topic_id.guidPrefix[ 5] < v1.topic_id.guidPrefix[ 5]) return false;
    if (v1.topic_id.guidPrefix[ 4] < v2.topic_id.guidPrefix[ 4]) return true;
    if (v2.topic_id.guidPrefix[ 4] < v1.topic_id.guidPrefix[ 4]) return false;
    if (v1.topic_id.guidPrefix[ 3] < v2.topic_id.guidPrefix[ 3]) return true;
    if (v2.topic_id.guidPrefix[ 3] < v1.topic_id.guidPrefix[ 3]) return false;
    if (v1.topic_id.guidPrefix[ 2] < v2.topic_id.guidPrefix[ 2]) return true;
    if (v2.topic_id.guidPrefix[ 2] < v1.topic_id.guidPrefix[ 2]) return false;
    if (v1.topic_id.guidPrefix[ 1] < v2.topic_id.guidPrefix[ 1]) return true;
    if (v2.topic_id.guidPrefix[ 1] < v1.topic_id.guidPrefix[ 1]) return false;
    if (v1.topic_id.guidPrefix[ 0] < v2.topic_id.guidPrefix[ 0]) return true;
    if (v2.topic_id.guidPrefix[ 0] < v1.topic_id.guidPrefix[ 0]) return false;
    if (v1.topic_id.entityId.entityKey[2] < v2.topic_id.entityId.entityKey[2]) return true;
    if (v2.topic_id.entityId.entityKey[2] < v1.topic_id.entityId.entityKey[2]) return false;
    if (v1.topic_id.entityId.entityKey[1] < v2.topic_id.entityId.entityKey[1]) return true;
    if (v2.topic_id.entityId.entityKey[1] < v1.topic_id.entityId.entityKey[1]) return false;
    if (v1.topic_id.entityId.entityKey[0] < v2.topic_id.entityId.entityKey[0]) return true;
    if (v2.topic_id.entityId.entityKey[0] < v1.topic_id.entityId.entityKey[0]) return false;
    if (v1.topic_id.entityId.entityKind < v2.topic_id.entityId.entityKind) return true;
    if (v2.topic_id.entityId.entityKind < v1.topic_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class TopicReportDataWriterImpl;
class TopicReportDataReaderImpl;

/** Servant for TypeSupport interface of TopicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export TopicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef TopicReport                message_type;
  typedef TopicReport_var            message_var;
  typedef TopicReportTypeSupport     typesupport_type;
  typedef TopicReportTypeSupport_var typesupport_var;
  typedef TopicReportDataWriter      datawriter_type;
  typedef TopicReportDataReader      datareader_type;
  typedef TopicReportDataWriter_var  datawriter_var;
  typedef TopicReportDataReader_var  datareader_var;
  typedef TopicReportDataWriterImpl  datawriterimpl_type;
  typedef TopicReportDataReaderImpl  datareaderimpl_type;

  TopicReportTypeSupportImpl();
  virtual ~TopicReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef TopicReportTypeSupport::_ptr_type _ptr_type;
  typedef TopicReportTypeSupport::_var_type _var_type;
  typedef TopicReportDataWriter data_writer_type;
  typedef TopicReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::TopicReport data_sample_type;
  typedef ::OpenDDS::DCPS::TopicReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return TopicReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the TopicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export TopicReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef TopicReport                message_type;
  typedef TopicReportTypeSupportImpl typesupportimpl_type;
  typedef TopicReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::TopicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  TopicReportDataWriterImpl (void);

  /// Destructor
  virtual ~TopicReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::TopicReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::TopicReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::TopicReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::TopicReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::TopicReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::TopicReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::TopicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::TopicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::TopicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::TopicReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::TopicReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::TopicReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of TopicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export TopicReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef TopicReport                message_type;
  typedef TopicReportTypeSupportImpl typesupportimpl_type;
  typedef TopicReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::TopicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TopicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::TopicReport, ACE_Null_Mutex>  DataAllocator;
  typedef TopicReportDataReader Interface;

  /// Constructor
  TopicReportDataReaderImpl (void);

  /// Destructor
  virtual ~TopicReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::TopicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::TopicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::TopicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::TopicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::TopicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::TopicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::TopicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::TopicReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::TopicReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::TopicReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::TopicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::TopicReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::TopicReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TopicReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TopicReport*);

}  }

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::PublisherReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::PublisherReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::PublisherReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::PublisherReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::PublisherReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::PublisherReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::PublisherReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export PublisherReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::PublisherReport& v1, const OpenDDS::DCPS::PublisherReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class PublisherReportDataWriterImpl;
class PublisherReportDataReaderImpl;

/** Servant for TypeSupport interface of PublisherReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export PublisherReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublisherReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef PublisherReport                message_type;
  typedef PublisherReport_var            message_var;
  typedef PublisherReportTypeSupport     typesupport_type;
  typedef PublisherReportTypeSupport_var typesupport_var;
  typedef PublisherReportDataWriter      datawriter_type;
  typedef PublisherReportDataReader      datareader_type;
  typedef PublisherReportDataWriter_var  datawriter_var;
  typedef PublisherReportDataReader_var  datareader_var;
  typedef PublisherReportDataWriterImpl  datawriterimpl_type;
  typedef PublisherReportDataReaderImpl  datareaderimpl_type;

  PublisherReportTypeSupportImpl();
  virtual ~PublisherReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef PublisherReportTypeSupport::_ptr_type _ptr_type;
  typedef PublisherReportTypeSupport::_var_type _var_type;
  typedef PublisherReportDataWriter data_writer_type;
  typedef PublisherReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::PublisherReport data_sample_type;
  typedef ::OpenDDS::DCPS::PublisherReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return PublisherReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the PublisherReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export PublisherReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublisherReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef PublisherReport                message_type;
  typedef PublisherReportTypeSupportImpl typesupportimpl_type;
  typedef PublisherReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::PublisherReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublisherReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  PublisherReportDataWriterImpl (void);

  /// Destructor
  virtual ~PublisherReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::PublisherReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::PublisherReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::PublisherReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::PublisherReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::PublisherReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::PublisherReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::PublisherReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::PublisherReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::PublisherReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::PublisherReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::PublisherReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::PublisherReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of PublisherReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export PublisherReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublisherReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef PublisherReport                message_type;
  typedef PublisherReportTypeSupportImpl typesupportimpl_type;
  typedef PublisherReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::PublisherReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::PublisherReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::PublisherReport, ACE_Null_Mutex>  DataAllocator;
  typedef PublisherReportDataReader Interface;

  /// Constructor
  PublisherReportDataReaderImpl (void);

  /// Destructor
  virtual ~PublisherReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::PublisherReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::PublisherReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::PublisherReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::PublisherReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::PublisherReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::PublisherReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::PublisherReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::PublisherReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::PublisherReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::PublisherReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::PublisherReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::PublisherReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::PublisherReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::PublisherReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::PublisherReport*);

}  }

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::SubscriberReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::SubscriberReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::SubscriberReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::SubscriberReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::SubscriberReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export SubscriberReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::SubscriberReport& v1, const OpenDDS::DCPS::SubscriberReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class SubscriberReportDataWriterImpl;
class SubscriberReportDataReaderImpl;

/** Servant for TypeSupport interface of SubscriberReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export SubscriberReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriberReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef SubscriberReport                message_type;
  typedef SubscriberReport_var            message_var;
  typedef SubscriberReportTypeSupport     typesupport_type;
  typedef SubscriberReportTypeSupport_var typesupport_var;
  typedef SubscriberReportDataWriter      datawriter_type;
  typedef SubscriberReportDataReader      datareader_type;
  typedef SubscriberReportDataWriter_var  datawriter_var;
  typedef SubscriberReportDataReader_var  datareader_var;
  typedef SubscriberReportDataWriterImpl  datawriterimpl_type;
  typedef SubscriberReportDataReaderImpl  datareaderimpl_type;

  SubscriberReportTypeSupportImpl();
  virtual ~SubscriberReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef SubscriberReportTypeSupport::_ptr_type _ptr_type;
  typedef SubscriberReportTypeSupport::_var_type _var_type;
  typedef SubscriberReportDataWriter data_writer_type;
  typedef SubscriberReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::SubscriberReport data_sample_type;
  typedef ::OpenDDS::DCPS::SubscriberReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return SubscriberReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the SubscriberReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export SubscriberReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriberReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef SubscriberReport                message_type;
  typedef SubscriberReportTypeSupportImpl typesupportimpl_type;
  typedef SubscriberReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::SubscriberReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriberReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  SubscriberReportDataWriterImpl (void);

  /// Destructor
  virtual ~SubscriberReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::SubscriberReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::SubscriberReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::SubscriberReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::SubscriberReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::SubscriberReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::SubscriberReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::SubscriberReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of SubscriberReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export SubscriberReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriberReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef SubscriberReport                message_type;
  typedef SubscriberReportTypeSupportImpl typesupportimpl_type;
  typedef SubscriberReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::SubscriberReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::SubscriberReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::SubscriberReport, ACE_Null_Mutex>  DataAllocator;
  typedef SubscriberReportDataReader Interface;

  /// Constructor
  SubscriberReportDataReaderImpl (void);

  /// Destructor
  virtual ~SubscriberReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::SubscriberReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::SubscriberReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::SubscriberReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::SubscriberReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::SubscriberReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::SubscriberReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::SubscriberReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::SubscriberReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::SubscriberReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::SubscriberReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::SubscriberReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::SubscriberReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::SubscriberReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::SubscriberReport*);

}  }

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterAssociation& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociation& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociation>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociation*);

}  }

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DWAssociations& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociations& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociations*);

}  }

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::DataWriterReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::DataWriterReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataWriterReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataWriterReport& v1, const OpenDDS::DCPS::DataWriterReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[ 9] < v2.dw_id.guidPrefix[ 9]) return true;
    if (v2.dw_id.guidPrefix[ 9] < v1.dw_id.guidPrefix[ 9]) return false;
    if (v1.dw_id.guidPrefix[ 8] < v2.dw_id.guidPrefix[ 8]) return true;
    if (v2.dw_id.guidPrefix[ 8] < v1.dw_id.guidPrefix[ 8]) return false;
    if (v1.dw_id.guidPrefix[ 7] < v2.dw_id.guidPrefix[ 7]) return true;
    if (v2.dw_id.guidPrefix[ 7] < v1.dw_id.guidPrefix[ 7]) return false;
    if (v1.dw_id.guidPrefix[ 6] < v2.dw_id.guidPrefix[ 6]) return true;
    if (v2.dw_id.guidPrefix[ 6] < v1.dw_id.guidPrefix[ 6]) return false;
    if (v1.dw_id.guidPrefix[ 5] < v2.dw_id.guidPrefix[ 5]) return true;
    if (v2.dw_id.guidPrefix[ 5] < v1.dw_id.guidPrefix[ 5]) return false;
    if (v1.dw_id.guidPrefix[ 4] < v2.dw_id.guidPrefix[ 4]) return true;
    if (v2.dw_id.guidPrefix[ 4] < v1.dw_id.guidPrefix[ 4]) return false;
    if (v1.dw_id.guidPrefix[ 3] < v2.dw_id.guidPrefix[ 3]) return true;
    if (v2.dw_id.guidPrefix[ 3] < v1.dw_id.guidPrefix[ 3]) return false;
    if (v1.dw_id.guidPrefix[ 2] < v2.dw_id.guidPrefix[ 2]) return true;
    if (v2.dw_id.guidPrefix[ 2] < v1.dw_id.guidPrefix[ 2]) return false;
    if (v1.dw_id.guidPrefix[ 1] < v2.dw_id.guidPrefix[ 1]) return true;
    if (v2.dw_id.guidPrefix[ 1] < v1.dw_id.guidPrefix[ 1]) return false;
    if (v1.dw_id.guidPrefix[ 0] < v2.dw_id.guidPrefix[ 0]) return true;
    if (v2.dw_id.guidPrefix[ 0] < v1.dw_id.guidPrefix[ 0]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class DataWriterReportDataWriterImpl;
class DataWriterReportDataReaderImpl;

/** Servant for TypeSupport interface of DataWriterReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataWriterReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef DataWriterReport                message_type;
  typedef DataWriterReport_var            message_var;
  typedef DataWriterReportTypeSupport     typesupport_type;
  typedef DataWriterReportTypeSupport_var typesupport_var;
  typedef DataWriterReportDataWriter      datawriter_type;
  typedef DataWriterReportDataReader      datareader_type;
  typedef DataWriterReportDataWriter_var  datawriter_var;
  typedef DataWriterReportDataReader_var  datareader_var;
  typedef DataWriterReportDataWriterImpl  datawriterimpl_type;
  typedef DataWriterReportDataReaderImpl  datareaderimpl_type;

  DataWriterReportTypeSupportImpl();
  virtual ~DataWriterReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef DataWriterReportTypeSupport::_ptr_type _ptr_type;
  typedef DataWriterReportTypeSupport::_var_type _var_type;
  typedef DataWriterReportDataWriter data_writer_type;
  typedef DataWriterReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::DataWriterReport data_sample_type;
  typedef ::OpenDDS::DCPS::DataWriterReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return DataWriterReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the DataWriterReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export DataWriterReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef DataWriterReport                message_type;
  typedef DataWriterReportTypeSupportImpl typesupportimpl_type;
  typedef DataWriterReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::DataWriterReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataWriterReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  DataWriterReportDataWriterImpl (void);

  /// Destructor
  virtual ~DataWriterReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::DataWriterReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::DataWriterReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataWriterReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::DataWriterReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::DataWriterReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of DataWriterReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataWriterReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef DataWriterReport                message_type;
  typedef DataWriterReportTypeSupportImpl typesupportimpl_type;
  typedef DataWriterReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::DataWriterReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataWriterReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::DataWriterReport, ACE_Null_Mutex>  DataAllocator;
  typedef DataWriterReportDataReader Interface;

  /// Constructor
  DataWriterReportDataReaderImpl (void);

  /// Destructor
  virtual ~DataWriterReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::DataWriterReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::DataWriterReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::DataWriterReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::DataWriterReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::DataWriterReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::DataWriterReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataWriterReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataWriterReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::DataWriterReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::DataWriterReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::DataWriterReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::DataWriterReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterReport*);

}  }

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociationPeriodic>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociationPeriodic*);

}  }

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DWAssociationsPeriodic& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociationsPeriodic& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociationsPeriodic*);

}  }

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::DataWriterPeriodicReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterPeriodicReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::DataWriterPeriodicReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataWriterPeriodicReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataWriterPeriodicReport& v1, const OpenDDS::DCPS::DataWriterPeriodicReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[ 9] < v2.dw_id.guidPrefix[ 9]) return true;
    if (v2.dw_id.guidPrefix[ 9] < v1.dw_id.guidPrefix[ 9]) return false;
    if (v1.dw_id.guidPrefix[ 8] < v2.dw_id.guidPrefix[ 8]) return true;
    if (v2.dw_id.guidPrefix[ 8] < v1.dw_id.guidPrefix[ 8]) return false;
    if (v1.dw_id.guidPrefix[ 7] < v2.dw_id.guidPrefix[ 7]) return true;
    if (v2.dw_id.guidPrefix[ 7] < v1.dw_id.guidPrefix[ 7]) return false;
    if (v1.dw_id.guidPrefix[ 6] < v2.dw_id.guidPrefix[ 6]) return true;
    if (v2.dw_id.guidPrefix[ 6] < v1.dw_id.guidPrefix[ 6]) return false;
    if (v1.dw_id.guidPrefix[ 5] < v2.dw_id.guidPrefix[ 5]) return true;
    if (v2.dw_id.guidPrefix[ 5] < v1.dw_id.guidPrefix[ 5]) return false;
    if (v1.dw_id.guidPrefix[ 4] < v2.dw_id.guidPrefix[ 4]) return true;
    if (v2.dw_id.guidPrefix[ 4] < v1.dw_id.guidPrefix[ 4]) return false;
    if (v1.dw_id.guidPrefix[ 3] < v2.dw_id.guidPrefix[ 3]) return true;
    if (v2.dw_id.guidPrefix[ 3] < v1.dw_id.guidPrefix[ 3]) return false;
    if (v1.dw_id.guidPrefix[ 2] < v2.dw_id.guidPrefix[ 2]) return true;
    if (v2.dw_id.guidPrefix[ 2] < v1.dw_id.guidPrefix[ 2]) return false;
    if (v1.dw_id.guidPrefix[ 1] < v2.dw_id.guidPrefix[ 1]) return true;
    if (v2.dw_id.guidPrefix[ 1] < v1.dw_id.guidPrefix[ 1]) return false;
    if (v1.dw_id.guidPrefix[ 0] < v2.dw_id.guidPrefix[ 0]) return true;
    if (v2.dw_id.guidPrefix[ 0] < v1.dw_id.guidPrefix[ 0]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class DataWriterPeriodicReportDataWriterImpl;
class DataWriterPeriodicReportDataReaderImpl;

/** Servant for TypeSupport interface of DataWriterPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataWriterPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef DataWriterPeriodicReport                message_type;
  typedef DataWriterPeriodicReport_var            message_var;
  typedef DataWriterPeriodicReportTypeSupport     typesupport_type;
  typedef DataWriterPeriodicReportTypeSupport_var typesupport_var;
  typedef DataWriterPeriodicReportDataWriter      datawriter_type;
  typedef DataWriterPeriodicReportDataReader      datareader_type;
  typedef DataWriterPeriodicReportDataWriter_var  datawriter_var;
  typedef DataWriterPeriodicReportDataReader_var  datareader_var;
  typedef DataWriterPeriodicReportDataWriterImpl  datawriterimpl_type;
  typedef DataWriterPeriodicReportDataReaderImpl  datareaderimpl_type;

  DataWriterPeriodicReportTypeSupportImpl();
  virtual ~DataWriterPeriodicReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef DataWriterPeriodicReportTypeSupport::_ptr_type _ptr_type;
  typedef DataWriterPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataWriterPeriodicReportDataWriter data_writer_type;
  typedef DataWriterPeriodicReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::DataWriterPeriodicReport data_sample_type;
  typedef ::OpenDDS::DCPS::DataWriterPeriodicReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return DataWriterPeriodicReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the DataWriterPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export DataWriterPeriodicReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterPeriodicReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef DataWriterPeriodicReport                message_type;
  typedef DataWriterPeriodicReportTypeSupportImpl typesupportimpl_type;
  typedef DataWriterPeriodicReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::DataWriterPeriodicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataWriterPeriodicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  DataWriterPeriodicReportDataWriterImpl (void);

  /// Destructor
  virtual ~DataWriterPeriodicReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataWriterPeriodicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::DataWriterPeriodicReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::DataWriterPeriodicReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of DataWriterPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataWriterPeriodicReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterPeriodicReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef DataWriterPeriodicReport                message_type;
  typedef DataWriterPeriodicReportTypeSupportImpl typesupportimpl_type;
  typedef DataWriterPeriodicReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::DataWriterPeriodicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataWriterPeriodicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::DataWriterPeriodicReport, ACE_Null_Mutex>  DataAllocator;
  typedef DataWriterPeriodicReportDataReader Interface;

  /// Constructor
  DataWriterPeriodicReportDataReaderImpl (void);

  /// Destructor
  virtual ~DataWriterPeriodicReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::DataWriterPeriodicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::DataWriterPeriodicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataWriterPeriodicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataWriterPeriodicReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::DataWriterPeriodicReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::DataWriterPeriodicReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::DataWriterPeriodicReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterPeriodicReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterPeriodicReport*);

}  }

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderAssociation& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociation& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociation>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociation*);

}  }

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DRAssociations& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociations& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociations*);

}  }

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::DataReaderReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::DataReaderReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataReaderReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataReaderReport& v1, const OpenDDS::DCPS::DataReaderReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[ 9] < v2.dr_id.guidPrefix[ 9]) return true;
    if (v2.dr_id.guidPrefix[ 9] < v1.dr_id.guidPrefix[ 9]) return false;
    if (v1.dr_id.guidPrefix[ 8] < v2.dr_id.guidPrefix[ 8]) return true;
    if (v2.dr_id.guidPrefix[ 8] < v1.dr_id.guidPrefix[ 8]) return false;
    if (v1.dr_id.guidPrefix[ 7] < v2.dr_id.guidPrefix[ 7]) return true;
    if (v2.dr_id.guidPrefix[ 7] < v1.dr_id.guidPrefix[ 7]) return false;
    if (v1.dr_id.guidPrefix[ 6] < v2.dr_id.guidPrefix[ 6]) return true;
    if (v2.dr_id.guidPrefix[ 6] < v1.dr_id.guidPrefix[ 6]) return false;
    if (v1.dr_id.guidPrefix[ 5] < v2.dr_id.guidPrefix[ 5]) return true;
    if (v2.dr_id.guidPrefix[ 5] < v1.dr_id.guidPrefix[ 5]) return false;
    if (v1.dr_id.guidPrefix[ 4] < v2.dr_id.guidPrefix[ 4]) return true;
    if (v2.dr_id.guidPrefix[ 4] < v1.dr_id.guidPrefix[ 4]) return false;
    if (v1.dr_id.guidPrefix[ 3] < v2.dr_id.guidPrefix[ 3]) return true;
    if (v2.dr_id.guidPrefix[ 3] < v1.dr_id.guidPrefix[ 3]) return false;
    if (v1.dr_id.guidPrefix[ 2] < v2.dr_id.guidPrefix[ 2]) return true;
    if (v2.dr_id.guidPrefix[ 2] < v1.dr_id.guidPrefix[ 2]) return false;
    if (v1.dr_id.guidPrefix[ 1] < v2.dr_id.guidPrefix[ 1]) return true;
    if (v2.dr_id.guidPrefix[ 1] < v1.dr_id.guidPrefix[ 1]) return false;
    if (v1.dr_id.guidPrefix[ 0] < v2.dr_id.guidPrefix[ 0]) return true;
    if (v2.dr_id.guidPrefix[ 0] < v1.dr_id.guidPrefix[ 0]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class DataReaderReportDataWriterImpl;
class DataReaderReportDataReaderImpl;

/** Servant for TypeSupport interface of DataReaderReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataReaderReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef DataReaderReport                message_type;
  typedef DataReaderReport_var            message_var;
  typedef DataReaderReportTypeSupport     typesupport_type;
  typedef DataReaderReportTypeSupport_var typesupport_var;
  typedef DataReaderReportDataWriter      datawriter_type;
  typedef DataReaderReportDataReader      datareader_type;
  typedef DataReaderReportDataWriter_var  datawriter_var;
  typedef DataReaderReportDataReader_var  datareader_var;
  typedef DataReaderReportDataWriterImpl  datawriterimpl_type;
  typedef DataReaderReportDataReaderImpl  datareaderimpl_type;

  DataReaderReportTypeSupportImpl();
  virtual ~DataReaderReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef DataReaderReportTypeSupport::_ptr_type _ptr_type;
  typedef DataReaderReportTypeSupport::_var_type _var_type;
  typedef DataReaderReportDataWriter data_writer_type;
  typedef DataReaderReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::DataReaderReport data_sample_type;
  typedef ::OpenDDS::DCPS::DataReaderReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return DataReaderReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the DataReaderReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export DataReaderReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef DataReaderReport                message_type;
  typedef DataReaderReportTypeSupportImpl typesupportimpl_type;
  typedef DataReaderReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::DataReaderReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataReaderReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  DataReaderReportDataWriterImpl (void);

  /// Destructor
  virtual ~DataReaderReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::DataReaderReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::DataReaderReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataReaderReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::DataReaderReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::DataReaderReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of DataReaderReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataReaderReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef DataReaderReport                message_type;
  typedef DataReaderReportTypeSupportImpl typesupportimpl_type;
  typedef DataReaderReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::DataReaderReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataReaderReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::DataReaderReport, ACE_Null_Mutex>  DataAllocator;
  typedef DataReaderReportDataReader Interface;

  /// Constructor
  DataReaderReportDataReaderImpl (void);

  /// Destructor
  virtual ~DataReaderReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::DataReaderReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::DataReaderReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::DataReaderReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::DataReaderReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::DataReaderReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::DataReaderReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataReaderReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataReaderReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::DataReaderReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::DataReaderReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::DataReaderReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::DataReaderReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderReport*);

}  }

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociationPeriodic>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociationPeriodic*);

}  }

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DRAssociationsPeriodic& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociationsPeriodic& seq);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociationsPeriodic*);

}  }

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::DataReaderPeriodicReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderPeriodicReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::DataReaderPeriodicReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataReaderPeriodicReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataReaderPeriodicReport& v1, const OpenDDS::DCPS::DataReaderPeriodicReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[ 9] < v2.dr_id.guidPrefix[ 9]) return true;
    if (v2.dr_id.guidPrefix[ 9] < v1.dr_id.guidPrefix[ 9]) return false;
    if (v1.dr_id.guidPrefix[ 8] < v2.dr_id.guidPrefix[ 8]) return true;
    if (v2.dr_id.guidPrefix[ 8] < v1.dr_id.guidPrefix[ 8]) return false;
    if (v1.dr_id.guidPrefix[ 7] < v2.dr_id.guidPrefix[ 7]) return true;
    if (v2.dr_id.guidPrefix[ 7] < v1.dr_id.guidPrefix[ 7]) return false;
    if (v1.dr_id.guidPrefix[ 6] < v2.dr_id.guidPrefix[ 6]) return true;
    if (v2.dr_id.guidPrefix[ 6] < v1.dr_id.guidPrefix[ 6]) return false;
    if (v1.dr_id.guidPrefix[ 5] < v2.dr_id.guidPrefix[ 5]) return true;
    if (v2.dr_id.guidPrefix[ 5] < v1.dr_id.guidPrefix[ 5]) return false;
    if (v1.dr_id.guidPrefix[ 4] < v2.dr_id.guidPrefix[ 4]) return true;
    if (v2.dr_id.guidPrefix[ 4] < v1.dr_id.guidPrefix[ 4]) return false;
    if (v1.dr_id.guidPrefix[ 3] < v2.dr_id.guidPrefix[ 3]) return true;
    if (v2.dr_id.guidPrefix[ 3] < v1.dr_id.guidPrefix[ 3]) return false;
    if (v1.dr_id.guidPrefix[ 2] < v2.dr_id.guidPrefix[ 2]) return true;
    if (v2.dr_id.guidPrefix[ 2] < v1.dr_id.guidPrefix[ 2]) return false;
    if (v1.dr_id.guidPrefix[ 1] < v2.dr_id.guidPrefix[ 1]) return true;
    if (v2.dr_id.guidPrefix[ 1] < v1.dr_id.guidPrefix[ 1]) return false;
    if (v1.dr_id.guidPrefix[ 0] < v2.dr_id.guidPrefix[ 0]) return true;
    if (v2.dr_id.guidPrefix[ 0] < v1.dr_id.guidPrefix[ 0]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class DataReaderPeriodicReportDataWriterImpl;
class DataReaderPeriodicReportDataReaderImpl;

/** Servant for TypeSupport interface of DataReaderPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataReaderPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef DataReaderPeriodicReport                message_type;
  typedef DataReaderPeriodicReport_var            message_var;
  typedef DataReaderPeriodicReportTypeSupport     typesupport_type;
  typedef DataReaderPeriodicReportTypeSupport_var typesupport_var;
  typedef DataReaderPeriodicReportDataWriter      datawriter_type;
  typedef DataReaderPeriodicReportDataReader      datareader_type;
  typedef DataReaderPeriodicReportDataWriter_var  datawriter_var;
  typedef DataReaderPeriodicReportDataReader_var  datareader_var;
  typedef DataReaderPeriodicReportDataWriterImpl  datawriterimpl_type;
  typedef DataReaderPeriodicReportDataReaderImpl  datareaderimpl_type;

  DataReaderPeriodicReportTypeSupportImpl();
  virtual ~DataReaderPeriodicReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef DataReaderPeriodicReportTypeSupport::_ptr_type _ptr_type;
  typedef DataReaderPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataReaderPeriodicReportDataWriter data_writer_type;
  typedef DataReaderPeriodicReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::DataReaderPeriodicReport data_sample_type;
  typedef ::OpenDDS::DCPS::DataReaderPeriodicReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return DataReaderPeriodicReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the DataReaderPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export DataReaderPeriodicReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderPeriodicReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef DataReaderPeriodicReport                message_type;
  typedef DataReaderPeriodicReportTypeSupportImpl typesupportimpl_type;
  typedef DataReaderPeriodicReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::DataReaderPeriodicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataReaderPeriodicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  DataReaderPeriodicReportDataWriterImpl (void);

  /// Destructor
  virtual ~DataReaderPeriodicReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataReaderPeriodicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::DataReaderPeriodicReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::DataReaderPeriodicReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of DataReaderPeriodicReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export DataReaderPeriodicReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderPeriodicReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef DataReaderPeriodicReport                message_type;
  typedef DataReaderPeriodicReportTypeSupportImpl typesupportimpl_type;
  typedef DataReaderPeriodicReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::DataReaderPeriodicReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::DataReaderPeriodicReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::DataReaderPeriodicReport, ACE_Null_Mutex>  DataAllocator;
  typedef DataReaderPeriodicReportDataReader Interface;

  /// Constructor
  DataReaderPeriodicReportDataReaderImpl (void);

  /// Destructor
  virtual ~DataReaderPeriodicReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::DataReaderPeriodicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::DataReaderPeriodicReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::DataReaderPeriodicReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::DataReaderPeriodicReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::DataReaderPeriodicReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::DataReaderPeriodicReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::DataReaderPeriodicReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderPeriodicReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderPeriodicReport*);

}  }

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::TransportReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
bool gen_is_bounded_size(const OpenDDS::DCPS::TransportReport&);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::TransportReport& stru, bool align);

OpenDDS_monitor_Export
bool gen_is_bounded_size(KeyOnly<const OpenDDS::DCPS::TransportReport>);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TransportReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TransportReport> stru);

}  }

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_has_key(const OpenDDS::DCPS::TransportReport&);

}  }

namespace OpenDDS {
namespace DCPS {
namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export TransportReport_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::TransportReport& v1, const OpenDDS::DCPS::TransportReport& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    if (v1.transport_id < v2.transport_id) return true;
    if (v2.transport_id < v1.transport_id) return false;
    return false;
  }
};
}
}
}
namespace OpenDDS {
namespace DCPS {

class TransportReportDataWriterImpl;
class TransportReportDataReaderImpl;

/** Servant for TypeSupport interface of TransportReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export TransportReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TransportReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef TransportReport                message_type;
  typedef TransportReport_var            message_var;
  typedef TransportReportTypeSupport     typesupport_type;
  typedef TransportReportTypeSupport_var typesupport_var;
  typedef TransportReportDataWriter      datawriter_type;
  typedef TransportReportDataReader      datareader_type;
  typedef TransportReportDataWriter_var  datawriter_var;
  typedef TransportReportDataReader_var  datareader_var;
  typedef TransportReportDataWriterImpl  datawriterimpl_type;
  typedef TransportReportDataReaderImpl  datareaderimpl_type;

  TransportReportTypeSupportImpl();
  virtual ~TransportReportTypeSupportImpl();

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

  typedef TransportReportTypeSupport::_ptr_type _ptr_type;
  typedef TransportReportTypeSupport::_var_type _var_type;
  typedef TransportReportDataWriter data_writer_type;
  typedef TransportReportDataReader data_reader_type;
  typedef ::OpenDDS::DCPS::TransportReport data_sample_type;
  typedef ::OpenDDS::DCPS::TransportReportSeq data_sequence_type;

  static _ptr_type _narrow(CORBA::Object_ptr obj) {
    return TransportReportTypeSupport::_narrow(obj);
  }
};

/** Servant for DataWriter interface of the TransportReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class OpenDDS_monitor_Export TransportReportDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<TransportReportDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:
  typedef TransportReport                message_type;
  typedef TransportReportTypeSupportImpl typesupportimpl_type;
  typedef TransportReportDataReaderImpl  datareader_type;

  typedef std::map<OpenDDS::DCPS::TransportReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TransportReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;

  /// Constructor
  TransportReportDataWriterImpl (void);

  /// Destructor
  virtual ~TransportReportDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::OpenDDS::DCPS::TransportReport & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::OpenDDS::DCPS::TransportReport & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::OpenDDS::DCPS::TransportReport & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::OpenDDS::DCPS::TransportReport & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::OpenDDS::DCPS::TransportReport & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::OpenDDS::DCPS::TransportReport & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::OpenDDS::DCPS::TransportReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::OpenDDS::DCPS::TransportReport & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::TransportReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::TransportReport & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::OpenDDS::DCPS::TransportReport& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::OpenDDS::DCPS::TransportReport& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;

   // A class, normally provided by an unit test, that needs access to
   // private methods/members.
   friend class ::DDS_TEST;
};

/** Servant for DataReader interface of TransportReport data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class OpenDDS_monitor_Export TransportReportDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<TransportReportDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:
  typedef TransportReport                message_type;
  typedef TransportReportTypeSupportImpl typesupportimpl_type;
  typedef TransportReportDataWriterImpl  datawriter_type;

  typedef std::map<OpenDDS::DCPS::TransportReport, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::TransportReport_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<OpenDDS::DCPS::TransportReport, ACE_Null_Mutex>  DataAllocator;
  typedef TransportReportDataReader Interface;

  /// Constructor
  TransportReportDataReaderImpl (void);

  /// Destructor
  virtual ~TransportReportDataReaderImpl (void);

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::OpenDDS::DCPS::TransportReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::OpenDDS::DCPS::TransportReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::OpenDDS::DCPS::TransportReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::OpenDDS::DCPS::TransportReport & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::OpenDDS::DCPS::TransportReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::OpenDDS::DCPS::TransportReportSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::OpenDDS::DCPS::TransportReport & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::OpenDDS::DCPS::TransportReport & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::OpenDDS::DCPS::TransportReportSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
    bool adjust_ref_count=false);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  virtual ::DDS::ReturnCode_t take(
    OpenDDS::DCPS::AbstractSamples& samples,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const OpenDDS::DCPS::TransportReport& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                    OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::OpenDDS::DCPS::TransportReportSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::OpenDDS::DCPS::TransportReport *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered);

    /// Release sample_lock_ during status notifications in store_instance_data()
    /// as the lock is not needed and could cause deadlock condition.
    /// See comments in member function implementation for details.
    void notify_status_condition_no_sample_lock();

    /// Common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::OpenDDS::DCPS::TransportReportSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples);

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
}
}
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportReport>();
OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportReport*);

}  }

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReportType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ReportType& enumval);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

extern const char* gen_OpenDDS_DCPS_ReportType_names[];
}  }

#endif

/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::GenericReport& uni, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::GenericReport& uni);

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_skip_over(Serializer& ser, OpenDDS::DCPS::GenericReport*);

}  }

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
#endif /* OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_MOS7OL */
