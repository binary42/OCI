/* Generated by ../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file DdsDcpsInfoUtils.idl*/
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsInfoUtilsTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/CorbaSeq/OctetSeqTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"
#include "dds/DdsDcpsInfrastructureTypeSupportImpl.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */


/* End TYPEDEF: RepoId */


/* Begin TYPEDEF: TransportBLOB */


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportLocator& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.transport_type) + 1;
  gen_find_size(stru.data, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.transport_type)
    && (strm << stru.data);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.transport_type.out())
    && (strm >> stru.data);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TransportLocator> : MetaStruct {
  typedef OpenDDS::DCPS::TransportLocator T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TransportLocator& typed = *static_cast<const OpenDDS::DCPS::TransportLocator*>(stru);
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "transport_type") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportBLOB*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::TransportLocator");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"transport_type", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const OpenDDS::DCPS::TransportBLOB*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type, static_cast<const T*>(rhs)->transport_type);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportLocator>()
{
  static MetaStructImpl<OpenDDS::DCPS::TransportLocator> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocator*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TransportLocator>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportLocatorSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::IncompatibleQosStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.count_since_last_send);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_policy_id);
  gen_find_size(stru.policies, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.count_since_last_send)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.count_since_last_send)
    && (strm >> stru.last_policy_id)
    && (strm >> stru.policies);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> : MetaStruct {
  typedef OpenDDS::DCPS::IncompatibleQosStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::IncompatibleQosStatus& typed = *static_cast<const OpenDDS::DCPS::IncompatibleQosStatus*>(stru);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return typed.count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'count_since_last_send' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<DDS::QosPolicyCountSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::IncompatibleQosStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return make_field_cmp(&T::count_since_last_send, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "count_since_last_send", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return &static_cast<const T*>(stru)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      static_cast<T*>(lhs)->count_since_last_send = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return static_cast<const T*>(lhs)->count_since_last_send == static_cast<const T*>(rhs)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::IncompatibleQosStatus>()
{
  static MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::IncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::AddDomainStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.id, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.id)
    && (strm << ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.id)
    && (strm >> ACE_InputCDR::to_boolean(stru.federated));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> : MetaStruct {
  typedef OpenDDS::DCPS::AddDomainStatus T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::AddDomainStatus& typed = *static_cast<const OpenDDS::DCPS::AddDomainStatus*>(stru);
    if (std::strncmp(field, "id.", 3) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.id, field + 3);
    }
    if (std::strcmp(field, "federated") == 0) {
      return typed.federated;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "id.", 3) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 3);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0));
    }
    if (std::strcmp(field, "federated") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'federated' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::AddDomainStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "id.", 3) == 0) {
      return make_struct_cmp(&T::id, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 3, 0), next);
    }
    if (std::strcmp(field, "federated") == 0) {
      return make_field_cmp(&T::federated, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"id", "federated", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "id") == 0) {
      return &static_cast<const T*>(stru)->id;
    }
    if (std::strcmp(field, "federated") == 0) {
      return &static_cast<const T*>(stru)->federated;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "id") == 0) {
      static_cast<T*>(lhs)->id = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "federated") == 0) {
      static_cast<T*>(lhs)->federated = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "federated") == 0) {
      return static_cast<const T*>(lhs)->federated == static_cast<const T*>(rhs)->federated;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::AddDomainStatus>()
{
  static MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::AddDomainStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::AddDomainStatus>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::TopicStatus>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_TopicStatus_names[] = {
  "CREATED",
  "ENABLED",
  "FOUND",
  "NOT_FOUND",
  "REMOVED",
  "CONFLICTING_TYPENAME",
  "PRECONDITION_NOT_MET",
  "INTERNAL_ERROR"
};
}  }

#endif

/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::WriterAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.writerTransInfo, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.pubQos, size, padding);
  gen_find_size(stru.writerQos, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.writerTransInfo)
    && (strm << stru.writerId)
    && (strm << stru.pubQos)
    && (strm << stru.writerQos);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.writerTransInfo)
    && (strm >> stru.writerId)
    && (strm >> stru.pubQos)
    && (strm >> stru.writerQos);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::WriterAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::WriterAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::WriterAssociation& typed = *static_cast<const OpenDDS::DCPS::WriterAssociation*>(stru);
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return getMetaStruct<DDS::PublisherQos>().getValue(&typed.pubQos, field + 7);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataWriterQos>().getValue(&typed.writerQos, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0));
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0));
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return getMetaStruct<DDS::PublisherQos>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<DDS::PublisherQos*>(0));
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataWriterQos>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::DataWriterQos*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::WriterAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return make_struct_cmp(&T::pubQos, getMetaStruct<DDS::PublisherQos>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return make_struct_cmp(&T::writerQos, getMetaStruct<DDS::DataWriterQos>().create_qc_comparator(field + 10, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"writerTransInfo", "writerId", "pubQos", "writerQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "writerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->writerTransInfo;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      return &static_cast<const T*>(stru)->pubQos;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      return &static_cast<const T*>(stru)->writerQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "writerTransInfo") == 0) {
      static_cast<T*>(lhs)->writerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      static_cast<T*>(lhs)->pubQos = *static_cast<const DDS::PublisherQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      static_cast<T*>(lhs)->writerQos = *static_cast<const DDS::DataWriterQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::WriterAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::WriterAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::WriterAssociation>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ReaderAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.readerTransInfo, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.subQos, size, padding);
  gen_find_size(stru.readerQos, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterExpression) + 1;
  gen_find_size(stru.exprParams, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.readerTransInfo)
    && (strm << stru.readerId)
    && (strm << stru.subQos)
    && (strm << stru.readerQos)
    && (strm << stru.filterExpression)
    && (strm << stru.exprParams);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.readerTransInfo)
    && (strm >> stru.readerId)
    && (strm >> stru.subQos)
    && (strm >> stru.readerQos)
    && (strm >> stru.filterExpression.out())
    && (strm >> stru.exprParams);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::ReaderAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ReaderAssociation& typed = *static_cast<const OpenDDS::DCPS::ReaderAssociation*>(stru);
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return getMetaStruct<DDS::SubscriberQos>().getValue(&typed.subQos, field + 7);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataReaderQos>().getValue(&typed.readerQos, field + 10);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0));
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0));
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return getMetaStruct<DDS::SubscriberQos>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<DDS::SubscriberQos*>(0));
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataReaderQos>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::DataReaderQos*>(0));
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<DDS::StringSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::DCPS::ReaderAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return make_struct_cmp(&T::subQos, getMetaStruct<DDS::SubscriberQos>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return make_struct_cmp(&T::readerQos, getMetaStruct<DDS::DataReaderQos>().create_qc_comparator(field + 10, 0), next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"readerTransInfo", "readerId", "subQos", "readerQos", "filterExpression", "exprParams", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "readerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->readerTransInfo;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "subQos") == 0) {
      return &static_cast<const T*>(stru)->subQos;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      return &static_cast<const T*>(stru)->readerQos;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      return &static_cast<const T*>(stru)->exprParams;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "readerTransInfo") == 0) {
      static_cast<T*>(lhs)->readerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "subQos") == 0) {
      static_cast<T*>(lhs)->subQos = *static_cast<const DDS::SubscriberQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      static_cast<T*>(lhs)->readerQos = *static_cast<const DDS::DataReaderQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      static_cast<T*>(lhs)->exprParams = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression, static_cast<const T*>(rhs)->filterExpression);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ReaderAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ReaderAssociation>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::WriterIdSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ReaderIdSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: ReaderIdSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
