// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p7
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "RtpsBaseMessageTypesC.h"
#include "tao/CDR.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "RtpsBaseMessageTypesC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::OctetArray2_slice *
OpenDDS::RTPS::OctetArray2_dup (const OpenDDS::RTPS::OctetArray2_slice *_tao_src_array)
{
  OpenDDS::RTPS::OctetArray2_slice *_tao_dup_array =
    OpenDDS::RTPS::OctetArray2_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::OctetArray2_slice *> (0);
    }
  
  OpenDDS::RTPS::OctetArray2_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::OctetArray2_slice *
OpenDDS::RTPS::OctetArray2_alloc (void)
{
  OpenDDS::RTPS::OctetArray2_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[2], 0);
  return retval;
}

void
OpenDDS::RTPS::OctetArray2_free (
    OpenDDS::RTPS::OctetArray2_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::OctetArray2_copy (
    OpenDDS::RTPS::OctetArray2_slice * _tao_to,
    const OpenDDS::RTPS::OctetArray2_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 2; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::OctetArray16_slice *
OpenDDS::RTPS::OctetArray16_dup (const OpenDDS::RTPS::OctetArray16_slice *_tao_src_array)
{
  OpenDDS::RTPS::OctetArray16_slice *_tao_dup_array =
    OpenDDS::RTPS::OctetArray16_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::OctetArray16_slice *> (0);
    }
  
  OpenDDS::RTPS::OctetArray16_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::OctetArray16_slice *
OpenDDS::RTPS::OctetArray16_alloc (void)
{
  OpenDDS::RTPS::OctetArray16_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[16], 0);
  return retval;
}

void
OpenDDS::RTPS::OctetArray16_free (
    OpenDDS::RTPS::OctetArray16_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::OctetArray16_copy (
    OpenDDS::RTPS::OctetArray16_slice * _tao_to,
    const OpenDDS::RTPS::OctetArray16_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 16; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::OctetArray4_slice *
OpenDDS::RTPS::OctetArray4_dup (const OpenDDS::RTPS::OctetArray4_slice *_tao_src_array)
{
  OpenDDS::RTPS::OctetArray4_slice *_tao_dup_array =
    OpenDDS::RTPS::OctetArray4_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::OctetArray4_slice *> (0);
    }
  
  OpenDDS::RTPS::OctetArray4_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::OctetArray4_slice *
OpenDDS::RTPS::OctetArray4_alloc (void)
{
  OpenDDS::RTPS::OctetArray4_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[4], 0);
  return retval;
}

void
OpenDDS::RTPS::OctetArray4_free (
    OpenDDS::RTPS::OctetArray4_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::OctetArray4_copy (
    OpenDDS::RTPS::OctetArray4_slice * _tao_to,
    const OpenDDS::RTPS::OctetArray4_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_FILTERRESULT_T_CS_)
#define _OPENDDS_RTPS_FILTERRESULT_T_CS_

OpenDDS::RTPS::FilterResult_t::FilterResult_t (void)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (max)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    const FilterResult_t &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (seq)
{}

OpenDDS::RTPS::FilterResult_t::~FilterResult_t (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::FilterSignature_t_slice *
OpenDDS::RTPS::FilterSignature_t_dup (const OpenDDS::RTPS::FilterSignature_t_slice *_tao_src_array)
{
  OpenDDS::RTPS::FilterSignature_t_slice *_tao_dup_array =
    OpenDDS::RTPS::FilterSignature_t_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::FilterSignature_t_slice *> (0);
    }
  
  OpenDDS::RTPS::FilterSignature_t_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::FilterSignature_t_slice *
OpenDDS::RTPS::FilterSignature_t_alloc (void)
{
  OpenDDS::RTPS::FilterSignature_t_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[4], 0);
  return retval;
}

void
OpenDDS::RTPS::FilterSignature_t_free (
    OpenDDS::RTPS::FilterSignature_t_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::FilterSignature_t_copy (
    OpenDDS::RTPS::FilterSignature_t_slice * _tao_to,
    const OpenDDS::RTPS::FilterSignature_t_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_FILTERSIGNATURESEQ_CS_)
#define _OPENDDS_RTPS_FILTERSIGNATURESEQ_CS_

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (void)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      > (max)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::FilterSignature_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    const FilterSignatureSeq &seq)
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      > (seq)
{}

OpenDDS::RTPS::FilterSignatureSeq::~FilterSignatureSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_PROPERTYSEQ_CS_)
#define _OPENDDS_RTPS_PROPERTYSEQ_CS_

OpenDDS::RTPS::PropertySeq::PropertySeq (void)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Property_t
      > (max)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Property_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Property_t
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    const PropertySeq &seq)
  : ::TAO::unbounded_value_sequence<
        Property_t
      > (seq)
{}

OpenDDS::RTPS::PropertySeq::~PropertySeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_PARAMETERLIST_CS_)
#define _OPENDDS_RTPS_PARAMETERLIST_CS_

OpenDDS::RTPS::ParameterList::ParameterList (void)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Parameter
      > (max)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Parameter * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Parameter
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    const ParameterList &seq)
  : ::TAO::unbounded_value_sequence<
        Parameter
      > (seq)
{}

OpenDDS::RTPS::ParameterList::~ParameterList (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

OpenDDS::RTPS::Parameter::Parameter (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = 0;
}

OpenDDS::RTPS::Parameter::Parameter (const ::OpenDDS::RTPS::Parameter &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 5U:
    case 7U:
    {
      this->u_.string_data_ = ::CORBA::string_dup (u.u_.string_data_);
    }
    break;
    case 44U:
    {
      if (u.u_.user_data_ == 0)
        {
          this->u_.user_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.user_data_,
              DDS::UserDataQosPolicy (*u.u_.user_data_)
            );
        }
    }
    break;
    case 45U:
    {
      if (u.u_.group_data_ == 0)
        {
          this->u_.group_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.group_data_,
              DDS::GroupDataQosPolicy (*u.u_.group_data_)
            );
        }
    }
    break;
    case 46U:
    {
      if (u.u_.topic_data_ == 0)
        {
          this->u_.topic_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.topic_data_,
              DDS::TopicDataQosPolicy (*u.u_.topic_data_)
            );
        }
    }
    break;
    case 29U:
    {
      this->u_.durability_ = u.u_.durability_;
    }
    break;
    case 30U:
    {
      this->u_.durability_service_ = u.u_.durability_service_;
    }
    break;
    case 35U:
    {
      this->u_.deadline_ = u.u_.deadline_;
    }
    break;
    case 39U:
    {
      this->u_.latency_budget_ = u.u_.latency_budget_;
    }
    break;
    case 27U:
    {
      this->u_.liveliness_ = u.u_.liveliness_;
    }
    break;
    case 26U:
    {
      this->u_.reliability_ = u.u_.reliability_;
    }
    break;
    case 43U:
    {
      this->u_.lifespan_ = u.u_.lifespan_;
    }
    break;
    case 37U:
    {
      this->u_.destination_order_ = u.u_.destination_order_;
    }
    break;
    case 64U:
    {
      this->u_.history_ = u.u_.history_;
    }
    break;
    case 65U:
    {
      this->u_.resource_limits_ = u.u_.resource_limits_;
    }
    break;
    case 31U:
    {
      this->u_.ownership_ = u.u_.ownership_;
    }
    break;
    case 6U:
    {
      this->u_.ownership_strength_ = u.u_.ownership_strength_;
    }
    break;
    case 33U:
    {
      this->u_.presentation_ = u.u_.presentation_;
    }
    break;
    case 41U:
    {
      if (u.u_.partition_ == 0)
        {
          this->u_.partition_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.partition_,
              DDS::PartitionQosPolicy (*u.u_.partition_)
            );
        }
    }
    break;
    case 4U:
    {
      this->u_.time_based_filter_ = u.u_.time_based_filter_;
    }
    break;
    case 73U:
    {
      this->u_.transport_priority_ = u.u_.transport_priority_;
    }
    break;
    case 21U:
    {
      this->u_.version_ = u.u_.version_;
    }
    break;
    case 22U:
    {
      this->u_.vendor_ = u.u_.vendor_;
    }
    break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
    {
      this->u_.locator_ = u.u_.locator_;
    }
    break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
    {
      this->u_.ipv4_address_ = u.u_.ipv4_address_;
    }
    break;
    case 14U:
    case 13U:
    case 70U:
    {
      this->u_.udpv4_port_ = u.u_.udpv4_port_;
    }
    break;
    case 67U:
    {
      this->u_.expects_inline_qos_ = u.u_.expects_inline_qos_;
    }
    break;
    case 52U:
    {
      this->u_.count_ = u.u_.count_;
    }
    break;
    case 68U:
    {
      this->u_.participant_builtin_endpoints_ = u.u_.participant_builtin_endpoints_;
    }
    break;
    case 2U:
    {
      this->u_.duration_ = u.u_.duration_;
    }
    break;
    case 53U:
    {
      if (u.u_.content_filter_property_ == 0)
        {
          this->u_.content_filter_property_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.content_filter_property_,
              OpenDDS::RTPS::ContentFilterProperty_t (*u.u_.content_filter_property_)
            );
        }
    }
    break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
    {
      this->u_.guid_ = u.u_.guid_;
    }
    break;
    case 81U:
    case 83U:
    {
      this->u_.entity_id_ = u.u_.entity_id_;
    }
    break;
    case 88U:
    {
      this->u_.builtin_endpoints_ = u.u_.builtin_endpoints_;
    }
    break;
    case 89U:
    {
      if (u.u_.properties_ == 0)
        {
          this->u_.properties_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.properties_,
              OpenDDS::RTPS::PropertySeq (*u.u_.properties_)
            );
        }
    }
    break;
    case 96U:
    {
      this->u_.type_max_size_serialized_ = u.u_.type_max_size_serialized_;
    }
    break;
    case 98U:
    {
      if (u.u_.entity_name_ == 0)
        {
          this->u_.entity_name_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.entity_name_,
              OpenDDS::RTPS::EntityName_t (*u.u_.entity_name_)
            );
        }
    }
    break;
    case 112U:
    {
      this->u_.key_hash_ = u.u_.key_hash_;
    }
    break;
    case 113U:
    {
      this->u_.status_info_ = u.u_.status_info_;
    }
    break;
    case 85U:
    {
      if (u.u_.content_filter_info_ == 0)
        {
          this->u_.content_filter_info_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.content_filter_info_,
              OpenDDS::RTPS::ContentFilterInfo_t (*u.u_.content_filter_info_)
            );
        }
    }
    break;
    case 86U:
    {
      this->u_.coherent_set_ = u.u_.coherent_set_;
    }
    break;
    case 87U:
    {
      if (u.u_.directed_write_ == 0)
        {
          this->u_.directed_write_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.directed_write_,
              OpenDDS::RTPS::GUIDSeq (*u.u_.directed_write_)
            );
        }
    }
    break;
    case 97U:
    {
      if (u.u_.original_writer_info_ == 0)
        {
          this->u_.original_writer_info_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.original_writer_info_,
              OpenDDS::RTPS::OriginalWriterInfo_t (*u.u_.original_writer_info_)
            );
        }
    }
    break;
    case 45057U:
    {
      if (u.u_.opendds_locator_ == 0)
        {
          this->u_.opendds_locator_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.opendds_locator_,
              OpenDDS::DCPS::TransportLocator (*u.u_.opendds_locator_)
            );
        }
    }
    break;
    default:
    {
      if (u.u_.unknown_data_ == 0)
        {
          this->u_.unknown_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.unknown_data_,
              OpenDDS::RTPS::OctetSeq (*u.u_.unknown_data_)
            );
        }
    }
    break;
  }
}

OpenDDS::RTPS::Parameter::~Parameter (void)
{
  // Finalize.
  this->_reset ();
}

OpenDDS::RTPS::Parameter &
OpenDDS::RTPS::Parameter::operator= (const ::OpenDDS::RTPS::Parameter &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 5U:
    case 7U:
    {
      this->u_.string_data_ = ::CORBA::string_dup (u.u_.string_data_);
    }
    break;
    case 44U:
    {
      if (u.u_.user_data_ == 0)
        {
          this->u_.user_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.user_data_,
              DDS::UserDataQosPolicy (*u.u_.user_data_),
              *this
            );
        }
    }
    break;
    case 45U:
    {
      if (u.u_.group_data_ == 0)
        {
          this->u_.group_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.group_data_,
              DDS::GroupDataQosPolicy (*u.u_.group_data_),
              *this
            );
        }
    }
    break;
    case 46U:
    {
      if (u.u_.topic_data_ == 0)
        {
          this->u_.topic_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.topic_data_,
              DDS::TopicDataQosPolicy (*u.u_.topic_data_),
              *this
            );
        }
    }
    break;
    case 29U:
    {
      this->u_.durability_ = u.u_.durability_;
    }
    break;
    case 30U:
    {
      this->u_.durability_service_ = u.u_.durability_service_;
    }
    break;
    case 35U:
    {
      this->u_.deadline_ = u.u_.deadline_;
    }
    break;
    case 39U:
    {
      this->u_.latency_budget_ = u.u_.latency_budget_;
    }
    break;
    case 27U:
    {
      this->u_.liveliness_ = u.u_.liveliness_;
    }
    break;
    case 26U:
    {
      this->u_.reliability_ = u.u_.reliability_;
    }
    break;
    case 43U:
    {
      this->u_.lifespan_ = u.u_.lifespan_;
    }
    break;
    case 37U:
    {
      this->u_.destination_order_ = u.u_.destination_order_;
    }
    break;
    case 64U:
    {
      this->u_.history_ = u.u_.history_;
    }
    break;
    case 65U:
    {
      this->u_.resource_limits_ = u.u_.resource_limits_;
    }
    break;
    case 31U:
    {
      this->u_.ownership_ = u.u_.ownership_;
    }
    break;
    case 6U:
    {
      this->u_.ownership_strength_ = u.u_.ownership_strength_;
    }
    break;
    case 33U:
    {
      this->u_.presentation_ = u.u_.presentation_;
    }
    break;
    case 41U:
    {
      if (u.u_.partition_ == 0)
        {
          this->u_.partition_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.partition_,
              DDS::PartitionQosPolicy (*u.u_.partition_),
              *this
            );
        }
    }
    break;
    case 4U:
    {
      this->u_.time_based_filter_ = u.u_.time_based_filter_;
    }
    break;
    case 73U:
    {
      this->u_.transport_priority_ = u.u_.transport_priority_;
    }
    break;
    case 21U:
    {
      this->u_.version_ = u.u_.version_;
    }
    break;
    case 22U:
    {
      this->u_.vendor_ = u.u_.vendor_;
    }
    break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
    {
      this->u_.locator_ = u.u_.locator_;
    }
    break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
    {
      this->u_.ipv4_address_ = u.u_.ipv4_address_;
    }
    break;
    case 14U:
    case 13U:
    case 70U:
    {
      this->u_.udpv4_port_ = u.u_.udpv4_port_;
    }
    break;
    case 67U:
    {
      this->u_.expects_inline_qos_ = u.u_.expects_inline_qos_;
    }
    break;
    case 52U:
    {
      this->u_.count_ = u.u_.count_;
    }
    break;
    case 68U:
    {
      this->u_.participant_builtin_endpoints_ = u.u_.participant_builtin_endpoints_;
    }
    break;
    case 2U:
    {
      this->u_.duration_ = u.u_.duration_;
    }
    break;
    case 53U:
    {
      if (u.u_.content_filter_property_ == 0)
        {
          this->u_.content_filter_property_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.content_filter_property_,
              OpenDDS::RTPS::ContentFilterProperty_t (*u.u_.content_filter_property_),
              *this
            );
        }
    }
    break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
    {
      this->u_.guid_ = u.u_.guid_;
    }
    break;
    case 81U:
    case 83U:
    {
      this->u_.entity_id_ = u.u_.entity_id_;
    }
    break;
    case 88U:
    {
      this->u_.builtin_endpoints_ = u.u_.builtin_endpoints_;
    }
    break;
    case 89U:
    {
      if (u.u_.properties_ == 0)
        {
          this->u_.properties_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.properties_,
              OpenDDS::RTPS::PropertySeq (*u.u_.properties_),
              *this
            );
        }
    }
    break;
    case 96U:
    {
      this->u_.type_max_size_serialized_ = u.u_.type_max_size_serialized_;
    }
    break;
    case 98U:
    {
      if (u.u_.entity_name_ == 0)
        {
          this->u_.entity_name_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.entity_name_,
              OpenDDS::RTPS::EntityName_t (*u.u_.entity_name_),
              *this
            );
        }
    }
    break;
    case 112U:
    {
      this->u_.key_hash_ = u.u_.key_hash_;
    }
    break;
    case 113U:
    {
      this->u_.status_info_ = u.u_.status_info_;
    }
    break;
    case 85U:
    {
      if (u.u_.content_filter_info_ == 0)
        {
          this->u_.content_filter_info_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.content_filter_info_,
              OpenDDS::RTPS::ContentFilterInfo_t (*u.u_.content_filter_info_),
              *this
            );
        }
    }
    break;
    case 86U:
    {
      this->u_.coherent_set_ = u.u_.coherent_set_;
    }
    break;
    case 87U:
    {
      if (u.u_.directed_write_ == 0)
        {
          this->u_.directed_write_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.directed_write_,
              OpenDDS::RTPS::GUIDSeq (*u.u_.directed_write_),
              *this
            );
        }
    }
    break;
    case 97U:
    {
      if (u.u_.original_writer_info_ == 0)
        {
          this->u_.original_writer_info_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.original_writer_info_,
              OpenDDS::RTPS::OriginalWriterInfo_t (*u.u_.original_writer_info_),
              *this
            );
        }
    }
    break;
    case 45057U:
    {
      if (u.u_.opendds_locator_ == 0)
        {
          this->u_.opendds_locator_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.opendds_locator_,
              OpenDDS::DCPS::TransportLocator (*u.u_.opendds_locator_),
              *this
            );
        }
    }
    break;
    default:
    {
      if (u.u_.unknown_data_ == 0)
        {
          this->u_.unknown_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.unknown_data_,
              OpenDDS::RTPS::OctetSeq (*u.u_.unknown_data_),
              *this
            );
        }
    }
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void OpenDDS::RTPS::Parameter::_reset (void)
{
  switch (this->disc_)
  {
    
    case 5U:
    case 7U:
      ::CORBA::string_free (this->u_.string_data_);
      this->u_.string_data_ = 0;
      break;
    case 44U:
      delete this->u_.user_data_;
      this->u_.user_data_ = 0;
      break;
    case 45U:
      delete this->u_.group_data_;
      this->u_.group_data_ = 0;
      break;
    case 46U:
      delete this->u_.topic_data_;
      this->u_.topic_data_ = 0;
      break;
    case 29U:
      break;
    case 30U:
      break;
    case 35U:
      break;
    case 39U:
      break;
    case 27U:
      break;
    case 26U:
      break;
    case 43U:
      break;
    case 37U:
      break;
    case 64U:
      break;
    case 65U:
      break;
    case 31U:
      break;
    case 6U:
      break;
    case 33U:
      break;
    case 41U:
      delete this->u_.partition_;
      this->u_.partition_ = 0;
      break;
    case 4U:
      break;
    case 73U:
      break;
    case 21U:
      break;
    case 22U:
      break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      break;
    case 14U:
    case 13U:
    case 70U:
      break;
    case 67U:
      break;
    case 52U:
      break;
    case 68U:
      break;
    case 2U:
      break;
    case 53U:
      delete this->u_.content_filter_property_;
      this->u_.content_filter_property_ = 0;
      break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      break;
    case 81U:
    case 83U:
      break;
    case 88U:
      break;
    case 89U:
      delete this->u_.properties_;
      this->u_.properties_ = 0;
      break;
    case 96U:
      break;
    case 98U:
      delete this->u_.entity_name_;
      this->u_.entity_name_ = 0;
      break;
    case 112U:
      break;
    case 113U:
      break;
    case 85U:
      delete this->u_.content_filter_info_;
      this->u_.content_filter_info_ = 0;
      break;
    case 86U:
      break;
    case 87U:
      delete this->u_.directed_write_;
      this->u_.directed_write_ = 0;
      break;
    case 97U:
      delete this->u_.original_writer_info_;
      this->u_.original_writer_info_ = 0;
      break;
    case 45057U:
      delete this->u_.opendds_locator_;
      this->u_.opendds_locator_ = 0;
      break;
    default:
      delete this->u_.unknown_data_;
      this->u_.unknown_data_ = 0;
      break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Time_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.seconds) &&
    (strm << _tao_aggregate.fraction);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Time_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.seconds) &&
    (strm >> _tao_aggregate.fraction);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OctetArray2_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        2);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OctetArray2_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        2);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::VendorId_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray2_forany _tao_aggregate_vendorId
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray2_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray2_slice*> (
      #endif
          _tao_aggregate.vendorId
        )
    );
  return
    (strm << _tao_aggregate_vendorId);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::VendorId_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray2_forany _tao_aggregate_vendorId
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray2_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray2_slice*> (
      #endif
          _tao_aggregate.vendorId
        )
    );
  return
    (strm >> _tao_aggregate_vendorId);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SequenceNumber_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.high) &&
    (strm << _tao_aggregate.low);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SequenceNumber_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.high) &&
    (strm >> _tao_aggregate.low);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FragmentNumber_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FragmentNumber_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OctetArray16_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        16);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OctetArray16_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        16);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Locator_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray16_forany _tao_aggregate_address
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.address
        )
    );
  return
    (strm << _tao_aggregate.kind) &&
    (strm << _tao_aggregate.port) &&
    (strm << _tao_aggregate_address);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Locator_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray16_forany _tao_aggregate_address
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.address
        )
    );
  return
    (strm >> _tao_aggregate.kind) &&
    (strm >> _tao_aggregate.port) &&
    (strm >> _tao_aggregate_address);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LocatorUDPv4_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.address) &&
    (strm << _tao_aggregate.port);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LocatorUDPv4_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.address) &&
    (strm >> _tao_aggregate.port);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::TopicKind_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::TopicKind_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ReliabilityKind_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ReliabilityKind_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Count_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Count_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ProtocolVersion_t &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.major)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.minor));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ProtocolVersion_t &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.major)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.minor));
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::KeyHash_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray16_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm << _tao_aggregate_value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::KeyHash_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray16_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm >> _tao_aggregate_value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OctetArray4_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        4);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OctetArray4_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        4);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::StatusInfo_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm << _tao_aggregate_value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::StatusInfo_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm >> _tao_aggregate_value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ContentFilterProperty_t &_tao_aggregate)
{
  return
    (strm << ACE_OutputCDR::from_string (_tao_aggregate.contentFilteredTopicName.in (), 256)) &&
    (strm << ACE_OutputCDR::from_string (_tao_aggregate.relatedTopicName.in (), 256)) &&
    (strm << ACE_OutputCDR::from_string (_tao_aggregate.filterClassName.in (), 256)) &&
    (strm << _tao_aggregate.filterExpression.in ()) &&
    (strm << _tao_aggregate.expressionParameters);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ContentFilterProperty_t &_tao_aggregate)
{
  return
    (strm >> ACE_InputCDR::to_string (_tao_aggregate.contentFilteredTopicName.out (), 256)) &&
    (strm >> ACE_InputCDR::to_string (_tao_aggregate.relatedTopicName.out (), 256)) &&
    (strm >> ACE_InputCDR::to_string (_tao_aggregate.filterClassName.out (), 256)) &&
    (strm >> _tao_aggregate.filterExpression.out ()) &&
    (strm >> _tao_aggregate.expressionParameters);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterResult_t &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterResult_t &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterSignature_t_forany &_tao_array)
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        4);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterSignature_t_forany &_tao_array)
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        4);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterSignatureSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterSignatureSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ContentFilterInfo_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.filterResult) &&
    (strm << _tao_aggregate.filterSignatures);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ContentFilterInfo_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.filterResult) &&
    (strm >> _tao_aggregate.filterSignatures);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Property_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Property_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::PropertySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::PropertySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::EntityName_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::EntityName_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParameterList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParameterList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OriginalWriterInfo_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.originalWriterGUID) &&
    (strm << _tao_aggregate.originalWriterSN) &&
    (strm << _tao_aggregate.originalWriterQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OriginalWriterInfo_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.originalWriterGUID) &&
    (strm >> _tao_aggregate.originalWriterSN) &&
    (strm >> _tao_aggregate.originalWriterQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Parameter &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 5U:
    case 7U:
      {
        result = strm << ACE_OutputCDR::from_string (_tao_union.string_data (), 256);
      }
      break;
    case 44U:
      {
        result = strm << _tao_union.user_data ();
      }
      break;
    case 45U:
      {
        result = strm << _tao_union.group_data ();
      }
      break;
    case 46U:
      {
        result = strm << _tao_union.topic_data ();
      }
      break;
    case 29U:
      {
        result = strm << _tao_union.durability ();
      }
      break;
    case 30U:
      {
        result = strm << _tao_union.durability_service ();
      }
      break;
    case 35U:
      {
        result = strm << _tao_union.deadline ();
      }
      break;
    case 39U:
      {
        result = strm << _tao_union.latency_budget ();
      }
      break;
    case 27U:
      {
        result = strm << _tao_union.liveliness ();
      }
      break;
    case 26U:
      {
        result = strm << _tao_union.reliability ();
      }
      break;
    case 43U:
      {
        result = strm << _tao_union.lifespan ();
      }
      break;
    case 37U:
      {
        result = strm << _tao_union.destination_order ();
      }
      break;
    case 64U:
      {
        result = strm << _tao_union.history ();
      }
      break;
    case 65U:
      {
        result = strm << _tao_union.resource_limits ();
      }
      break;
    case 31U:
      {
        result = strm << _tao_union.ownership ();
      }
      break;
    case 6U:
      {
        result = strm << _tao_union.ownership_strength ();
      }
      break;
    case 33U:
      {
        result = strm << _tao_union.presentation ();
      }
      break;
    case 41U:
      {
        result = strm << _tao_union.partition ();
      }
      break;
    case 4U:
      {
        result = strm << _tao_union.time_based_filter ();
      }
      break;
    case 73U:
      {
        result = strm << _tao_union.transport_priority ();
      }
      break;
    case 21U:
      {
        result = strm << _tao_union.version ();
      }
      break;
    case 22U:
      {
        result = strm << _tao_union.vendor ();
      }
      break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      {
        result = strm << _tao_union.locator ();
      }
      break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      {
        result = strm << _tao_union.ipv4_address ();
      }
      break;
    case 14U:
    case 13U:
    case 70U:
      {
        result = strm << _tao_union.udpv4_port ();
      }
      break;
    case 67U:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.expects_inline_qos ());
      }
      break;
    case 52U:
      {
        result = strm << _tao_union.count ();
      }
      break;
    case 68U:
      {
        result = strm << _tao_union.participant_builtin_endpoints ();
      }
      break;
    case 2U:
      {
        result = strm << _tao_union.duration ();
      }
      break;
    case 53U:
      {
        result = strm << _tao_union.content_filter_property ();
      }
      break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      {
        result = strm << _tao_union.guid ();
      }
      break;
    case 81U:
    case 83U:
      {
        result = strm << _tao_union.entity_id ();
      }
      break;
    case 88U:
      {
        result = strm << _tao_union.builtin_endpoints ();
      }
      break;
    case 89U:
      {
        result = strm << _tao_union.properties ();
      }
      break;
    case 96U:
      {
        result = strm << _tao_union.type_max_size_serialized ();
      }
      break;
    case 98U:
      {
        result = strm << _tao_union.entity_name ();
      }
      break;
    case 112U:
      {
        result = strm << _tao_union.key_hash ();
      }
      break;
    case 113U:
      {
        result = strm << _tao_union.status_info ();
      }
      break;
    case 85U:
      {
        result = strm << _tao_union.content_filter_info ();
      }
      break;
    case 86U:
      {
        result = strm << _tao_union.coherent_set ();
      }
      break;
    case 87U:
      {
        result = strm << _tao_union.directed_write ();
      }
      break;
    case 97U:
      {
        result = strm << _tao_union.original_writer_info ();
      }
      break;
    case 45057U:
      {
        result = strm << _tao_union.opendds_locator ();
      }
      break;
    default:
      {
        result = strm << _tao_union.unknown_data ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Parameter &_tao_union
  )
{
  CORBA::UShort _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 5U:
    case 7U:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> ACE_InputCDR::to_string (_tao_union_tmp.out (), 256);

        if (result)
          {
            _tao_union.string_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 44U:
      {
        DDS::UserDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.user_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 45U:
      {
        DDS::GroupDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.group_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 46U:
      {
        DDS::TopicDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.topic_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 29U:
      {
        DDS::DurabilityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.durability (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 30U:
      {
        DDS::DurabilityServiceQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.durability_service (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 35U:
      {
        DDS::DeadlineQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.deadline (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 39U:
      {
        DDS::LatencyBudgetQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.latency_budget (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 27U:
      {
        DDS::LivelinessQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.liveliness (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 26U:
      {
        DDS::ReliabilityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.reliability (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 43U:
      {
        DDS::LifespanQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.lifespan (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 37U:
      {
        DDS::DestinationOrderQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.destination_order (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 64U:
      {
        DDS::HistoryQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.history (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 65U:
      {
        DDS::ResourceLimitsQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.resource_limits (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 31U:
      {
        DDS::OwnershipQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ownership (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 6U:
      {
        DDS::OwnershipStrengthQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ownership_strength (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 33U:
      {
        DDS::PresentationQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.presentation (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 41U:
      {
        DDS::PartitionQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.partition (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4U:
      {
        DDS::TimeBasedFilterQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.time_based_filter (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 73U:
      {
        DDS::TransportPriorityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.transport_priority (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 21U:
      {
        OpenDDS::RTPS::ProtocolVersion_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.version (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 22U:
      {
        OpenDDS::RTPS::VendorId_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.vendor (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      {
        OpenDDS::RTPS::Locator_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.locator (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ipv4_address (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 14U:
    case 13U:
    case 70U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.udpv4_port (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 67U:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.expects_inline_qos (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 52U:
      {
        OpenDDS::RTPS::Count_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.count (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 68U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.participant_builtin_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2U:
      {
        OpenDDS::RTPS::Time_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.duration (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 53U:
      {
        OpenDDS::RTPS::ContentFilterProperty_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.content_filter_property (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      {
        OpenDDS::DCPS::GUID_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.guid (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 81U:
    case 83U:
      {
        OpenDDS::DCPS::EntityId_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.entity_id (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 88U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.builtin_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 89U:
      {
        OpenDDS::RTPS::PropertySeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.properties (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 96U:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.type_max_size_serialized (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 98U:
      {
        OpenDDS::RTPS::EntityName_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.entity_name (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 112U:
      {
        OpenDDS::RTPS::KeyHash_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.key_hash (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 113U:
      {
        OpenDDS::RTPS::StatusInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.status_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 85U:
      {
        OpenDDS::RTPS::ContentFilterInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.content_filter_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 86U:
      {
        OpenDDS::RTPS::SequenceNumber_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.coherent_set (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 87U:
      {
        OpenDDS::RTPS::GUIDSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.directed_write (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 97U:
      {
        OpenDDS::RTPS::OriginalWriterInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.original_writer_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 45057U:
      {
        OpenDDS::DCPS::TransportLocator _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.opendds_locator (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        OpenDDS::RTPS::OctetSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.unknown_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



