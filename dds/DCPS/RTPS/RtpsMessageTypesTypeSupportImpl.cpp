/* Generated by ../../../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file RtpsMessageTypes.idl*/
#include "RtpsMessageTypesTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "./../../DdsDcpsGuidTypeSupportImpl.h"
#include "./../../DdsDcpsInfoUtilsTypeSupportImpl.h"
#include "./RtpsBaseMessageTypesTypeSupportImpl.h"
#include "dds/DdsDcpsInfrastructureTypeSupportImpl.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: RTPS */



/* Begin TYPEDEF: LongSeq8 */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LongSeq8& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LongSeq8*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }

#endif

/* End TYPEDEF: LongSeq8 */


/* Begin STRUCT: SequenceNumberSet */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 12 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumberSet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumberSet& typed = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(stru);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::SequenceNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SequenceNumberSet */


/* Begin STRUCT: FragmentNumberSet */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 8 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumberSet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumberSet& typed = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(stru);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::FragmentNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 11, 0), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: FragmentNumberSet */


/* Begin TYPEDEF: LocatorList */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Locator_t*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: LocatorList */


/* Begin STRUCT: Header */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Header& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru_prefix, size, padding);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru_prefix)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru_prefix)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Header> : MetaStruct {
  typedef OpenDDS::RTPS::Header T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Header& typed = *static_cast<const OpenDDS::RTPS::Header*>(stru);
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0));
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::Header");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"prefix", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "prefix") == 0) {
      return &static_cast<const T*>(stru)->prefix;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "prefix") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->prefix;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::RTPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::RTPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::RTPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Header>()
{
  static MetaStructImpl<OpenDDS::RTPS::Header> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Header*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Header>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Header */


/* Begin STRUCT: SubmessageHeader */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageHeader& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.submessageId));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.flags));
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.submessageLength);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  strm.swap_bytes(ACE_CDR_BYTE_ORDER != (stru.flags & 1));
  return (strm << ACE_OutputCDR::from_octet(stru.submessageId))
    && (strm << ACE_OutputCDR::from_octet(stru.flags))
    && (strm << stru.submessageLength);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.submessageId))
    && (strm >> ACE_InputCDR::to_octet(stru.flags))
    && (strm >> stru.submessageLength);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> : MetaStruct {
  typedef OpenDDS::RTPS::SubmessageHeader T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SubmessageHeader& typed = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(stru);
    if (std::strcmp(field, "submessageId") == 0) {
      return typed.submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return typed.flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return typed.submessageLength;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'submessageId' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "flags") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'flags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'submessageLength' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::SubmessageHeader");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "submessageId") == 0) {
      return make_field_cmp(&T::submessageId, next);
    }
    if (std::strcmp(field, "flags") == 0) {
      return make_field_cmp(&T::flags, next);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return make_field_cmp(&T::submessageLength, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"submessageId", "flags", "submessageLength", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      return &static_cast<const T*>(stru)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return &static_cast<const T*>(stru)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return &static_cast<const T*>(stru)->submessageLength;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "submessageId") == 0) {
      static_cast<T*>(lhs)->submessageId = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "flags") == 0) {
      static_cast<T*>(lhs)->flags = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      static_cast<T*>(lhs)->submessageLength = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "submessageId") == 0) {
      return static_cast<const T*>(lhs)->submessageId == static_cast<const T*>(rhs)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return static_cast<const T*>(lhs)->flags == static_cast<const T*>(rhs)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return static_cast<const T*>(lhs)->submessageLength == static_cast<const T*>(rhs)->submessageLength;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SubmessageHeader>()
{
  static MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageHeader*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SubmessageHeader */


/* Begin STRUCT: AckNackSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::AckNackSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.readerSNState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.readerSNState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.readerSNState)
    && (strm >> stru.count);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::AckNackSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::AckNackSubmessage& typed = *static_cast<const OpenDDS::RTPS::AckNackSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.readerSNState, field + 14);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 14);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::AckNackSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return make_struct_cmp(&T::readerSNState, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 14, 0), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "readerSNState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      return &static_cast<const T*>(stru)->readerSNState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      static_cast<T*>(lhs)->readerSNState = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::AckNackSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::AckNackSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: AckNackSubmessage */


/* Begin STRUCT: DataSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && strm.skip(stru.octetsToInlineQos - 16)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::DataSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataSubmessage */


/* Begin STRUCT: DataFragSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentStartingNum, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentsInSubmessage);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentSize);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sampleSize);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentStartingNum)
    && (strm << stru.fragmentsInSubmessage)
    && (strm << stru.fragmentSize)
    && (strm << stru.sampleSize)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentStartingNum)
    && (strm >> stru.fragmentsInSubmessage)
    && (strm >> stru.fragmentSize)
    && (strm >> stru.sampleSize)
    && strm.skip(stru.octetsToInlineQos - 28)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.fragmentStartingNum, field + 20);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return typed.fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return typed.fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return typed.sampleSize;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 20);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentSize' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sampleSize' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::DataFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return make_struct_cmp(&T::fragmentStartingNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 20, 0), next);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return make_field_cmp(&T::fragmentsInSubmessage, next);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return make_field_cmp(&T::fragmentSize, next);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return make_field_cmp(&T::sampleSize, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "fragmentStartingNum", "fragmentsInSubmessage", "fragmentSize", "sampleSize", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      return &static_cast<const T*>(stru)->fragmentStartingNum;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return &static_cast<const T*>(stru)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return &static_cast<const T*>(stru)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return &static_cast<const T*>(stru)->sampleSize;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      static_cast<T*>(lhs)->fragmentStartingNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      static_cast<T*>(lhs)->fragmentsInSubmessage = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      static_cast<T*>(lhs)->fragmentSize = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      static_cast<T*>(lhs)->sampleSize = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return static_cast<const T*>(lhs)->fragmentsInSubmessage == static_cast<const T*>(rhs)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return static_cast<const T*>(lhs)->fragmentSize == static_cast<const T*>(rhs)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return static_cast<const T*>(lhs)->sampleSize == static_cast<const T*>(rhs)->sampleSize;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DataFragSubmessage */


/* Begin STRUCT: GapSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::GapSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.gapStart, size, padding);
  gen_find_size(stru.gapList, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.gapStart)
    && (strm << stru.gapList);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.gapStart)
    && (strm >> stru.gapList);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::GapSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::GapSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::GapSubmessage& typed = *static_cast<const OpenDDS::RTPS::GapSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.gapStart, field + 9);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.gapList, field + 8);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::GapSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return make_struct_cmp(&T::gapStart, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return make_struct_cmp(&T::gapList, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 8, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "gapStart", "gapList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      return &static_cast<const T*>(stru)->gapStart;
    }
    if (std::strcmp(field, "gapList") == 0) {
      return &static_cast<const T*>(stru)->gapList;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      static_cast<T*>(lhs)->gapStart = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapList") == 0) {
      static_cast<T*>(lhs)->gapList = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::GapSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::GapSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::GapSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::GapSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: GapSubmessage */


/* Begin STRUCT: HeartBeatSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.firstSN, size, padding);
  gen_find_size(stru.lastSN, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.firstSN)
    && (strm << stru.lastSN)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.firstSN)
    && (strm >> stru.lastSN)
    && (strm >> stru.count);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.firstSN, field + 8);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.lastSN, field + 7);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::HeartBeatSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return make_struct_cmp(&T::firstSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return make_struct_cmp(&T::lastSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "firstSN", "lastSN", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      return &static_cast<const T*>(stru)->firstSN;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      return &static_cast<const T*>(stru)->lastSN;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      static_cast<T*>(lhs)->firstSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      static_cast<T*>(lhs)->lastSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: HeartBeatSubmessage */


/* Begin STRUCT: HeartBeatFragSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.lastFragmentNum, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.lastFragmentNum)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.lastFragmentNum)
    && (strm >> stru.count);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.lastFragmentNum, field + 16);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::HeartBeatFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return make_struct_cmp(&T::lastFragmentNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "lastFragmentNum", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      return &static_cast<const T*>(stru)->lastFragmentNum;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      static_cast<T*>(lhs)->lastFragmentNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: HeartBeatFragSubmessage */


/* Begin STRUCT: InfoDestinationSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoDestinationSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru_guidPrefix);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoDestinationSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoDestinationSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoDestinationSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::InfoDestinationSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::RTPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::RTPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::RTPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoDestinationSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoDestinationSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InfoDestinationSubmessage */


/* Begin STRUCT: InfoReplySubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplySubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocatorList, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocatorList, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocatorList));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocatorList));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplySubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplySubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplySubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::InfoReplySubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocatorList", "multicastLocatorList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplySubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InfoReplySubmessage */


/* Begin STRUCT: InfoSourceSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoSourceSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.unused);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru.unused)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru.unused)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoSourceSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoSourceSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoSourceSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "unused") == 0) {
      return typed.unused;
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "unused") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'unused' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::InfoSourceSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strcmp(field, "unused") == 0) {
      return make_field_cmp(&T::unused, next);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8, 0), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unused", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unused") == 0) {
      return &static_cast<const T*>(stru)->unused;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unused") == 0) {
      static_cast<T*>(lhs)->unused = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::RTPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::RTPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::RTPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "unused") == 0) {
      return static_cast<const T*>(lhs)->unused == static_cast<const T*>(rhs)->unused;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoSourceSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoSourceSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InfoSourceSubmessage */


/* Begin STRUCT: InfoTimestampSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoTimestampSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if (!(stru.smHeader.flags & 2)) {
    gen_find_size(stru.timestamp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm << stru.timestamp));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm >> stru.timestamp));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoTimestampSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoTimestampSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoTimestampSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(&typed.timestamp, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Timestamp_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::InfoTimestampSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return make_struct_cmp(&T::timestamp, getMetaStruct<OpenDDS::RTPS::Timestamp_t>().create_qc_comparator(field + 10, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "timestamp", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      return &static_cast<const T*>(stru)->timestamp;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      static_cast<T*>(lhs)->timestamp = *static_cast<const OpenDDS::RTPS::Timestamp_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoTimestampSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoTimestampSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InfoTimestampSubmessage */


/* Begin STRUCT: PadSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::PadSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::PadSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::PadSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::PadSubmessage& typed = *static_cast<const OpenDDS::RTPS::PadSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::PadSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::PadSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::PadSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::PadSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::PadSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: PadSubmessage */


/* Begin STRUCT: NackFragSubmessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::NackFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentNumberState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentNumberState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentNumberState)
    && (strm >> stru.count);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::NackFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::NackFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::NackFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(&typed.fragmentNumberState, field + 20);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, field + 20);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumberSet*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::NackFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::RTPS::EntityId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return make_struct_cmp(&T::fragmentNumberState, getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().create_qc_comparator(field + 20, 0), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "fragmentNumberState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      return &static_cast<const T*>(stru)->fragmentNumberState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::RTPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      static_cast<T*>(lhs)->fragmentNumberState = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::NackFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::NackFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: NackFragSubmessage */


/* Begin STRUCT: InfoReplyIp4Submessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplyIp4Submessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocator, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocator, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocator));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocator));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplyIp4Submessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplyIp4Submessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplyIp4Submessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.unicastLocator, field + 15);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.multicastLocator, field + 17);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0));
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::InfoReplyIp4Submessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return make_struct_cmp(&T::unicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 15, 0), next);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return make_struct_cmp(&T::multicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 17, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocator", "multicastLocator", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      return &static_cast<const T*>(stru)->unicastLocator;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      return &static_cast<const T*>(stru)->multicastLocator;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      static_cast<T*>(lhs)->unicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      static_cast<T*>(lhs)->multicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplyIp4Submessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplyIp4Submessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: InfoReplyIp4Submessage */


/* Begin ENUM: SubmessageKind */

namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::RTPS::SubmessageKind>(temp);
    return true;
  }
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_RTPS_SubmessageKind_names[] = {
  "RESERVED_0",
  "PAD",
  "RESERVED_2",
  "RESERVED_3",
  "RESERVED_4",
  "RESERVED_5",
  "ACKNACK",
  "HEARTBEAT",
  "GAP",
  "INFO_TS",
  "RESERVED_10",
  "RESERVED_11",
  "INFO_SRC",
  "INFO_REPLY_IP4",
  "INFO_DST",
  "INFO_REPLY",
  "RESERVED_16",
  "RESERVED_17",
  "NACK_FRAG",
  "HEARTBEAT_FRAG",
  "RESERVED_20",
  "DATA",
  "DATA_FRAG"
};
}  }

#endif

/* End ENUM: SubmessageKind */


/* Begin UNION: Submessage */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Submessage& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD:
    {
      gen_find_size(uni.pad_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::ACKNACK:
    {
      gen_find_size(uni.acknack_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT:
    {
      gen_find_size(uni.heartbeat_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::GAP:
    {
      gen_find_size(uni.gap_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_TS:
    {
      gen_find_size(uni.info_ts_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_SRC:
    {
      gen_find_size(uni.info_src_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      gen_find_size(uni.info_reply_ipv4_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_DST:
    {
      gen_find_size(uni.info_dst_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY:
    {
      gen_find_size(uni.info_reply_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::NACK_FRAG:
    {
      gen_find_size(uni.nack_frag_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      gen_find_size(uni.hb_frag_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::DATA:
    {
      gen_find_size(uni.data_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::DATA_FRAG:
    {
      gen_find_size(uni.data_frag_sm(), size, padding);
      break;
    }
  default:
    {
      gen_find_size(uni.unknown_sm(), size, padding);
      break;
    }
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD:
    {
      return (strm << uni.pad_sm());
    }
  case OpenDDS::RTPS::ACKNACK:
    {
      return (strm << uni.acknack_sm());
    }
  case OpenDDS::RTPS::HEARTBEAT:
    {
      return (strm << uni.heartbeat_sm());
    }
  case OpenDDS::RTPS::GAP:
    {
      return (strm << uni.gap_sm());
    }
  case OpenDDS::RTPS::INFO_TS:
    {
      return (strm << uni.info_ts_sm());
    }
  case OpenDDS::RTPS::INFO_SRC:
    {
      return (strm << uni.info_src_sm());
    }
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      return (strm << uni.info_reply_ipv4_sm());
    }
  case OpenDDS::RTPS::INFO_DST:
    {
      return (strm << uni.info_dst_sm());
    }
  case OpenDDS::RTPS::INFO_REPLY:
    {
      return (strm << uni.info_reply_sm());
    }
  case OpenDDS::RTPS::NACK_FRAG:
    {
      return (strm << uni.nack_frag_sm());
    }
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      return (strm << uni.hb_frag_sm());
    }
  case OpenDDS::RTPS::DATA:
    {
      return (strm << uni.data_sm());
    }
  case OpenDDS::RTPS::DATA_FRAG:
    {
      return (strm << uni.data_frag_sm());
    }
  default:
    {
      return (strm << uni.unknown_sm());
    }
  }
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  // unused
  return false;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Submessage*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::RTPS::SubmessageKind disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::RTPS::PAD:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::PadSubmessage*>(0));
    break;
  case OpenDDS::RTPS::ACKNACK:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::AckNackSubmessage*>(0));
    break;
  case OpenDDS::RTPS::HEARTBEAT:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatSubmessage*>(0));
    break;
  case OpenDDS::RTPS::GAP:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GapSubmessage*>(0));
    break;
  case OpenDDS::RTPS::INFO_TS:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoTimestampSubmessage*>(0));
    break;
  case OpenDDS::RTPS::INFO_SRC:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoSourceSubmessage*>(0));
    break;
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplyIp4Submessage*>(0));
    break;
  case OpenDDS::RTPS::INFO_DST:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoDestinationSubmessage*>(0));
    break;
  case OpenDDS::RTPS::INFO_REPLY:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplySubmessage*>(0));
    break;
  case OpenDDS::RTPS::NACK_FRAG:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::NackFragSubmessage*>(0));
    break;
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatFragSubmessage*>(0));
    break;
  case OpenDDS::RTPS::DATA:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataSubmessage*>(0));
    break;
  case OpenDDS::RTPS::DATA_FRAG:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataFragSubmessage*>(0));
    break;
  default:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    break;
  }
}

}  }

#endif

/* End UNION: Submessage */


/* Begin TYPEDEF: SubmessageSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }

#endif

/* End TYPEDEF: SubmessageSeq */


/* Begin STRUCT: ParticipantMessageData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantMessageData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.participantGuid, size, padding);
  gen_find_size(stru.data, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.participantGuid)
    && (strm << stru.data);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.participantGuid)
    && (strm >> stru.data);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantMessageData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantMessageData& typed = *static_cast<const OpenDDS::RTPS::ParticipantMessageData*>(stru);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(&typed.participantGuid, field + 16);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ParticipantMessageData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return make_struct_cmp(&T::participantGuid, getMetaStruct<OpenDDS::RTPS::GUID_t>().create_qc_comparator(field + 16, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"participantGuid", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "participantGuid") == 0) {
      return &static_cast<const T*>(stru)->participantGuid;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "participantGuid") == 0) {
      static_cast<T*>(lhs)->participantGuid = *static_cast<const OpenDDS::RTPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const OpenDDS::RTPS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantMessageData>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantMessageData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ParticipantMessageData */


/* Begin TYPEDEF: LocatorSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Locator_t*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: LocatorSeq */


/* Begin STRUCT: ParticipantProxy_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.protocolVersion, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.availableBuiltinEndpoints);
  gen_find_size(stru.metatrafficUnicastLocatorList, size, padding);
  gen_find_size(stru.metatrafficMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultUnicastLocatorList, size, padding);
  gen_find_size(stru.manualLivelinessCount, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.protocolVersion)
    && (strm << stru_guidPrefix)
    && (strm << stru.vendorId)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.availableBuiltinEndpoints)
    && (strm << stru.metatrafficUnicastLocatorList)
    && (strm << stru.metatrafficMulticastLocatorList)
    && (strm << stru.defaultMulticastLocatorList)
    && (strm << stru.defaultUnicastLocatorList)
    && (strm << stru.manualLivelinessCount);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::RTPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.protocolVersion)
    && (strm >> stru_guidPrefix)
    && (strm >> stru.vendorId)
    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    && (strm >> stru.availableBuiltinEndpoints)
    && (strm >> stru.metatrafficUnicastLocatorList)
    && (strm >> stru.metatrafficMulticastLocatorList)
    && (strm >> stru.defaultMulticastLocatorList)
    && (strm >> stru.defaultUnicastLocatorList)
    && (strm >> stru.manualLivelinessCount);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantProxy_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantProxy_t& typed = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(stru);
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.protocolVersion, field + 16);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return typed.availableBuiltinEndpoints;
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.manualLivelinessCount, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GuidPrefix_t_forany*>(0));
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ParticipantProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return make_struct_cmp(&T::protocolVersion, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 16, 0), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9, 0), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return make_field_cmp(&T::availableBuiltinEndpoints, next);
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return make_struct_cmp(&T::manualLivelinessCount, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 22, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"protocolVersion", "guidPrefix", "vendorId", "expectsInlineQos", "availableBuiltinEndpoints", "metatrafficUnicastLocatorList", "metatrafficMulticastLocatorList", "defaultMulticastLocatorList", "defaultUnicastLocatorList", "manualLivelinessCount", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "protocolVersion") == 0) {
      return &static_cast<const T*>(stru)->protocolVersion;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return &static_cast<const T*>(stru)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficUnicastLocatorList;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultUnicastLocatorList;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      return &static_cast<const T*>(stru)->manualLivelinessCount;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "protocolVersion") == 0) {
      static_cast<T*>(lhs)->protocolVersion = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::RTPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::RTPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::RTPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      static_cast<T*>(lhs)->availableBuiltinEndpoints = *static_cast<const OpenDDS::RTPS::BuiltinEndpointSet_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficUnicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficMulticastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultMulticastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultUnicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      static_cast<T*>(lhs)->manualLivelinessCount = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return static_cast<const T*>(lhs)->availableBuiltinEndpoints == static_cast<const T*>(rhs)->availableBuiltinEndpoints;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ParticipantProxy_t */


/* Begin STRUCT: SPDPdiscoveredParticipantData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsParticipantData, size, padding);
  gen_find_size(stru.participantProxy, size, padding);
  gen_find_size(stru.leaseDuration, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsParticipantData)
    && (strm << stru.participantProxy)
    && (strm << stru.leaseDuration);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsParticipantData)
    && (strm >> stru.participantProxy)
    && (strm >> stru.leaseDuration);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> : MetaStruct {
  typedef OpenDDS::RTPS::SPDPdiscoveredParticipantData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SPDPdiscoveredParticipantData& typed = *static_cast<const OpenDDS::RTPS::SPDPdiscoveredParticipantData*>(stru);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(&typed.ddsParticipantData, field + 19);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(&typed.participantProxy, field + 17);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(&typed.leaseDuration, field + 14);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::ParticipantBuiltinTopicData*>(0));
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParticipantProxy_t*>(0));
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(ser, field + 14);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::SPDPdiscoveredParticipantData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return make_struct_cmp(&T::ddsParticipantData, getMetaStruct<DDS::ParticipantBuiltinTopicData>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return make_struct_cmp(&T::participantProxy, getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().create_qc_comparator(field + 17, 0), next);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return make_struct_cmp(&T::leaseDuration, getMetaStruct<OpenDDS::RTPS::Duration_t>().create_qc_comparator(field + 14, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsParticipantData", "participantProxy", "leaseDuration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      return &static_cast<const T*>(stru)->ddsParticipantData;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      return &static_cast<const T*>(stru)->participantProxy;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      return &static_cast<const T*>(stru)->leaseDuration;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      static_cast<T*>(lhs)->ddsParticipantData = *static_cast<const DDS::ParticipantBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      static_cast<T*>(lhs)->participantProxy = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      static_cast<T*>(lhs)->leaseDuration = *static_cast<const OpenDDS::RTPS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SPDPdiscoveredParticipantData>()
{
  static MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SPDPdiscoveredParticipantData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SPDPdiscoveredParticipantData */


/* Begin STRUCT: WriterProxy_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::WriterProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.remoteWriterGuid, size, padding);
  gen_find_size(stru.unicastLocatorList, size, padding);
  gen_find_size(stru.multicastLocatorList, size, padding);
  gen_find_size(stru.allLocators, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.remoteWriterGuid)
    && (strm << stru.unicastLocatorList)
    && (strm << stru.multicastLocatorList)
    && (strm << stru.allLocators);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.remoteWriterGuid)
    && (strm >> stru.unicastLocatorList)
    && (strm >> stru.multicastLocatorList)
    && (strm >> stru.allLocators);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::WriterProxy_t> : MetaStruct {
  typedef OpenDDS::RTPS::WriterProxy_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::WriterProxy_t& typed = *static_cast<const OpenDDS::RTPS::WriterProxy_t*>(stru);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(&typed.remoteWriterGuid, field + 17);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::WriterProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::WriterProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteWriterGuid, getMetaStruct<OpenDDS::RTPS::GUID_t>().create_qc_comparator(field + 17, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::WriterProxy_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteWriterGuid", "unicastLocatorList", "multicastLocatorList", "allLocators", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteWriterGuid;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::WriterProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      static_cast<T*>(lhs)->remoteWriterGuid = *static_cast<const OpenDDS::RTPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::WriterProxy_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::WriterProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::WriterProxy_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::WriterProxy_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::WriterProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::WriterProxy_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DiscoveredWriterData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsPublicationData, size, padding);
  gen_find_size(stru.writerProxy, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsPublicationData)
    && (strm << stru.writerProxy);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsPublicationData)
    && (strm >> stru.writerProxy);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DiscoveredWriterData> : MetaStruct {
  typedef OpenDDS::RTPS::DiscoveredWriterData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DiscoveredWriterData& typed = *static_cast<const OpenDDS::RTPS::DiscoveredWriterData*>(stru);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(&typed.ddsPublicationData, field + 19);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::RTPS::WriterProxy_t>().getValue(&typed.writerProxy, field + 12);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredWriterData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::PublicationBuiltinTopicData*>(0));
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::RTPS::WriterProxy_t>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::WriterProxy_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::DiscoveredWriterData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return make_struct_cmp(&T::ddsPublicationData, getMetaStruct<DDS::PublicationBuiltinTopicData>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return make_struct_cmp(&T::writerProxy, getMetaStruct<OpenDDS::RTPS::WriterProxy_t>().create_qc_comparator(field + 12, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredWriterData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsPublicationData", "writerProxy", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      return &static_cast<const T*>(stru)->ddsPublicationData;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      return &static_cast<const T*>(stru)->writerProxy;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredWriterData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      static_cast<T*>(lhs)->ddsPublicationData = *static_cast<const DDS::PublicationBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      static_cast<T*>(lhs)->writerProxy = *static_cast<const OpenDDS::RTPS::WriterProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredWriterData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredWriterData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DiscoveredWriterData>()
{
  static MetaStructImpl<OpenDDS::RTPS::DiscoveredWriterData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DiscoveredWriterData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DiscoveredWriterData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DiscoveredWriterData */


/* Begin STRUCT: ReaderProxy_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ReaderProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.remoteReaderGuid, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  gen_find_size(stru.unicastLocatorList, size, padding);
  gen_find_size(stru.multicastLocatorList, size, padding);
  gen_find_size(stru.allLocators, size, padding);
  gen_find_size(stru.associatedWriters, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.remoteReaderGuid)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.unicastLocatorList)
    && (strm << stru.multicastLocatorList)
    && (strm << stru.allLocators)
    && (strm << stru.associatedWriters);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.remoteReaderGuid)
    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    && (strm >> stru.unicastLocatorList)
    && (strm >> stru.multicastLocatorList)
    && (strm >> stru.allLocators)
    && (strm >> stru.associatedWriters);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ReaderProxy_t> : MetaStruct {
  typedef OpenDDS::RTPS::ReaderProxy_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ReaderProxy_t& typed = *static_cast<const OpenDDS::RTPS::ReaderProxy_t*>(stru);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(&typed.remoteReaderGuid, field + 17);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReaderProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUIDSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ReaderProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteReaderGuid, getMetaStruct<OpenDDS::RTPS::GUID_t>().create_qc_comparator(field + 17, 0), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReaderProxy_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteReaderGuid", "expectsInlineQos", "unicastLocatorList", "multicastLocatorList", "allLocators", "associatedWriters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteReaderGuid;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      return &static_cast<const T*>(stru)->associatedWriters;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReaderProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      static_cast<T*>(lhs)->remoteReaderGuid = *static_cast<const OpenDDS::RTPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      static_cast<T*>(lhs)->associatedWriters = *static_cast<const OpenDDS::RTPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReaderProxy_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReaderProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ReaderProxy_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ReaderProxy_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ReaderProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ReaderProxy_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DiscoveredReaderData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsSubscriptionData, size, padding);
  gen_find_size(stru.readerProxy, size, padding);
  gen_find_size(stru.contentFilterProperty, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsSubscriptionData)
    && (strm << stru.readerProxy)
    && (strm << stru.contentFilterProperty);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsSubscriptionData)
    && (strm >> stru.readerProxy)
    && (strm >> stru.contentFilterProperty);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DiscoveredReaderData> : MetaStruct {
  typedef OpenDDS::RTPS::DiscoveredReaderData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DiscoveredReaderData& typed = *static_cast<const OpenDDS::RTPS::DiscoveredReaderData*>(stru);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(&typed.ddsSubscriptionData, field + 20);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ReaderProxy_t>().getValue(&typed.readerProxy, field + 12);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ContentFilterProperty_t>().getValue(&typed.contentFilterProperty, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredReaderData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(ser, field + 20);
    } else {
      gen_skip_over(ser, static_cast<DDS::SubscriptionBuiltinTopicData*>(0));
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ReaderProxy_t>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ReaderProxy_t*>(0));
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ContentFilterProperty_t>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ContentFilterProperty_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::DiscoveredReaderData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return make_struct_cmp(&T::ddsSubscriptionData, getMetaStruct<DDS::SubscriptionBuiltinTopicData>().create_qc_comparator(field + 20, 0), next);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return make_struct_cmp(&T::readerProxy, getMetaStruct<OpenDDS::RTPS::ReaderProxy_t>().create_qc_comparator(field + 12, 0), next);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return make_struct_cmp(&T::contentFilterProperty, getMetaStruct<OpenDDS::RTPS::ContentFilterProperty_t>().create_qc_comparator(field + 22, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredReaderData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsSubscriptionData", "readerProxy", "contentFilterProperty", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      return &static_cast<const T*>(stru)->ddsSubscriptionData;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      return &static_cast<const T*>(stru)->readerProxy;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      return &static_cast<const T*>(stru)->contentFilterProperty;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredReaderData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      static_cast<T*>(lhs)->ddsSubscriptionData = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      static_cast<T*>(lhs)->readerProxy = *static_cast<const OpenDDS::RTPS::ReaderProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      static_cast<T*>(lhs)->contentFilterProperty = *static_cast<const OpenDDS::RTPS::ContentFilterProperty_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredReaderData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredReaderData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DiscoveredReaderData>()
{
  static MetaStructImpl<OpenDDS::RTPS::DiscoveredReaderData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DiscoveredReaderData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DiscoveredReaderData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: DiscoveredTopicData */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DiscoveredTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsTopicData, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsTopicData);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsTopicData);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> : MetaStruct {
  typedef OpenDDS::RTPS::DiscoveredTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DiscoveredTopicData& typed = *static_cast<const OpenDDS::RTPS::DiscoveredTopicData*>(stru);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(&typed.ddsTopicData, field + 13);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicBuiltinTopicData*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::DiscoveredTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return make_struct_cmp(&T::ddsTopicData, getMetaStruct<DDS::TopicBuiltinTopicData>().create_qc_comparator(field + 13, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsTopicData", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsTopicData") == 0) {
      return &static_cast<const T*>(stru)->ddsTopicData;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsTopicData") == 0) {
      static_cast<T*>(lhs)->ddsTopicData = *static_cast<const DDS::TopicBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DiscoveredTopicData>()
{
  static MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DiscoveredTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: DiscoveredTopicData */

/* End MODULE: RTPS */

/* End MODULE: OpenDDS */
