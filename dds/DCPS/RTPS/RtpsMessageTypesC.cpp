// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p7
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "RtpsMessageTypesC.h"
#include "tao/CDR.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "RtpsMessageTypesC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_LONGSEQ8_CS_)
#define _OPENDDS_RTPS_LONGSEQ8_CS_

OpenDDS::RTPS::LongSeq8::LongSeq8 (void)
{}

OpenDDS::RTPS::LongSeq8::LongSeq8 (
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::bounded_value_sequence<
        ::CORBA::Long,
        8
      >
    (length, buffer, release)
{}

OpenDDS::RTPS::LongSeq8::LongSeq8 (
    const LongSeq8 &seq)
  : ::TAO::bounded_value_sequence<
        ::CORBA::Long,
        8
      > (seq)
{}

OpenDDS::RTPS::LongSeq8::~LongSeq8 (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_LOCATORLIST_CS_)
#define _OPENDDS_RTPS_LOCATORLIST_CS_

OpenDDS::RTPS::LocatorList::LocatorList (void)
{}

OpenDDS::RTPS::LocatorList::LocatorList (
    ::CORBA::ULong length,
    OpenDDS::RTPS::Locator_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::bounded_value_sequence<
        Locator_t,
        8
      >
    (length, buffer, release)
{}

OpenDDS::RTPS::LocatorList::LocatorList (
    const LocatorList &seq)
  : ::TAO::bounded_value_sequence<
        Locator_t,
        8
      > (seq)
{}

OpenDDS::RTPS::LocatorList::~LocatorList (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

OpenDDS::RTPS::Submessage::Submessage (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = OpenDDS::RTPS::RESERVED_0;
}

OpenDDS::RTPS::Submessage::Submessage (const ::OpenDDS::RTPS::Submessage &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case OpenDDS::RTPS::PAD:
    {
      this->u_.pad_sm_ = u.u_.pad_sm_;
    }
    break;
    case OpenDDS::RTPS::ACKNACK:
    {
      if (u.u_.acknack_sm_ == 0)
        {
          this->u_.acknack_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.acknack_sm_,
              OpenDDS::RTPS::AckNackSubmessage (*u.u_.acknack_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT:
    {
      this->u_.heartbeat_sm_ = u.u_.heartbeat_sm_;
    }
    break;
    case OpenDDS::RTPS::GAP:
    {
      if (u.u_.gap_sm_ == 0)
        {
          this->u_.gap_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.gap_sm_,
              OpenDDS::RTPS::GapSubmessage (*u.u_.gap_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::INFO_TS:
    {
      this->u_.info_ts_sm_ = u.u_.info_ts_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_SRC:
    {
      this->u_.info_src_sm_ = u.u_.info_src_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      this->u_.info_reply_ipv4_sm_ = u.u_.info_reply_ipv4_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_DST:
    {
      this->u_.info_dst_sm_ = u.u_.info_dst_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY:
    {
      if (u.u_.info_reply_sm_ == 0)
        {
          this->u_.info_reply_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.info_reply_sm_,
              OpenDDS::RTPS::InfoReplySubmessage (*u.u_.info_reply_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::NACK_FRAG:
    {
      if (u.u_.nack_frag_sm_ == 0)
        {
          this->u_.nack_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.nack_frag_sm_,
              OpenDDS::RTPS::NackFragSubmessage (*u.u_.nack_frag_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      this->u_.hb_frag_sm_ = u.u_.hb_frag_sm_;
    }
    break;
    case OpenDDS::RTPS::DATA:
    {
      if (u.u_.data_sm_ == 0)
        {
          this->u_.data_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.data_sm_,
              OpenDDS::RTPS::DataSubmessage (*u.u_.data_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::DATA_FRAG:
    {
      if (u.u_.data_frag_sm_ == 0)
        {
          this->u_.data_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.data_frag_sm_,
              OpenDDS::RTPS::DataFragSubmessage (*u.u_.data_frag_sm_)
            );
        }
    }
    break;
    default:
    {
      this->u_.unknown_sm_ = u.u_.unknown_sm_;
    }
    break;
  }
}

OpenDDS::RTPS::Submessage::~Submessage (void)
{
  // Finalize.
  this->_reset ();
}

OpenDDS::RTPS::Submessage &
OpenDDS::RTPS::Submessage::operator= (const ::OpenDDS::RTPS::Submessage &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case OpenDDS::RTPS::PAD:
    {
      this->u_.pad_sm_ = u.u_.pad_sm_;
    }
    break;
    case OpenDDS::RTPS::ACKNACK:
    {
      if (u.u_.acknack_sm_ == 0)
        {
          this->u_.acknack_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.acknack_sm_,
              OpenDDS::RTPS::AckNackSubmessage (*u.u_.acknack_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT:
    {
      this->u_.heartbeat_sm_ = u.u_.heartbeat_sm_;
    }
    break;
    case OpenDDS::RTPS::GAP:
    {
      if (u.u_.gap_sm_ == 0)
        {
          this->u_.gap_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.gap_sm_,
              OpenDDS::RTPS::GapSubmessage (*u.u_.gap_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::INFO_TS:
    {
      this->u_.info_ts_sm_ = u.u_.info_ts_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_SRC:
    {
      this->u_.info_src_sm_ = u.u_.info_src_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      this->u_.info_reply_ipv4_sm_ = u.u_.info_reply_ipv4_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_DST:
    {
      this->u_.info_dst_sm_ = u.u_.info_dst_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY:
    {
      if (u.u_.info_reply_sm_ == 0)
        {
          this->u_.info_reply_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.info_reply_sm_,
              OpenDDS::RTPS::InfoReplySubmessage (*u.u_.info_reply_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::NACK_FRAG:
    {
      if (u.u_.nack_frag_sm_ == 0)
        {
          this->u_.nack_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.nack_frag_sm_,
              OpenDDS::RTPS::NackFragSubmessage (*u.u_.nack_frag_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      this->u_.hb_frag_sm_ = u.u_.hb_frag_sm_;
    }
    break;
    case OpenDDS::RTPS::DATA:
    {
      if (u.u_.data_sm_ == 0)
        {
          this->u_.data_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.data_sm_,
              OpenDDS::RTPS::DataSubmessage (*u.u_.data_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::DATA_FRAG:
    {
      if (u.u_.data_frag_sm_ == 0)
        {
          this->u_.data_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.data_frag_sm_,
              OpenDDS::RTPS::DataFragSubmessage (*u.u_.data_frag_sm_),
              *this
            );
        }
    }
    break;
    default:
    {
      this->u_.unknown_sm_ = u.u_.unknown_sm_;
    }
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void OpenDDS::RTPS::Submessage::_reset (void)
{
  switch (this->disc_)
  {
    
    case OpenDDS::RTPS::PAD:
      break;
    case OpenDDS::RTPS::ACKNACK:
      delete this->u_.acknack_sm_;
      this->u_.acknack_sm_ = 0;
      break;
    case OpenDDS::RTPS::HEARTBEAT:
      break;
    case OpenDDS::RTPS::GAP:
      delete this->u_.gap_sm_;
      this->u_.gap_sm_ = 0;
      break;
    case OpenDDS::RTPS::INFO_TS:
      break;
    case OpenDDS::RTPS::INFO_SRC:
      break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      break;
    case OpenDDS::RTPS::INFO_DST:
      break;
    case OpenDDS::RTPS::INFO_REPLY:
      delete this->u_.info_reply_sm_;
      this->u_.info_reply_sm_ = 0;
      break;
    case OpenDDS::RTPS::NACK_FRAG:
      delete this->u_.nack_frag_sm_;
      this->u_.nack_frag_sm_ = 0;
      break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      break;
    case OpenDDS::RTPS::DATA:
      delete this->u_.data_sm_;
      this->u_.data_sm_ = 0;
      break;
    case OpenDDS::RTPS::DATA_FRAG:
      delete this->u_.data_frag_sm_;
      this->u_.data_frag_sm_ = 0;
      break;
    default:
      break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_SUBMESSAGESEQ_CS_)
#define _OPENDDS_RTPS_SUBMESSAGESEQ_CS_

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (void)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Submessage
      > (max)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Submessage * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Submessage
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    const SubmessageSeq &seq)
  : ::TAO::unbounded_value_sequence<
        Submessage
      > (seq)
{}

OpenDDS::RTPS::SubmessageSeq::~SubmessageSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_LOCATORSEQ_CS_)
#define _OPENDDS_RTPS_LOCATORSEQ_CS_

OpenDDS::RTPS::LocatorSeq::LocatorSeq (void)
{}

OpenDDS::RTPS::LocatorSeq::LocatorSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Locator_t
      > (max)
{}

OpenDDS::RTPS::LocatorSeq::LocatorSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Locator_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Locator_t
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::LocatorSeq::LocatorSeq (
    const LocatorSeq &seq)
  : ::TAO::unbounded_value_sequence<
        Locator_t
      > (seq)
{}

OpenDDS::RTPS::LocatorSeq::~LocatorSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LongSeq8 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LongSeq8 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SequenceNumberSet &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.bitmapBase) &&
    (strm << _tao_aggregate.numBits) &&
    (strm << _tao_aggregate.bitmap);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SequenceNumberSet &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.bitmapBase) &&
    (strm >> _tao_aggregate.numBits) &&
    (strm >> _tao_aggregate.bitmap);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FragmentNumberSet &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.bitmapBase) &&
    (strm << _tao_aggregate.numBits) &&
    (strm << _tao_aggregate.bitmap);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FragmentNumberSet &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.bitmapBase) &&
    (strm >> _tao_aggregate.numBits) &&
    (strm >> _tao_aggregate.bitmap);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LocatorList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LocatorList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Header &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_prefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.prefix
        )
    );
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate_prefix) &&
    (strm << _tao_aggregate.version) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Header &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_prefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.prefix
        )
    );
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate_prefix) &&
    (strm >> _tao_aggregate.version) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SubmessageHeader &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.submessageId)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags)) &&
    (strm << _tao_aggregate.submessageLength);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SubmessageHeader &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.submessageId)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags)) &&
    (strm >> _tao_aggregate.submessageLength);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::AckNackSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.readerSNState) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::AckNackSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.readerSNState) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DataSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.extraFlags) &&
    (strm << _tao_aggregate.octetsToInlineQos) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.inlineQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DataSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.extraFlags) &&
    (strm >> _tao_aggregate.octetsToInlineQos) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.inlineQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DataFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.extraFlags) &&
    (strm << _tao_aggregate.octetsToInlineQos) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.fragmentStartingNum) &&
    (strm << _tao_aggregate.fragmentsInSubmessage) &&
    (strm << _tao_aggregate.fragmentSize) &&
    (strm << _tao_aggregate.sampleSize) &&
    (strm << _tao_aggregate.inlineQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DataFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.extraFlags) &&
    (strm >> _tao_aggregate.octetsToInlineQos) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.fragmentStartingNum) &&
    (strm >> _tao_aggregate.fragmentsInSubmessage) &&
    (strm >> _tao_aggregate.fragmentSize) &&
    (strm >> _tao_aggregate.sampleSize) &&
    (strm >> _tao_aggregate.inlineQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::GapSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.gapStart) &&
    (strm << _tao_aggregate.gapList);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::GapSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.gapStart) &&
    (strm >> _tao_aggregate.gapList);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::HeartBeatSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.firstSN) &&
    (strm << _tao_aggregate.lastSN) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::HeartBeatSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.firstSN) &&
    (strm >> _tao_aggregate.lastSN) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::HeartBeatFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.lastFragmentNum) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::HeartBeatFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.lastFragmentNum) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoDestinationSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoDestinationSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoReplySubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unicastLocatorList) &&
    (strm << _tao_aggregate.multicastLocatorList);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoReplySubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unicastLocatorList) &&
    (strm >> _tao_aggregate.multicastLocatorList);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoSourceSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unused) &&
    (strm << _tao_aggregate.version) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoSourceSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unused) &&
    (strm >> _tao_aggregate.version) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoTimestampSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.timestamp);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoTimestampSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.timestamp);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::PadSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::PadSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::NackFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.fragmentNumberState) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::NackFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.fragmentNumberState) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoReplyIp4Submessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unicastLocator) &&
    (strm << _tao_aggregate.multicastLocator);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoReplyIp4Submessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unicastLocator) &&
    (strm >> _tao_aggregate.multicastLocator);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, OpenDDS::RTPS::SubmessageKind _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, OpenDDS::RTPS::SubmessageKind & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<OpenDDS::RTPS::SubmessageKind> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Submessage &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case OpenDDS::RTPS::PAD:
      {
        result = strm << _tao_union.pad_sm ();
      }
      break;
    case OpenDDS::RTPS::ACKNACK:
      {
        result = strm << _tao_union.acknack_sm ();
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT:
      {
        result = strm << _tao_union.heartbeat_sm ();
      }
      break;
    case OpenDDS::RTPS::GAP:
      {
        result = strm << _tao_union.gap_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_TS:
      {
        result = strm << _tao_union.info_ts_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_SRC:
      {
        result = strm << _tao_union.info_src_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      {
        result = strm << _tao_union.info_reply_ipv4_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_DST:
      {
        result = strm << _tao_union.info_dst_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY:
      {
        result = strm << _tao_union.info_reply_sm ();
      }
      break;
    case OpenDDS::RTPS::NACK_FRAG:
      {
        result = strm << _tao_union.nack_frag_sm ();
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      {
        result = strm << _tao_union.hb_frag_sm ();
      }
      break;
    case OpenDDS::RTPS::DATA:
      {
        result = strm << _tao_union.data_sm ();
      }
      break;
    case OpenDDS::RTPS::DATA_FRAG:
      {
        result = strm << _tao_union.data_frag_sm ();
      }
      break;
    default:
      {
        result = strm << _tao_union.unknown_sm ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Submessage &_tao_union
  )
{
  OpenDDS::RTPS::SubmessageKind _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case OpenDDS::RTPS::PAD:
      {
        OpenDDS::RTPS::PadSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.pad_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::ACKNACK:
      {
        OpenDDS::RTPS::AckNackSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.acknack_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT:
      {
        OpenDDS::RTPS::HeartBeatSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.heartbeat_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::GAP:
      {
        OpenDDS::RTPS::GapSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.gap_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_TS:
      {
        OpenDDS::RTPS::InfoTimestampSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_ts_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_SRC:
      {
        OpenDDS::RTPS::InfoSourceSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_src_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      {
        OpenDDS::RTPS::InfoReplyIp4Submessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_reply_ipv4_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_DST:
      {
        OpenDDS::RTPS::InfoDestinationSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_dst_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY:
      {
        OpenDDS::RTPS::InfoReplySubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_reply_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::NACK_FRAG:
      {
        OpenDDS::RTPS::NackFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.nack_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      {
        OpenDDS::RTPS::HeartBeatFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.hb_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::DATA:
      {
        OpenDDS::RTPS::DataSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.data_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::DATA_FRAG:
      {
        OpenDDS::RTPS::DataFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.data_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        OpenDDS::RTPS::SubmessageHeader _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.unknown_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SubmessageSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SubmessageSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParticipantMessageData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.participantGuid) &&
    (strm << _tao_aggregate.data);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParticipantMessageData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.participantGuid) &&
    (strm >> _tao_aggregate.data);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_LocatorSeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_LocatorSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LocatorSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LocatorSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_OpenDDS_RTPS_LocatorSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParticipantProxy_t &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.protocolVersion) &&
    (strm << _tao_aggregate_guidPrefix) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm << _tao_aggregate.availableBuiltinEndpoints) &&
    (strm << _tao_aggregate.metatrafficUnicastLocatorList) &&
    (strm << _tao_aggregate.metatrafficMulticastLocatorList) &&
    (strm << _tao_aggregate.defaultMulticastLocatorList) &&
    (strm << _tao_aggregate.defaultUnicastLocatorList) &&
    (strm << _tao_aggregate.manualLivelinessCount);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParticipantProxy_t &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.protocolVersion) &&
    (strm >> _tao_aggregate_guidPrefix) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm >> _tao_aggregate.availableBuiltinEndpoints) &&
    (strm >> _tao_aggregate.metatrafficUnicastLocatorList) &&
    (strm >> _tao_aggregate.metatrafficMulticastLocatorList) &&
    (strm >> _tao_aggregate.defaultMulticastLocatorList) &&
    (strm >> _tao_aggregate.defaultUnicastLocatorList) &&
    (strm >> _tao_aggregate.manualLivelinessCount);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SPDPdiscoveredParticipantData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsParticipantData) &&
    (strm << _tao_aggregate.participantProxy) &&
    (strm << _tao_aggregate.leaseDuration);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SPDPdiscoveredParticipantData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsParticipantData) &&
    (strm >> _tao_aggregate.participantProxy) &&
    (strm >> _tao_aggregate.leaseDuration);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::WriterProxy_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.remoteWriterGuid) &&
    (strm << _tao_aggregate.unicastLocatorList) &&
    (strm << _tao_aggregate.multicastLocatorList) &&
    (strm << _tao_aggregate.allLocators);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::WriterProxy_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.remoteWriterGuid) &&
    (strm >> _tao_aggregate.unicastLocatorList) &&
    (strm >> _tao_aggregate.multicastLocatorList) &&
    (strm >> _tao_aggregate.allLocators);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DiscoveredWriterData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsPublicationData) &&
    (strm << _tao_aggregate.writerProxy);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DiscoveredWriterData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsPublicationData) &&
    (strm >> _tao_aggregate.writerProxy);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ReaderProxy_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.remoteReaderGuid) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm << _tao_aggregate.unicastLocatorList) &&
    (strm << _tao_aggregate.multicastLocatorList) &&
    (strm << _tao_aggregate.allLocators) &&
    (strm << _tao_aggregate.associatedWriters);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ReaderProxy_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.remoteReaderGuid) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm >> _tao_aggregate.unicastLocatorList) &&
    (strm >> _tao_aggregate.multicastLocatorList) &&
    (strm >> _tao_aggregate.allLocators) &&
    (strm >> _tao_aggregate.associatedWriters);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DiscoveredReaderData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsSubscriptionData) &&
    (strm << _tao_aggregate.readerProxy) &&
    (strm << _tao_aggregate.contentFilterProperty);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DiscoveredReaderData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsSubscriptionData) &&
    (strm >> _tao_aggregate.readerProxy) &&
    (strm >> _tao_aggregate.contentFilterProperty);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DiscoveredTopicData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsTopicData);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DiscoveredTopicData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsTopicData);
}

TAO_END_VERSIONED_NAMESPACE_DECL



