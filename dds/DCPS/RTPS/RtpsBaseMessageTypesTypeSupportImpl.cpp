/* Generated by ../../../bin/opendds_idl version 3.6 (ACE version 6.2a_p7) running on input file RtpsBaseMessageTypes.idl*/
#include "RtpsBaseMessageTypesTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "./../../DdsDcpsGuidTypeSupportImpl.h"
#include "./../../DdsDcpsInfoUtilsTypeSupportImpl.h"
#include "dds/DdsDcpsInfrastructureTypeSupportImpl.h"


/* Begin MODULE: OpenDDS */



/* Begin MODULE: RTPS */



/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityId_t */


/* End TYPEDEF: EntityId_t */


/* Begin TYPEDEF: GUID_t */


/* End TYPEDEF: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin STRUCT: Time_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Time_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.seconds);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.fraction);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.seconds)
    && (strm >> stru.fraction);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Time_t> : MetaStruct {
  typedef OpenDDS::RTPS::Time_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Time_t& typed = *static_cast<const OpenDDS::RTPS::Time_t*>(stru);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "fraction") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::Time_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Time_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Time_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Time_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Time_t */


/* Begin TYPEDEF: Timestamp_t */


/* End TYPEDEF: Timestamp_t */


/* Begin TYPEDEF: Duration_t */


/* End TYPEDEF: Duration_t */


/* Begin TYPEDEF: OctetArray2 */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 2 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 2);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 2);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(2, 1);
}

}  }

#endif

/* End TYPEDEF: OctetArray2 */


/* Begin STRUCT: VendorId_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::VendorId_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  gen_find_size(stru_vendorId, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm << stru_vendorId);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm >> stru_vendorId);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::VendorId_t> : MetaStruct {
  typedef OpenDDS::RTPS::VendorId_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::VendorId_t& typed = *static_cast<const OpenDDS::RTPS::VendorId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray2_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::VendorId_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"vendorId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "vendorId") == 0) {
      OpenDDS::RTPS::OctetArray2* lhsArr = &static_cast<T*>(lhs)->vendorId;
      const OpenDDS::RTPS::OctetArray2* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray2*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::VendorId_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::VendorId_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::VendorId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::VendorId_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: VendorId_t */


/* Begin STRUCT: SequenceNumber_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.high);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.low);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.high)
    && (strm << stru.low);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.high)
    && (strm >> stru.low);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumber_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumber_t& typed = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(stru);
    if (std::strcmp(field, "high") == 0) {
      return typed.high;
    }
    if (std::strcmp(field, "low") == 0) {
      return typed.low;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'high' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "low") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'low' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::SequenceNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "high") == 0) {
      return make_field_cmp(&T::high, next);
    }
    if (std::strcmp(field, "low") == 0) {
      return make_field_cmp(&T::low, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"high", "low", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      return &static_cast<const T*>(stru)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return &static_cast<const T*>(stru)->low;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "high") == 0) {
      static_cast<T*>(lhs)->high = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "low") == 0) {
      static_cast<T*>(lhs)->low = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "high") == 0) {
      return static_cast<const T*>(lhs)->high == static_cast<const T*>(rhs)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return static_cast<const T*>(lhs)->low == static_cast<const T*>(rhs)->low;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: SequenceNumber_t */


/* Begin STRUCT: FragmentNumber_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumber_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumber_t& typed = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::FragmentNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: FragmentNumber_t */


/* Begin TYPEDEF: OctetArray16 */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray16_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 16 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 16);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 16);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray16_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(16, 1);
}

}  }

#endif

/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: Locator_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Locator_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray16_forany stru_address(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.address));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.kind);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.port);
  gen_find_size(stru_address, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray16_forany stru_address(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.address));
  return (strm << stru.kind)
    && (strm << stru.port)
    && (strm << stru_address);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray16_forany stru_address(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.address));
  return (strm >> stru.kind)
    && (strm >> stru.port)
    && (strm >> stru_address);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Locator_t> : MetaStruct {
  typedef OpenDDS::RTPS::Locator_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Locator_t& typed = *static_cast<const OpenDDS::RTPS::Locator_t*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return typed.kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Locator_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "port") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray16_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::Locator_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Locator_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "port", "address", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Locator_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "address") == 0) {
      OpenDDS::RTPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->address;
      const OpenDDS::RTPS::OctetArray16* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Locator_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Locator_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Locator_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Locator_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Locator_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Locator_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Locator_t */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: LocatorUDPv4_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorUDPv4_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.address);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.port);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.address)
    && (strm << stru.port);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.address)
    && (strm >> stru.port);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> : MetaStruct {
  typedef OpenDDS::RTPS::LocatorUDPv4_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::LocatorUDPv4_t& typed = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(stru);
    if (std::strcmp(field, "address") == 0) {
      return typed.address;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "port") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::LocatorUDPv4_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::address, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"address", "port", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->address = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->address == static_cast<const T*>(rhs)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorUDPv4_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: LocatorUDPv4_t */


/* Begin STRUCT: TopicKind_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::TopicKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::TopicKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::TopicKind_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::TopicKind_t& typed = *static_cast<const OpenDDS::RTPS::TopicKind_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::TopicKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::TopicKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::TopicKind_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::TopicKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::TopicKind_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: TopicKind_t */


/* Begin CONST: NO_KEY */


/* End CONST: NO_KEY */


/* Begin CONST: WITH_KEY */


/* End CONST: WITH_KEY */


/* Begin STRUCT: ReliabilityKind_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ReliabilityKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::ReliabilityKind_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ReliabilityKind_t& typed = *static_cast<const OpenDDS::RTPS::ReliabilityKind_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ReliabilityKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ReliabilityKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ReliabilityKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ReliabilityKind_t */


/* Begin CONST: BEST_EFFORT */


/* End CONST: BEST_EFFORT */


/* Begin CONST: RELIABLE */


/* End CONST: RELIABLE */


/* Begin STRUCT: Count_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Count_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Count_t> : MetaStruct {
  typedef OpenDDS::RTPS::Count_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Count_t& typed = *static_cast<const OpenDDS::RTPS::Count_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::Count_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Count_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Count_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Count_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Count_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Count_t */


/* Begin STRUCT: ProtocolVersion_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ProtocolVersion_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.major));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.minor));
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.major))
    && (strm << ACE_OutputCDR::from_octet(stru.minor));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.major))
    && (strm >> ACE_InputCDR::to_octet(stru.minor));
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> : MetaStruct {
  typedef OpenDDS::RTPS::ProtocolVersion_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ProtocolVersion_t& typed = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(stru);
    if (std::strcmp(field, "major") == 0) {
      return typed.major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return typed.minor;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'major' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "minor") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'minor' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ProtocolVersion_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "major") == 0) {
      return make_field_cmp(&T::major, next);
    }
    if (std::strcmp(field, "minor") == 0) {
      return make_field_cmp(&T::minor, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"major", "minor", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      return &static_cast<const T*>(stru)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return &static_cast<const T*>(stru)->minor;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "major") == 0) {
      static_cast<T*>(lhs)->major = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minor") == 0) {
      static_cast<T*>(lhs)->minor = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "major") == 0) {
      return static_cast<const T*>(lhs)->major == static_cast<const T*>(rhs)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return static_cast<const T*>(lhs)->minor == static_cast<const T*>(rhs)->minor;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ProtocolVersion_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ProtocolVersion_t */


/* Begin STRUCT: KeyHash_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::KeyHash_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray16_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray16_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray16_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray16_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::KeyHash_t> : MetaStruct {
  typedef OpenDDS::RTPS::KeyHash_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::KeyHash_t& typed = *static_cast<const OpenDDS::RTPS::KeyHash_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray16_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::KeyHash_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::RTPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::RTPS::OctetArray16* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::KeyHash_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::KeyHash_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::KeyHash_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::KeyHash_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: KeyHash_t */


/* Begin TYPEDEF: OctetArray4 */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray4_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 4 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 4);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray4_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(4, 1);
}

}  }

#endif

/* End TYPEDEF: OctetArray4 */


/* Begin STRUCT: StatusInfo_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::StatusInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::StatusInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::StatusInfo_t& typed = *static_cast<const OpenDDS::RTPS::StatusInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::StatusInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::StatusInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::StatusInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::StatusInfo_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: StatusInfo_t */


/* Begin TYPEDEF: String256 */


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ContentFilterProperty_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.contentFilteredTopicName) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.relatedTopicName) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterClassName) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterExpression) + 1;
  gen_find_size(stru.expressionParameters, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.contentFilteredTopicName)
    && (strm << stru.relatedTopicName)
    && (strm << stru.filterClassName)
    && (strm << stru.filterExpression)
    && (strm << stru.expressionParameters);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.contentFilteredTopicName.out())
    && (strm >> stru.relatedTopicName.out())
    && (strm >> stru.filterClassName.out())
    && (strm >> stru.filterExpression.out())
    && (strm >> stru.expressionParameters);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ContentFilterProperty_t> : MetaStruct {
  typedef OpenDDS::RTPS::ContentFilterProperty_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ContentFilterProperty_t& typed = *static_cast<const OpenDDS::RTPS::ContentFilterProperty_t*>(stru);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return typed.contentFilteredTopicName.in();
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return typed.relatedTopicName.in();
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return typed.filterClassName.in();
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterProperty_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'contentFilteredTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'contentFilteredTopicName' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'relatedTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'relatedTopicName' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::StringSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ContentFilterProperty_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return make_field_cmp(&T::contentFilteredTopicName, next);
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return make_field_cmp(&T::relatedTopicName, next);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return make_field_cmp(&T::filterClassName, next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterProperty_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"contentFilteredTopicName", "relatedTopicName", "filterClassName", "filterExpression", "expressionParameters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return &static_cast<const T*>(stru)->contentFilteredTopicName;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return &static_cast<const T*>(stru)->relatedTopicName;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return &static_cast<const T*>(stru)->filterClassName;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      return &static_cast<const T*>(stru)->expressionParameters;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterProperty_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      static_cast<T*>(lhs)->contentFilteredTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      static_cast<T*>(lhs)->relatedTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      static_cast<T*>(lhs)->expressionParameters = *static_cast<const OpenDDS::RTPS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterProperty_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->contentFilteredTopicName, static_cast<const T*>(rhs)->contentFilteredTopicName);
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relatedTopicName, static_cast<const T*>(rhs)->relatedTopicName);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName, static_cast<const T*>(rhs)->filterClassName);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression, static_cast<const T*>(rhs)->filterExpression);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterProperty_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ContentFilterProperty_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ContentFilterProperty_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ContentFilterProperty_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ContentFilterProperty_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ContentFilterProperty_t */


/* Begin TYPEDEF: FilterResult_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterResult_t& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterResult_t*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }

#endif

/* End TYPEDEF: FilterResult_t */


/* Begin TYPEDEF: FilterSignature_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignature_t_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 4 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 4);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignature_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(4, 4);
}

}  }

#endif

/* End TYPEDEF: FilterSignature_t */


/* Begin TYPEDEF: FilterSignatureSeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignatureSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp = OpenDDS::RTPS::FilterSignature_t_alloc();
    OpenDDS::RTPS::FilterSignature_t_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    OpenDDS::RTPS::FilterSignature_t_copy(seq[i], tmp.in());
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignatureSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignature_t_forany*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: FilterSignatureSeq */


/* Begin STRUCT: ContentFilterInfo_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ContentFilterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.filterResult, size, padding);
  gen_find_size(stru.filterSignatures, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.filterResult)
    && (strm << stru.filterSignatures);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.filterResult)
    && (strm >> stru.filterSignatures);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::ContentFilterInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ContentFilterInfo_t& typed = *static_cast<const OpenDDS::RTPS::ContentFilterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterResult_t*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignatureSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::ContentFilterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"filterResult", "filterSignatures", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "filterResult") == 0) {
      return &static_cast<const T*>(stru)->filterResult;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      return &static_cast<const T*>(stru)->filterSignatures;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "filterResult") == 0) {
      static_cast<T*>(lhs)->filterResult = *static_cast<const OpenDDS::RTPS::FilterResult_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      static_cast<T*>(lhs)->filterSignatures = *static_cast<const OpenDDS::RTPS::FilterSignatureSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ContentFilterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ContentFilterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: ContentFilterInfo_t */


/* Begin STRUCT: Property_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Property_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.value) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name)
    && (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out())
    && (strm >> stru.value.out());
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Property_t> : MetaStruct {
  typedef OpenDDS::RTPS::Property_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Property_t& typed = *static_cast<const OpenDDS::RTPS::Property_t*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "value") == 0) {
      return typed.value.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "value") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'value' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::Property_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name, static_cast<const T*>(rhs)->name);
    }
    if (std::strcmp(field, "value") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->value, static_cast<const T*>(rhs)->value);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Property_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Property_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Property_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Property_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::PropertySeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::PropertySeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Property_t*>(0));
  }
}

}  }

#endif

/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: EntityName_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::EntityName_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out());
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::EntityName_t> : MetaStruct {
  typedef OpenDDS::RTPS::EntityName_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::EntityName_t& typed = *static_cast<const OpenDDS::RTPS::EntityName_t*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::EntityName_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name, static_cast<const T*>(rhs)->name);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::EntityName_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::EntityName_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::EntityName_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::EntityName_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: EntityName_t */


/* Begin TYPEDEF: BuiltinEndpointSet_t */


/* End TYPEDEF: BuiltinEndpointSet_t */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin TYPEDEF: ParameterList */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParameterList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    size_t param_size = 0, param_padding = 0;
    gen_find_size(seq[i], param_size, param_padding);
    size += param_size + param_padding;
    if (size % 4) {
      size += 4 - (size % 4);
    }
  }
  size += 4; /* PID_SENTINEL */
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return (strm << OpenDDS::RTPS::PID_SENTINEL)
    && (strm << OpenDDS::RTPS::PID_PAD);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  while (true) {
    const CORBA::ULong len = seq.length();
    seq.length(len + 1);
    if (!(strm >> seq[len])) {
      return false;
    }
    if (seq[len]._d() == OpenDDS::RTPS::PID_SENTINEL) {
      seq.length(len);
      return true;
    }
  }
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParameterList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }

#endif

/* End TYPEDEF: ParameterList */


/* Begin STRUCT: OriginalWriterInfo_t */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OriginalWriterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.originalWriterGUID, size, padding);
  gen_find_size(stru.originalWriterSN, size, padding);
  gen_find_size(stru.originalWriterQos, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.originalWriterGUID)
    && (strm << stru.originalWriterSN)
    && (strm << stru.originalWriterQos);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.originalWriterGUID)
    && (strm >> stru.originalWriterSN)
    && (strm >> stru.originalWriterQos);
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::OriginalWriterInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::OriginalWriterInfo_t& typed = *static_cast<const OpenDDS::RTPS::OriginalWriterInfo_t*>(stru);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(&typed.originalWriterGUID, field + 19);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.originalWriterSN, field + 17);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::RTPS::GUID_t>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + std::string(field) + " not valid for struct OpenDDS::RTPS::OriginalWriterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return make_struct_cmp(&T::originalWriterGUID, getMetaStruct<OpenDDS::RTPS::GUID_t>().create_qc_comparator(field + 19, 0), next);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return make_struct_cmp(&T::originalWriterSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 17, 0), next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"originalWriterGUID", "originalWriterSN", "originalWriterQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      return &static_cast<const T*>(stru)->originalWriterGUID;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      return &static_cast<const T*>(stru)->originalWriterSN;
    }
    if (std::strcmp(field, "originalWriterQos") == 0) {
      return &static_cast<const T*>(stru)->originalWriterQos;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      static_cast<T*>(lhs)->originalWriterGUID = *static_cast<const OpenDDS::RTPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      static_cast<T*>(lhs)->originalWriterSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterQos") == 0) {
      static_cast<T*>(lhs)->originalWriterQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::OriginalWriterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OriginalWriterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t>().getValue(ser, "");
}

}  }

#endif

/* End STRUCT: OriginalWriterInfo_t */


/* Begin TYPEDEF: ParameterId_t */


/* End TYPEDEF: ParameterId_t */


/* Begin CONST: PID_PAD */


/* End CONST: PID_PAD */


/* Begin CONST: PID_SENTINEL */


/* End CONST: PID_SENTINEL */


/* Begin CONST: PID_USER_DATA */


/* End CONST: PID_USER_DATA */


/* Begin CONST: PID_TOPIC_NAME */


/* End CONST: PID_TOPIC_NAME */


/* Begin CONST: PID_TYPE_NAME */


/* End CONST: PID_TYPE_NAME */


/* Begin CONST: PID_GROUP_DATA */


/* End CONST: PID_GROUP_DATA */


/* Begin CONST: PID_TOPIC_DATA */


/* End CONST: PID_TOPIC_DATA */


/* Begin CONST: PID_DURABILITY */


/* End CONST: PID_DURABILITY */


/* Begin CONST: PID_DURABILITY_SERVICE */


/* End CONST: PID_DURABILITY_SERVICE */


/* Begin CONST: PID_DEADLINE */


/* End CONST: PID_DEADLINE */


/* Begin CONST: PID_LATENCY_BUDGET */


/* End CONST: PID_LATENCY_BUDGET */


/* Begin CONST: PID_LIVELINESS */


/* End CONST: PID_LIVELINESS */


/* Begin CONST: PID_RELIABILITY */


/* End CONST: PID_RELIABILITY */


/* Begin CONST: PID_LIFESPAN */


/* End CONST: PID_LIFESPAN */


/* Begin CONST: PID_DESTINATION_ORDER */


/* End CONST: PID_DESTINATION_ORDER */


/* Begin CONST: PID_HISTORY */


/* End CONST: PID_HISTORY */


/* Begin CONST: PID_RESOURCE_LIMITS */


/* End CONST: PID_RESOURCE_LIMITS */


/* Begin CONST: PID_OWNERSHIP */


/* End CONST: PID_OWNERSHIP */


/* Begin CONST: PID_OWNERSHIP_STRENGTH */


/* End CONST: PID_OWNERSHIP_STRENGTH */


/* Begin CONST: PID_PRESENTATION */


/* End CONST: PID_PRESENTATION */


/* Begin CONST: PID_PARTITION */


/* End CONST: PID_PARTITION */


/* Begin CONST: PID_TIME_BASED_FILTER */


/* End CONST: PID_TIME_BASED_FILTER */


/* Begin CONST: PID_TRANSPORT_PRIORITY */


/* End CONST: PID_TRANSPORT_PRIORITY */


/* Begin CONST: PID_PROTOCOL_VERSION */


/* End CONST: PID_PROTOCOL_VERSION */


/* Begin CONST: PID_VENDORID */


/* End CONST: PID_VENDORID */


/* Begin CONST: PID_UNICAST_LOCATOR */


/* End CONST: PID_UNICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_LOCATOR */


/* End CONST: PID_MULTICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_IPADDRESS */


/* End CONST: PID_MULTICAST_IPADDRESS */


/* Begin CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* End CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* End CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_UNICAST_IPADDRESS */


/* End CONST: PID_DEFAULT_UNICAST_IPADDRESS */


/* Begin CONST: PID_DEFAULT_UNICAST_PORT */


/* End CONST: PID_DEFAULT_UNICAST_PORT */


/* Begin CONST: PID_METATRAFFIC_UNICAST_IPADDRESS */


/* End CONST: PID_METATRAFFIC_UNICAST_IPADDRESS */


/* Begin CONST: PID_METATRAFFIC_UNICAST_PORT */


/* End CONST: PID_METATRAFFIC_UNICAST_PORT */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_IPADDRESS */


/* End CONST: PID_METATRAFFIC_MULTICAST_IPADDRESS */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_PORT */


/* End CONST: PID_METATRAFFIC_MULTICAST_PORT */


/* Begin CONST: PID_EXPECTS_INLINE_QOS */


/* End CONST: PID_EXPECTS_INLINE_QOS */


/* Begin CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* End CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* Begin CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* End CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* Begin CONST: PID_PARTICIPANT_LEASE_DURATION */


/* End CONST: PID_PARTICIPANT_LEASE_DURATION */


/* Begin CONST: PID_CONTENT_FILTER_PROPERTY */


/* End CONST: PID_CONTENT_FILTER_PROPERTY */


/* Begin CONST: PID_PARTICIPANT_GUID */


/* End CONST: PID_PARTICIPANT_GUID */


/* Begin CONST: PID_PARTICIPANT_ENTITYID */


/* End CONST: PID_PARTICIPANT_ENTITYID */


/* Begin CONST: PID_GROUP_GUID */


/* End CONST: PID_GROUP_GUID */


/* Begin CONST: PID_GROUP_ENTITYID */


/* End CONST: PID_GROUP_ENTITYID */


/* Begin CONST: PID_BUILTIN_ENDPOINT_SET */


/* End CONST: PID_BUILTIN_ENDPOINT_SET */


/* Begin CONST: PID_PROPERTY_LIST */


/* End CONST: PID_PROPERTY_LIST */


/* Begin CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* End CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* Begin CONST: PID_ENTITY_NAME */


/* End CONST: PID_ENTITY_NAME */


/* Begin CONST: PID_KEY_HASH */


/* End CONST: PID_KEY_HASH */


/* Begin CONST: PID_STATUS_INFO */


/* End CONST: PID_STATUS_INFO */


/* Begin CONST: PID_ENDPOINT_GUID */


/* End CONST: PID_ENDPOINT_GUID */


/* Begin CONST: PID_CONTENT_FILTER_INFO */


/* End CONST: PID_CONTENT_FILTER_INFO */


/* Begin CONST: PID_COHERENT_SET */


/* End CONST: PID_COHERENT_SET */


/* Begin CONST: PID_DIRECTED_WRITE */


/* End CONST: PID_DIRECTED_WRITE */


/* Begin CONST: PID_ORIGINAL_WRITER_INFO */


/* End CONST: PID_ORIGINAL_WRITER_INFO */


/* Begin CONST: PIDMASK_VENDOR_SPECIFIC */


/* End CONST: PIDMASK_VENDOR_SPECIFIC */


/* Begin CONST: PIDMASK_INCOMPATIBLE */


/* End CONST: PIDMASK_INCOMPATIBLE */


/* Begin CONST: PID_OPENDDS_BASE */


/* End CONST: PID_OPENDDS_BASE */


/* Begin CONST: PID_OPENDDS_LOCATOR */


/* End CONST: PID_OPENDDS_LOCATOR */


/* Begin CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* End CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* Begin UNION: Parameter */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Parameter& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case 5:
  case 7:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.string_data()) + 1;
      break;
    }
  case 44:
    {
      gen_find_size(uni.user_data(), size, padding);
      break;
    }
  case 45:
    {
      gen_find_size(uni.group_data(), size, padding);
      break;
    }
  case 46:
    {
      gen_find_size(uni.topic_data(), size, padding);
      break;
    }
  case 29:
    {
      gen_find_size(uni.durability(), size, padding);
      break;
    }
  case 30:
    {
      gen_find_size(uni.durability_service(), size, padding);
      break;
    }
  case 35:
    {
      gen_find_size(uni.deadline(), size, padding);
      break;
    }
  case 39:
    {
      gen_find_size(uni.latency_budget(), size, padding);
      break;
    }
  case 27:
    {
      gen_find_size(uni.liveliness(), size, padding);
      break;
    }
  case 26:
    {
      gen_find_size(uni.reliability(), size, padding);
      break;
    }
  case 43:
    {
      gen_find_size(uni.lifespan(), size, padding);
      break;
    }
  case 37:
    {
      gen_find_size(uni.destination_order(), size, padding);
      break;
    }
  case 64:
    {
      gen_find_size(uni.history(), size, padding);
      break;
    }
  case 65:
    {
      gen_find_size(uni.resource_limits(), size, padding);
      break;
    }
  case 31:
    {
      gen_find_size(uni.ownership(), size, padding);
      break;
    }
  case 6:
    {
      gen_find_size(uni.ownership_strength(), size, padding);
      break;
    }
  case 33:
    {
      gen_find_size(uni.presentation(), size, padding);
      break;
    }
  case 41:
    {
      gen_find_size(uni.partition(), size, padding);
      break;
    }
  case 4:
    {
      gen_find_size(uni.time_based_filter(), size, padding);
      break;
    }
  case 73:
    {
      gen_find_size(uni.transport_priority(), size, padding);
      break;
    }
  case 21:
    {
      gen_find_size(uni.version(), size, padding);
      break;
    }
  case 22:
    {
      gen_find_size(uni.vendor(), size, padding);
      break;
    }
  case 47:
  case 48:
  case 49:
  case 72:
  case 50:
  case 51:
    {
      gen_find_size(uni.locator(), size, padding);
      break;
    }
  case 17:
  case 12:
  case 69:
  case 11:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.ipv4_address());
      break;
    }
  case 14:
  case 13:
  case 70:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.udpv4_port());
      break;
    }
  case 67:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
      break;
    }
  case 52:
    {
      gen_find_size(uni.count(), size, padding);
      break;
    }
  case 68:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.participant_builtin_endpoints());
      break;
    }
  case 2:
    {
      gen_find_size(uni.duration(), size, padding);
      break;
    }
  case 53:
    {
      gen_find_size(uni.content_filter_property(), size, padding);
      break;
    }
  case 80:
  case 90:
  case 82:
  case 45058:
    {
      gen_find_size(uni.guid(), size, padding);
      break;
    }
  case 81:
  case 83:
    {
      gen_find_size(uni.entity_id(), size, padding);
      break;
    }
  case 88:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.builtin_endpoints());
      break;
    }
  case 89:
    {
      gen_find_size(uni.properties(), size, padding);
      break;
    }
  case 96:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.type_max_size_serialized());
      break;
    }
  case 98:
    {
      gen_find_size(uni.entity_name(), size, padding);
      break;
    }
  case 112:
    {
      gen_find_size(uni.key_hash(), size, padding);
      break;
    }
  case 113:
    {
      gen_find_size(uni.status_info(), size, padding);
      break;
    }
  case 85:
    {
      gen_find_size(uni.content_filter_info(), size, padding);
      break;
    }
  case 86:
    {
      gen_find_size(uni.coherent_set(), size, padding);
      break;
    }
  case 87:
    {
      gen_find_size(uni.directed_write(), size, padding);
      break;
    }
  case 97:
    {
      gen_find_size(uni.original_writer_info(), size, padding);
      break;
    }
  case 45057:
    {
      gen_find_size(uni.opendds_locator(), size, padding);
      break;
    }
  default:
    {
      gen_find_size(uni.unknown_data(), size, padding);
      break;
    }
  }
  size += 4; // parameterId & length
}

bool operator<<(Serializer& outer_strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  if (!(outer_strm << uni._d())) {
    return false;
  }
  size_t size = 0, pad = 0;
  gen_find_size(uni, size, pad);
  size -= 4; // parameterId & length
  const size_t post_pad = 4 - ((size + pad) % 4);
  const size_t total = size + pad + ((post_pad < 4) ? post_pad : 0);
  if (size + pad > ACE_UINT16_MAX || !(outer_strm << ACE_CDR::UShort(total))) {
    return false;
  }
  ACE_Message_Block param(size + pad);
  Serializer strm(&param, outer_strm.swap_bytes(), outer_strm.alignment());
  if (!insertParamData(strm, uni)) {
    return false;
  }
  const ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.rd_ptr());
  if (!outer_strm.write_octet_array(data, ACE_CDR::ULong(param.length()))) {
    return false;
  }
  if (post_pad < 4 && outer_strm.alignment() != Serializer::ALIGN_NONE) {
    static const ACE_CDR::Octet padding[3] = {0};
    return outer_strm.write_octet_array(padding, ACE_CDR::ULong(post_pad));
  }
  return true;
}

bool insertParamData(Serializer& strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case 5:
  case 7:
    {
      return (strm << uni.string_data());
    }
  case 44:
    {
      return (strm << uni.user_data());
    }
  case 45:
    {
      return (strm << uni.group_data());
    }
  case 46:
    {
      return (strm << uni.topic_data());
    }
  case 29:
    {
      return (strm << uni.durability());
    }
  case 30:
    {
      return (strm << uni.durability_service());
    }
  case 35:
    {
      return (strm << uni.deadline());
    }
  case 39:
    {
      return (strm << uni.latency_budget());
    }
  case 27:
    {
      return (strm << uni.liveliness());
    }
  case 26:
    {
      return (strm << uni.reliability());
    }
  case 43:
    {
      return (strm << uni.lifespan());
    }
  case 37:
    {
      return (strm << uni.destination_order());
    }
  case 64:
    {
      return (strm << uni.history());
    }
  case 65:
    {
      return (strm << uni.resource_limits());
    }
  case 31:
    {
      return (strm << uni.ownership());
    }
  case 6:
    {
      return (strm << uni.ownership_strength());
    }
  case 33:
    {
      return (strm << uni.presentation());
    }
  case 41:
    {
      return (strm << uni.partition());
    }
  case 4:
    {
      return (strm << uni.time_based_filter());
    }
  case 73:
    {
      return (strm << uni.transport_priority());
    }
  case 21:
    {
      return (strm << uni.version());
    }
  case 22:
    {
      return (strm << uni.vendor());
    }
  case 47:
  case 48:
  case 49:
  case 72:
  case 50:
  case 51:
    {
      return (strm << uni.locator());
    }
  case 17:
  case 12:
  case 69:
  case 11:
    {
      return (strm << uni.ipv4_address());
    }
  case 14:
  case 13:
  case 70:
    {
      return (strm << uni.udpv4_port());
    }
  case 67:
    {
      return (strm << ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
    }
  case 52:
    {
      return (strm << uni.count());
    }
  case 68:
    {
      return (strm << uni.participant_builtin_endpoints());
    }
  case 2:
    {
      return (strm << uni.duration());
    }
  case 53:
    {
      return (strm << uni.content_filter_property());
    }
  case 80:
  case 90:
  case 82:
  case 45058:
    {
      return (strm << uni.guid());
    }
  case 81:
  case 83:
    {
      return (strm << uni.entity_id());
    }
  case 88:
    {
      return (strm << uni.builtin_endpoints());
    }
  case 89:
    {
      return (strm << uni.properties());
    }
  case 96:
    {
      return (strm << uni.type_max_size_serialized());
    }
  case 98:
    {
      return (strm << uni.entity_name());
    }
  case 112:
    {
      return (strm << uni.key_hash());
    }
  case 113:
    {
      return (strm << uni.status_info());
    }
  case 85:
    {
      return (strm << uni.content_filter_info());
    }
  case 86:
    {
      return (strm << uni.coherent_set());
    }
  case 87:
    {
      return (strm << uni.directed_write());
    }
  case 97:
    {
      return (strm << uni.original_writer_info());
    }
  case 45057:
    {
      return (strm << uni.opendds_locator());
    }
  default:
    {
      return (strm << uni.unknown_data());
    }
  }
}

bool operator>>(Serializer& outer_strm, OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  ACE_CDR::UShort disc, size;
  if (!(outer_strm >> disc) || !(outer_strm >> size)) {
    return false;
  }
  if (disc == OpenDDS::RTPS::PID_SENTINEL) {
    uni._d(OpenDDS::RTPS::PID_SENTINEL);
    return true;
  }
  ACE_Message_Block param(size);
  ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.wr_ptr());
  if (!outer_strm.read_octet_array(data, size)) {
    return false;
  }
  param.wr_ptr(size);
  Serializer strm(&param, outer_strm.swap_bytes(), Serializer::ALIGN_CDR);
  switch (disc) {
  case 5:
  case 7:
    {
      CORBA::String_var tmp;
      if (strm >> tmp.out()) {
        uni.string_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 44:
    {
      DDS::UserDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.user_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 45:
    {
      DDS::GroupDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.group_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 46:
    {
      DDS::TopicDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.topic_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 29:
    {
      DDS::DurabilityQosPolicy tmp;
      if (strm >> tmp) {
        uni.durability(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 30:
    {
      DDS::DurabilityServiceQosPolicy tmp;
      if (strm >> tmp) {
        uni.durability_service(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 35:
    {
      DDS::DeadlineQosPolicy tmp;
      if (strm >> tmp) {
        uni.deadline(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 39:
    {
      DDS::LatencyBudgetQosPolicy tmp;
      if (strm >> tmp) {
        uni.latency_budget(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 27:
    {
      DDS::LivelinessQosPolicy tmp;
      if (strm >> tmp) {
        uni.liveliness(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 26:
    {
      DDS::ReliabilityQosPolicy tmp;
      if (strm >> tmp) {
        uni.reliability(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 43:
    {
      DDS::LifespanQosPolicy tmp;
      if (strm >> tmp) {
        uni.lifespan(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 37:
    {
      DDS::DestinationOrderQosPolicy tmp;
      if (strm >> tmp) {
        uni.destination_order(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 64:
    {
      DDS::HistoryQosPolicy tmp;
      if (strm >> tmp) {
        uni.history(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 65:
    {
      DDS::ResourceLimitsQosPolicy tmp;
      if (strm >> tmp) {
        uni.resource_limits(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 31:
    {
      DDS::OwnershipQosPolicy tmp;
      if (strm >> tmp) {
        uni.ownership(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 6:
    {
      DDS::OwnershipStrengthQosPolicy tmp;
      if (strm >> tmp) {
        uni.ownership_strength(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 33:
    {
      DDS::PresentationQosPolicy tmp;
      if (strm >> tmp) {
        uni.presentation(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 41:
    {
      DDS::PartitionQosPolicy tmp;
      if (strm >> tmp) {
        uni.partition(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 4:
    {
      DDS::TimeBasedFilterQosPolicy tmp;
      if (strm >> tmp) {
        uni.time_based_filter(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 73:
    {
      DDS::TransportPriorityQosPolicy tmp;
      if (strm >> tmp) {
        uni.transport_priority(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 21:
    {
      OpenDDS::RTPS::ProtocolVersion_t tmp;
      if (strm >> tmp) {
        uni.version(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 22:
    {
      OpenDDS::RTPS::VendorId_t tmp;
      if (strm >> tmp) {
        uni.vendor(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 47:
  case 48:
  case 49:
  case 72:
  case 50:
  case 51:
    {
      OpenDDS::RTPS::Locator_t tmp;
      if (strm >> tmp) {
        uni.locator(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 17:
  case 12:
  case 69:
  case 11:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.ipv4_address(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 14:
  case 13:
  case 70:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.udpv4_port(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 67:
    {
      CORBA::Boolean tmp;
      if (strm >> ACE_InputCDR::to_boolean(tmp)) {
        uni.expects_inline_qos(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 52:
    {
      OpenDDS::RTPS::Count_t tmp;
      if (strm >> tmp) {
        uni.count(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 68:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.participant_builtin_endpoints(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 2:
    {
      OpenDDS::RTPS::Duration_t tmp;
      if (strm >> tmp) {
        uni.duration(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 53:
    {
      OpenDDS::RTPS::ContentFilterProperty_t tmp;
      if (strm >> tmp) {
        uni.content_filter_property(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 80:
  case 90:
  case 82:
  case 45058:
    {
      OpenDDS::RTPS::GUID_t tmp;
      if (strm >> tmp) {
        uni.guid(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 81:
  case 83:
    {
      OpenDDS::RTPS::EntityId_t tmp;
      if (strm >> tmp) {
        uni.entity_id(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 88:
    {
      OpenDDS::RTPS::BuiltinEndpointSet_t tmp;
      if (strm >> tmp) {
        uni.builtin_endpoints(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 89:
    {
      OpenDDS::RTPS::PropertySeq tmp;
      if (strm >> tmp) {
        uni.properties(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 96:
    {
      CORBA::Long tmp;
      if (strm >> tmp) {
        uni.type_max_size_serialized(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 98:
    {
      OpenDDS::RTPS::EntityName_t tmp;
      if (strm >> tmp) {
        uni.entity_name(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 112:
    {
      OpenDDS::RTPS::KeyHash_t tmp;
      if (strm >> tmp) {
        uni.key_hash(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 113:
    {
      OpenDDS::RTPS::StatusInfo_t tmp;
      if (strm >> tmp) {
        uni.status_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 85:
    {
      OpenDDS::RTPS::ContentFilterInfo_t tmp;
      if (strm >> tmp) {
        uni.content_filter_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 86:
    {
      OpenDDS::RTPS::SequenceNumber_t tmp;
      if (strm >> tmp) {
        uni.coherent_set(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 87:
    {
      OpenDDS::RTPS::GUIDSeq tmp;
      if (strm >> tmp) {
        uni.directed_write(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 97:
    {
      OpenDDS::RTPS::OriginalWriterInfo_t tmp;
      if (strm >> tmp) {
        uni.original_writer_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 45057:
    {
      OpenDDS::DCPS::TransportLocator tmp;
      if (strm >> tmp) {
        uni.opendds_locator(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    {
      uni.unknown_data(OpenDDS::RTPS::OctetSeq(size));
      uni.unknown_data().length(size);
      std::memcpy(uni.unknown_data().get_buffer(), data, size);
      uni._d(disc);
    }
  }
  return true;
}

}  }

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Parameter*)
{
  ACE_UNUSED_ARG(ser);
  CORBA::UShort disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case 5:
  case 7:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
    }
    break;
  case 44:
    gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    break;
  case 45:
    gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    break;
  case 46:
    gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    break;
  case 29:
    gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    break;
  case 30:
    gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    break;
  case 35:
    gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    break;
  case 39:
    gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    break;
  case 27:
    gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    break;
  case 26:
    gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    break;
  case 43:
    gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    break;
  case 37:
    gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    break;
  case 64:
    gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    break;
  case 65:
    gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    break;
  case 31:
    gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    break;
  case 6:
    gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
    break;
  case 33:
    gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    break;
  case 41:
    gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    break;
  case 4:
    gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
    break;
  case 73:
    gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    break;
  case 21:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    break;
  case 22:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    break;
  case 47:
  case 48:
  case 49:
  case 72:
  case 50:
  case 51:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Locator_t*>(0));
    break;
  case 17:
  case 12:
  case 69:
  case 11:
    ser.skip(1, 4);
    break;
  case 14:
  case 13:
  case 70:
    ser.skip(1, 4);
    break;
  case 67:
    ser.skip(1, 1);
    break;
  case 52:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    break;
  case 68:
    ser.skip(1, 4);
    break;
  case 2:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0));
    break;
  case 53:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ContentFilterProperty_t*>(0));
    break;
  case 80:
  case 90:
  case 82:
  case 45058:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUID_t*>(0));
    break;
  case 81:
  case 83:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityId_t*>(0));
    break;
  case 88:
    ser.skip(1, 4);
    break;
  case 89:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::PropertySeq*>(0));
    break;
  case 96:
    ser.skip(1, 4);
    break;
  case 98:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityName_t*>(0));
    break;
  case 112:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::KeyHash_t*>(0));
    break;
  case 113:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::StatusInfo_t*>(0));
    break;
  case 85:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ContentFilterInfo_t*>(0));
    break;
  case 86:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    break;
  case 87:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GUIDSeq*>(0));
    break;
  case 97:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OriginalWriterInfo_t*>(0));
    break;
  case 45057:
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0));
    break;
  default:
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetSeq*>(0));
    break;
  }
}

}  }

#endif

/* End UNION: Parameter */

/* End MODULE: RTPS */

/* End MODULE: OpenDDS */
